module.exports = [
"[project]/node_modules/inngest/_virtual/rolldown_runtime.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "__export",
    ()=>__export,
    "__require",
    ()=>__require
]);
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$module__$5b$external$5d$__$28$node$3a$module$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:module [external] (node:module, cjs)");
const __TURBOPACK__import$2e$meta__ = {
    get url () {
        return `file://${__turbopack_context__.P("node_modules/inngest/_virtual/rolldown_runtime.js")}`;
    }
};
;
//#region rolldown:runtime
var __defProp = Object.defineProperty;
var __export = (all)=>{
    let target = {};
    for(var name in all)__defProp(target, name, {
        get: all[name],
        enumerable: true
    });
    return target;
};
var __require = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$module__$5b$external$5d$__$28$node$3a$module$2c$__cjs$29$__["createRequire"])(__TURBOPACK__import$2e$meta__.url);
;
}),
"[project]/node_modules/inngest/helpers/consts.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "ExecutionVersion",
    ()=>ExecutionVersion,
    "debugPrefix",
    ()=>debugPrefix,
    "defaultDevServerHost",
    ()=>defaultDevServerHost,
    "defaultInngestApiBaseUrl",
    ()=>defaultInngestApiBaseUrl,
    "defaultInngestEventBaseUrl",
    ()=>defaultInngestEventBaseUrl,
    "dummyEventKey",
    ()=>dummyEventKey,
    "envKeys",
    ()=>envKeys,
    "headerKeys",
    ()=>headerKeys,
    "internalEvents",
    ()=>internalEvents,
    "logPrefix",
    ()=>logPrefix,
    "probe",
    ()=>probe,
    "queryKeys",
    ()=>queryKeys,
    "syncKind",
    ()=>syncKind
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$chalk$2f$source$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/chalk/source/index.js [app-route] (ecmascript)");
;
//#region src/helpers/consts.ts
/**
* Keys for accessing query parameters included in requests from Inngest to run
* functions.
*
* Used internally to create handlers using `InngestCommHandler`, but can be
* imported to be used if creating a custom handler outside of the package.
*
* @public
*/ let queryKeys = /* @__PURE__ */ function(queryKeys$1) {
    queryKeys$1["DeployId"] = "deployId";
    queryKeys$1["FnId"] = "fnId";
    queryKeys$1["Probe"] = "probe";
    queryKeys$1["StepId"] = "stepId";
    return queryKeys$1;
}({});
let probe = /* @__PURE__ */ function(probe$1) {
    probe$1["Trust"] = "trust";
    return probe$1;
}({});
let envKeys = /* @__PURE__ */ function(envKeys$1) {
    envKeys$1["InngestSigningKey"] = "INNGEST_SIGNING_KEY";
    envKeys$1["InngestSigningKeyFallback"] = "INNGEST_SIGNING_KEY_FALLBACK";
    envKeys$1["InngestEventKey"] = "INNGEST_EVENT_KEY";
    /**
	* @deprecated Removed in v3. Use {@link InngestBaseUrl} instead.
	*/ envKeys$1["InngestDevServerUrl"] = "INNGEST_DEVSERVER_URL";
    envKeys$1["InngestEnvironment"] = "INNGEST_ENV";
    envKeys$1["InngestBaseUrl"] = "INNGEST_BASE_URL";
    envKeys$1["InngestEventApiBaseUrl"] = "INNGEST_EVENT_API_BASE_URL";
    envKeys$1["InngestApiBaseUrl"] = "INNGEST_API_BASE_URL";
    envKeys$1["InngestServeHost"] = "INNGEST_SERVE_HOST";
    envKeys$1["InngestServePath"] = "INNGEST_SERVE_PATH";
    envKeys$1["InngestLogLevel"] = "INNGEST_LOG_LEVEL";
    envKeys$1["InngestStreaming"] = "INNGEST_STREAMING";
    envKeys$1["InngestDevMode"] = "INNGEST_DEV";
    envKeys$1["InngestAllowInBandSync"] = "INNGEST_ALLOW_IN_BAND_SYNC";
    /**
	* @deprecated It's unknown what this env var was used for, but we do not
	* provide explicit support for it. Prefer using `INNGEST_ENV` instead.
	*/ envKeys$1["BranchName"] = "BRANCH_NAME";
    /**
	* The git branch of the commit the deployment was triggered by. Example:
	* `improve-about-page`.
	*
	* {@link https://vercel.com/docs/concepts/projects/environment-variables/system-environment-variables#system-environment-variables}
	*/ envKeys$1["VercelBranch"] = "VERCEL_GIT_COMMIT_REF";
    /**
	* Expected to be `"1"` if defined.
	*/ envKeys$1["IsVercel"] = "VERCEL";
    /**
	* The branch name of the current deployment. May only be accessible at build
	* time, but included here just in case.
	*
	* {@link https://developers.cloudflare.com/pages/platform/build-configuration/#environment-variables}
	*/ envKeys$1["CloudflarePagesBranch"] = "CF_PAGES_BRANCH";
    /**
	* Expected to be `"1"` if defined.
	*/ envKeys$1["IsCloudflarePages"] = "CF_PAGES";
    /**
	* The branch name of the deployment from Git to Netlify, if available.
	*
	* {@link https://docs.netlify.com/configure-builds/environment-variables/#git-metadata}
	*/ envKeys$1["NetlifyBranch"] = "BRANCH";
    /**
	* Expected to be `"true"` if defined.
	*/ envKeys$1["IsNetlify"] = "NETLIFY";
    /**
	* The Git branch for a service or deploy.
	*
	* {@link https://render.com/docs/environment-variables#all-services}
	*/ envKeys$1["RenderBranch"] = "RENDER_GIT_BRANCH";
    /**
	* Expected to be `"true"` if defined.
	*/ envKeys$1["IsRender"] = "RENDER";
    /**
	* The branch that triggered the deployment. Example: `main`
	*
	* {@link https://docs.railway.app/develop/variables#railway-provided-variables}
	*/ envKeys$1["RailwayBranch"] = "RAILWAY_GIT_BRANCH";
    /**
	* The railway environment for the deployment. Example: `production`
	*
	* {@link https://docs.railway.app/develop/variables#railway-provided-variables}
	*/ envKeys$1["RailwayEnvironment"] = "RAILWAY_ENVIRONMENT";
    envKeys$1["VercelEnvKey"] = "VERCEL_ENV";
    envKeys$1["OpenAiApiKey"] = "OPENAI_API_KEY";
    envKeys$1["GeminiApiKey"] = "GEMINI_API_KEY";
    envKeys$1["AnthropicApiKey"] = "ANTHROPIC_API_KEY";
    return envKeys$1;
}({});
/**
* Keys for accessing headers included in requests from Inngest to run
* functions.
*
* Used internally to create handlers using `InngestCommHandler`, but can be
* imported to be used if creating a custom handler outside of the package.
*
* @public
*/ let headerKeys = /* @__PURE__ */ function(headerKeys$1) {
    headerKeys$1["ContentLength"] = "content-length";
    headerKeys$1["Signature"] = "x-inngest-signature";
    headerKeys$1["SdkVersion"] = "x-inngest-sdk";
    headerKeys$1["Environment"] = "x-inngest-env";
    headerKeys$1["Platform"] = "x-inngest-platform";
    headerKeys$1["Framework"] = "x-inngest-framework";
    headerKeys$1["NoRetry"] = "x-inngest-no-retry";
    headerKeys$1["RequestVersion"] = "x-inngest-req-version";
    headerKeys$1["RetryAfter"] = "retry-after";
    headerKeys$1["InngestServerKind"] = "x-inngest-server-kind";
    headerKeys$1["InngestExpectedServerKind"] = "x-inngest-expected-server-kind";
    headerKeys$1["InngestSyncKind"] = "x-inngest-sync-kind";
    headerKeys$1["EventIdSeed"] = "x-inngest-event-id-seed";
    headerKeys$1["TraceParent"] = "traceparent";
    headerKeys$1["TraceState"] = "tracestate";
    return headerKeys$1;
}({});
const defaultInngestApiBaseUrl = "https://api.inngest.com/";
const defaultInngestEventBaseUrl = "https://inn.gs/";
const defaultDevServerHost = "http://localhost:8288/";
/**
* Events that Inngest may send internally that can be used to trigger
* functions.
*
* @public
*/ let internalEvents = /* @__PURE__ */ function(internalEvents$1) {
    /**
	* A function has failed after exhausting all available retries. This event
	* will contain the original event and the error that caused the failure.
	*/ internalEvents$1["FunctionFailed"] = "inngest/function.failed";
    internalEvents$1["FunctionInvoked"] = "inngest/function.invoked";
    internalEvents$1["FunctionFinished"] = "inngest/function.finished";
    internalEvents$1["FunctionCancelled"] = "inngest/function.cancelled";
    internalEvents$1["ScheduledTimer"] = "inngest/scheduled.timer";
    return internalEvents$1;
}({});
const logPrefix = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$chalk$2f$source$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].magenta.bold("[Inngest]");
const debugPrefix = "inngest";
const dummyEventKey = "NO_EVENT_KEY_SET";
let syncKind = /* @__PURE__ */ function(syncKind$1) {
    syncKind$1["InBand"] = "in_band";
    syncKind$1["OutOfBand"] = "out_of_band";
    return syncKind$1;
}({});
/**
* The execution models the SDK is aware of.
*
* This is used in a number of places to ensure all execution versions are
* accounted for for a given operation.
*/ let ExecutionVersion = /* @__PURE__ */ function(ExecutionVersion$1) {
    /**
	* Very legacy, initial version of the executor. Uses hashed op objects and
	* `pos` to determine the order of execution and which ops to run.
	*
	* Very stubborn about determinism.
	*/ ExecutionVersion$1[ExecutionVersion$1["V0"] = 0] = "V0";
    /**
	* Uses a more flexible approach to execution and is more lenient about
	* determinism, allowing non-step async actions and non-determinism.
	*
	* Nowhere near as stubborn about determinism and so can silently migrate
	* between versions after bug fixes.
	*/ ExecutionVersion$1[ExecutionVersion$1["V1"] = 1] = "V1";
    /**
	* Identical to V1, but allows the Executor to optimize parallel calls, hugely
	* reducing traffic going to/from the SDK.
	*/ ExecutionVersion$1[ExecutionVersion$1["V2"] = 2] = "V2";
    return ExecutionVersion$1;
}({});
;
 //# sourceMappingURL=consts.js.map
}),
"[project]/node_modules/inngest/version.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

//#region src/version.ts
__turbopack_context__.s([
    "version",
    ()=>version
]);
const version = "3.43.1";
;
 //# sourceMappingURL=version.js.map
}),
"[project]/node_modules/inngest/helpers/strings.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "hashEventKey",
    ()=>hashEventKey,
    "hashSigningKey",
    ()=>hashSigningKey,
    "slugify",
    ()=>slugify,
    "stringify",
    ()=>stringify$1,
    "stringifyUnknown",
    ()=>stringifyUnknown,
    "timeStr",
    ()=>timeStr
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hash$2e$js$2f$lib$2f$hash$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/hash.js/lib/hash.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$json$2d$stringify$2d$safe$2f$stringify$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/json-stringify-safe/stringify.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ms$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/ms/index.js [app-route] (ecmascript)");
;
;
;
//#region src/helpers/strings.ts
const { sha256 } = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hash$2e$js$2f$lib$2f$hash$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"];
/**
* Safely `JSON.stringify()` an `input`, handling circular refernences and
* removing `BigInt` values.
*/ const stringify$1 = (input)=>{
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$json$2d$stringify$2d$safe$2f$stringify$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(input, (_key, value)=>{
        if (typeof value !== "bigint") return value;
    });
};
/**
* Returns a slugified string used to generate consistent IDs.
*
* This can be used to generate a consistent ID for a function when migrating
* from v2 to v3 of the SDK.
*
* @public
*/ const slugify = (str)=>{
    const join = "-";
    return str.toLowerCase().replace(/[^a-z0-9-]+/g, join).replace(/-+/g, join).split(join).filter(Boolean).join(join);
};
const second = 1 * 1e3;
const minute = second * 60;
const hour = minute * 60;
const day = hour * 24;
/**
* A collection of periods in milliseconds and their suffixes used when creating
* time strings.
*/ const periods = [
    [
        "w",
        day * 7
    ],
    [
        "d",
        day
    ],
    [
        "h",
        hour
    ],
    [
        "m",
        minute
    ],
    [
        "s",
        second
    ]
];
/**
* Convert a given `Date`, `number`, or `ms`-compatible `string` to a
* Inngest sleep-compatible time string (e.g. `"1d"` or `"2h3010s"`).
*
* Can optionally provide a `now` date to use as the base for the calculation,
* otherwise a new date will be created on invocation.
*/ const timeStr = (input)=>{
    if (input instanceof Date) return input.toISOString();
    const milliseconds = typeof input === "string" ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ms$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(input) : input;
    const [, timeStr$1] = periods.reduce(([num, str], [suffix, period])=>{
        const numPeriods = Math.floor(num / period);
        if (numPeriods > 0) return [
            num % period,
            `${str}${numPeriods}${suffix}`
        ];
        return [
            num,
            str
        ];
    }, [
        milliseconds,
        ""
    ]);
    return timeStr$1;
};
/**
* Given an unknown input, stringify it if it's a boolean, a number, or a
* string, else return `undefined`.
*/ const stringifyUnknown = (input)=>{
    if (typeof input === "boolean" || typeof input === "number" || typeof input === "string") return input.toString();
};
const hashEventKey = (eventKey)=>{
    return sha256().update(eventKey).digest("hex");
};
const hashSigningKey = (signingKey)=>{
    if (!signingKey) return "";
    const prefix = signingKey.match(/^signkey-[\w]+-/)?.shift() || "";
    const key = signingKey.replace(/^signkey-[\w]+-/, "");
    return `${prefix}${sha256().update(key, "hex").digest("hex")}`;
};
;
 //# sourceMappingURL=strings.js.map
}),
"[project]/node_modules/inngest/helpers/env.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Mode",
    ()=>Mode,
    "allProcessEnv",
    ()=>allProcessEnv,
    "devServerHost",
    ()=>devServerHost,
    "getEnvironmentName",
    ()=>getEnvironmentName,
    "getFetch",
    ()=>getFetch,
    "getMode",
    ()=>getMode,
    "getPlatformName",
    ()=>getPlatformName,
    "getResponse",
    ()=>getResponse,
    "inngestHeaders",
    ()=>inngestHeaders,
    "parseAsBoolean",
    ()=>parseAsBoolean,
    "platformSupportsStreaming",
    ()=>platformSupportsStreaming,
    "processEnv",
    ()=>processEnv
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$_virtual$2f$rolldown_runtime$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/inngest/_virtual/rolldown_runtime.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/inngest/helpers/consts.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$version$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/inngest/version.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$strings$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/inngest/helpers/strings.js [app-route] (ecmascript)");
;
;
;
;
//#region src/helpers/env.ts
/**
* devServerHost returns the dev server host by searching for the INNGEST_DEVSERVER_URL
* environment variable (plus project prefixces for eg. react, such as REACT_APP_INNGEST_DEVSERVER_URL).
*
* If not found this returns undefined, indicating that the env var has not been set.
*
* @example devServerHost()
*/ const devServerHost = (env = allProcessEnv())=>{
    const prefixes = [
        "REACT_APP_",
        "NEXT_PUBLIC_"
    ];
    return [
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["envKeys"].InngestBaseUrl,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["envKeys"].InngestDevMode
    ].flatMap((key)=>{
        return prefixes.map((prefix)=>{
            return env[prefix + key];
        });
    }).find((v)=>{
        if (!v) return;
        try {
            return Boolean(new URL(v));
        } catch  {}
    });
};
const checkFns = ((checks)=>checks)({
    equals: (actual, expected)=>actual === expected,
    "starts with": (actual, expected)=>expected ? actual?.startsWith(expected) ?? false : false,
    "is truthy": (actual)=>Boolean(actual),
    "is truthy but not": (actual, expected)=>Boolean(actual) && actual !== expected
});
const prodChecks = [
    [
        "CF_PAGES",
        "equals",
        "1"
    ],
    [
        "CONTEXT",
        "starts with",
        "prod"
    ],
    [
        "ENVIRONMENT",
        "starts with",
        "prod"
    ],
    [
        "NODE_ENV",
        "starts with",
        "prod"
    ],
    [
        "VERCEL_ENV",
        "starts with",
        "prod"
    ],
    [
        "DENO_DEPLOYMENT_ID",
        "is truthy"
    ],
    [
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["envKeys"].VercelEnvKey,
        "is truthy but not",
        "development"
    ],
    [
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["envKeys"].IsNetlify,
        "is truthy"
    ],
    [
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["envKeys"].IsRender,
        "is truthy"
    ],
    [
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["envKeys"].RailwayBranch,
        "is truthy"
    ],
    [
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["envKeys"].IsCloudflarePages,
        "is truthy"
    ]
];
var Mode = class {
    type;
    /**
	* Whether the mode was explicitly set, or inferred from other sources.
	*/ isExplicit;
    explicitDevUrl;
    env;
    constructor({ type, isExplicit, explicitDevUrl, env = allProcessEnv() }){
        this.env = env;
        this.type = type;
        this.isExplicit = isExplicit || Boolean(explicitDevUrl);
        this.explicitDevUrl = explicitDevUrl;
    }
    get isDev() {
        return this.type === "dev";
    }
    get isCloud() {
        return this.type === "cloud";
    }
    get isInferred() {
        return !this.isExplicit;
    }
    /**
	* If we are explicitly in a particular mode, retrieve the URL that we are
	* sure we should be using, not considering any environment variables or other
	* influences.
	*/ getExplicitUrl(defaultCloudUrl) {
        if (!this.isExplicit) return;
        if (this.explicitDevUrl) return this.explicitDevUrl.href;
        if (this.isCloud) return defaultCloudUrl;
        if (this.isDev) return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["defaultDevServerHost"];
    }
};
/**
* Returns the mode of the current environment, based off of either passed
* environment variables or `process.env`, or explicit settings.
*/ const getMode = ({ env = allProcessEnv(), client, explicitMode } = {})=>{
    if (explicitMode) return new Mode({
        type: explicitMode,
        isExplicit: true,
        env
    });
    if (client?.["mode"].isExplicit) return client["mode"];
    if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["envKeys"].InngestDevMode in env) {
        if (typeof env[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["envKeys"].InngestDevMode] === "string") try {
            const explicitDevUrl = new URL(env[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["envKeys"].InngestDevMode]);
            return new Mode({
                type: "dev",
                isExplicit: true,
                explicitDevUrl,
                env
            });
        } catch  {}
        const envIsDev = parseAsBoolean(env[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["envKeys"].InngestDevMode]);
        if (typeof envIsDev === "boolean") return new Mode({
            type: envIsDev ? "dev" : "cloud",
            isExplicit: true,
            env
        });
    }
    const isProd = prodChecks.some(([key, checkKey, expected])=>{
        return checkFns[checkKey]((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$strings$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["stringifyUnknown"])(env[key]), expected);
    });
    return new Mode({
        type: isProd ? "cloud" : "dev",
        isExplicit: false,
        env
    });
};
/**
* getEnvironmentName returns the suspected branch name for this environment by
* searching through a set of common environment variables.
*
* This could be used to determine if we're on a branch deploy or not, though it
* should be noted that we don't know if this is the default branch or not.
*/ const getEnvironmentName = (env = allProcessEnv())=>{
    /**
	* Order is important; more than one of these env vars may be set, so ensure
	* that we check the most specific, most reliable env vars first.
	*/ return env[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["envKeys"].InngestEnvironment] || env[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["envKeys"].BranchName] || env[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["envKeys"].VercelBranch] || env[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["envKeys"].NetlifyBranch] || env[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["envKeys"].CloudflarePagesBranch] || env[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["envKeys"].RenderBranch] || env[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["envKeys"].RailwayBranch];
};
const processEnv = (key)=>{
    return allProcessEnv()[key];
};
/**
* allProcessEnv returns the current process environment variables, or an empty
* object if they cannot be read, making sure we support environments other than
* Node such as Deno, too.
*
* Using this ensures we don't dangerously access `process.env` in environments
* where it may not be defined, such as Deno or the browser.
*/ const allProcessEnv = ()=>{
    try {
        if ("TURBOPACK compile-time truthy", 1) return process.env;
    } catch (_err) {}
    try {
        const env = Deno.env.toObject();
        if (env) return env;
    } catch (_err) {}
    try {
        const env = Netlify.env.toObject();
        if (env) return env;
    } catch (_err) {}
    return {};
};
/**
* Generate a standardised set of headers based on input and environment
* variables.
*
*
*/ const inngestHeaders = (opts)=>{
    const sdkVersion = `inngest-js:v${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$version$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["version"]}`;
    const headers = {
        "Content-Type": "application/json",
        "User-Agent": sdkVersion,
        [__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["headerKeys"].SdkVersion]: sdkVersion
    };
    if (opts?.framework) headers[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["headerKeys"].Framework] = opts.framework;
    if (opts?.expectedServerKind) headers[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["headerKeys"].InngestExpectedServerKind] = opts.expectedServerKind;
    const env = {
        ...allProcessEnv(),
        ...opts?.env
    };
    const inngestEnv = opts?.inngestEnv || getEnvironmentName(env);
    if (inngestEnv) headers[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["headerKeys"].Environment] = inngestEnv;
    const platform = getPlatformName(env);
    if (platform) headers[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["headerKeys"].Platform] = platform;
    return {
        ...headers,
        ...opts?.client?.["headers"],
        ...opts?.extras
    };
};
/**
* A set of checks that, given an environment, will return `true` if the current
* environment is running on the platform with the given name.
*/ const platformChecks = {
    vercel: (env)=>env[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["envKeys"].IsVercel] === "1" || typeof EdgeRuntime === "string",
    netlify: (env)=>env[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["envKeys"].IsNetlify] === "true",
    "cloudflare-pages": (env)=>env[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["envKeys"].IsCloudflarePages] === "1",
    render: (env)=>env[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["envKeys"].IsRender] === "true",
    railway: (env)=>Boolean(env[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["envKeys"].RailwayEnvironment])
};
/**
* A set of checks that, given an environment, will return `true` if the current
* environment and platform supports streaming responses back to Inngest.
*
* Streaming capability is both framework and platform-based. Frameworks are
* supported in serve handlers, and platforms are checked here.
*
* As such, this record declares which platforms we explicitly support for
* streaming and is used by {@link platformSupportsStreaming}.
*/ const streamingChecks = {
    vercel: (_framework, _env)=>typeof EdgeRuntime === "string",
    "cloudflare-pages": ()=>true
};
const getPlatformName = (env)=>{
    return Object.keys(platformChecks).find((key)=>{
        return platformChecks[key](env);
    });
};
/**
* Returns `true` if we believe the current environment supports streaming
* responses back to Inngest.
*
* We run a check directly related to the platform we believe we're running on,
* usually based on environment variables.
*/ const platformSupportsStreaming = (framework, env = allProcessEnv())=>{
    return streamingChecks[getPlatformName(env)]?.(framework, env) ?? false;
};
/**
* A unique symbol used to mark a custom fetch implementation. We wrap the
* implementations to provide some extra control when handling errors.
*/ const CUSTOM_FETCH_MARKER = Symbol("Custom fetch implementation");
/**
* Given a potential fetch function, return the fetch function to use based on
* this and the environment.
*/ const getFetch = (givenFetch)=>{
    /**
	* If we've explicitly been given a fetch function, use that.
	*/ if (givenFetch) {
        if (CUSTOM_FETCH_MARKER in givenFetch) return givenFetch;
        /**
		* We wrap the given fetch function to provide some extra control when
		* handling errors.
		*/ const customFetch = async (...args)=>{
            try {
                return await givenFetch(...args);
            } catch (err) {
                /**
				* Capture warnings that are not simple fetch failures and highlight
				* them for the user.
				*
				* We also use this opportunity to log the causing error, as code higher
				* up the stack will likely abstract this.
				*/ if (!(err instanceof Error) || !err.message?.startsWith("fetch failed")) {
                    console.warn("A request failed when using a custom fetch implementation; this may be a misconfiguration. Make sure that your fetch client is correctly bound to the global scope.");
                    console.error(err);
                }
                throw err;
            }
        };
        /**
		* Mark the custom fetch implementation so that we can identify it later, in
		* addition to adding some runtime properties to it to make it seem as much
		* like the original fetch as possible.
		*/ Object.defineProperties(customFetch, {
            [CUSTOM_FETCH_MARKER]: {},
            name: {
                value: givenFetch.name
            },
            length: {
                value: givenFetch.length
            }
        });
        return customFetch;
    }
    /**
	* Browser or Node 18+
	*/ try {
        if (typeof globalThis !== "undefined" && "fetch" in globalThis) return fetch.bind(globalThis);
    } catch (_err) {}
    /**
	* Existing polyfilled fetch
	*/ if (typeof fetch !== "undefined") return fetch;
    /**
	* Environments where fetch cannot be found and must be polyfilled
	*/ return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$_virtual$2f$rolldown_runtime$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["__require"])("cross-fetch");
};
/**
* If `Response` isn't included in this environment, it's probably an earlier
* Node env that isn't already polyfilling. This function returns either the
* native `Response` or a polyfilled one.
*/ const getResponse = ()=>{
    if (typeof Response !== "undefined") return Response;
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$_virtual$2f$rolldown_runtime$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["__require"])("cross-fetch").Response;
};
/**
* Given an unknown value, try to parse it as a `boolean`. Useful for parsing
* environment variables that could be a selection of different values such as
* `"true"`, `"1"`.
*
* If the value could not be confidently parsed as a `boolean` or was seen to be
* `undefined`, this function returns `undefined`.
*/ const parseAsBoolean = (value)=>{
    if (typeof value === "boolean") return value;
    if (typeof value === "number") return Boolean(value);
    if (typeof value === "string") {
        const trimmed = value.trim().toLowerCase();
        if (trimmed === "undefined") return;
        if ([
            "true",
            "1"
        ].includes(trimmed)) return true;
        return false;
    }
};
;
 //# sourceMappingURL=env.js.map
}),
"[project]/node_modules/inngest/helpers/devserver.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "devServerAvailable",
    ()=>devServerAvailable,
    "devServerUrl",
    ()=>devServerUrl
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/inngest/helpers/consts.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$env$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/inngest/helpers/env.js [app-route] (ecmascript)");
;
;
//#region src/helpers/devserver.ts
/**
* Attempts to contact the dev server, returning a boolean indicating whether or
* not it was successful.
*
* @example devServerUrl(process.env[envKeys.DevServerUrl], "/your-path")
*/ const devServerAvailable = async (host = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["defaultDevServerHost"], fetch)=>{
    try {
        const url = devServerUrl(host, "/dev");
        await (await fetch(url.toString())).json();
        return true;
    } catch (_e) {
        return false;
    }
};
/**
* devServerUrl returns a full URL for the given path name.
*
* Because Cloudflare/V8 platforms don't allow process.env, you are expected
* to pass in the host from the dev server env key:
*
* @example devServerUrl(processEnv(envKeys.DevServerUrl), "/your-path")
* @example devServerUrl("http://localhost:8288/", "/your-path")
*/ const devServerUrl = (host = devServerHost$1(), pathname = "")=>{
    return new URL(pathname, host.includes("://") ? host : `http://${host}`);
};
/**
* devServerHost exports the development server's domain by inspecting env
* variables, or returns the default development server URL.
*
* This guarantees a specific URL as a string, as opposed to the env export
* which only returns a value of the env var is set.
*/ const devServerHost$1 = ()=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$env$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["devServerHost"])() || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["defaultDevServerHost"];
;
 //# sourceMappingURL=devserver.js.map
}),
"[project]/node_modules/inngest/helpers/enum.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

//#region src/helpers/enum.ts
/**
* Returns the value of an enum from a string value.
*
* If the value given is not a value from the enum, `undefined` is returned.
*/ __turbopack_context__.s([
    "enumFromValue",
    ()=>enumFromValue
]);
const enumFromValue = (enumType, value)=>{
    if (Object.values(enumType).includes(value)) return value;
};
;
 //# sourceMappingURL=enum.js.map
}),
"[project]/node_modules/inngest/components/NonRetriableError.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

//#region src/components/NonRetriableError.ts
/**
* An error that, when thrown, indicates to Inngest that the function should
* cease all execution and not retry.
*
* A `message` must be provided, and an optional `cause` can be provided to
* provide more context to the error.
*
* @public
*/ __turbopack_context__.s([
    "NonRetriableError",
    ()=>NonRetriableError
]);
var NonRetriableError = class extends Error {
    /**
	* The underlying cause of the error, if any.
	*
	* This will be serialized and sent to Inngest.
	*/ cause;
    constructor(message, options){
        super(message);
        this.cause = options?.cause;
        this.name = "NonRetriableError";
    }
};
;
 //# sourceMappingURL=NonRetriableError.js.map
}),
"[project]/node_modules/inngest/helpers/errors.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "ErrCode",
    ()=>ErrCode,
    "deserializeError",
    ()=>deserializeError$1,
    "errors_exports",
    ()=>errors_exports,
    "fixEventKeyMissingSteps",
    ()=>fixEventKeyMissingSteps,
    "functionStoppedRunningErr",
    ()=>functionStoppedRunningErr,
    "getErrorMessage",
    ()=>getErrorMessage,
    "minifyPrettyError",
    ()=>minifyPrettyError,
    "prettyError",
    ()=>prettyError,
    "rethrowError",
    ()=>rethrowError,
    "serializeError",
    ()=>serializeError$1
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$_virtual$2f$rolldown_runtime$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/inngest/_virtual/rolldown_runtime.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$components$2f$NonRetriableError$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/inngest/components/NonRetriableError.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/zod/v3/index.js [app-route] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__ = __turbopack_context__.i("[project]/node_modules/zod/v3/external.js [app-route] (ecmascript) <export * as z>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$chalk$2f$source$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/chalk/source/index.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$json$2d$stringify$2d$safe$2f$stringify$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/json-stringify-safe/stringify.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$serialize$2d$error$2d$cjs$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/serialize-error-cjs/dist/index.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$strip$2d$ansi$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/strip-ansi/index.js [app-route] (ecmascript)");
;
;
;
;
;
;
;
//#region src/helpers/errors.ts
var errors_exports = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$_virtual$2f$rolldown_runtime$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["__export"])({
    ErrCode: ()=>ErrCode,
    OutgoingResultError: ()=>OutgoingResultError,
    deserializeError: ()=>deserializeError$1,
    fixEventKeyMissingSteps: ()=>fixEventKeyMissingSteps,
    functionStoppedRunningErr: ()=>functionStoppedRunningErr,
    getErrorMessage: ()=>getErrorMessage,
    isSerializedError: ()=>isSerializedError,
    minifyPrettyError: ()=>minifyPrettyError,
    prettyError: ()=>prettyError,
    prettyErrorSplitter: ()=>prettyErrorSplitter,
    rethrowError: ()=>rethrowError,
    serializeError: ()=>serializeError$1
});
const SERIALIZED_KEY = "__serialized";
const SERIALIZED_VALUE = true;
/**
* Add first-class support for certain errors that we control, in addition to
* built-in errors such as `TypeError`.
*
* Adding these allows these non-standard errors to be correctly serialized,
* sent to Inngest, then deserialized back into the correct error type for users
* to react to correctly.
*
* Note that these errors only support `message?: string | undefined` as the
* input; more custom errors are not supported with this current strategy.
*/ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$serialize$2d$error$2d$cjs$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["errorConstructors"].set("NonRetriableError", __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$components$2f$NonRetriableError$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NonRetriableError"]);
/**
* Serialise an error to a serialized JSON string.
*
* Errors do not serialise nicely to JSON, so we use this function to convert
* them to a serialized JSON string. Doing this is also non-trivial for some
* errors, so we use the `serialize-error` package to do it for us.
*
* See {@link https://www.npmjs.com/package/serialize-error}
*
* This function is a small wrapper around that package to also add a `type`
* property to the serialised error, so that we can distinguish between
* serialised errors and other objects.
*
* Will not reserialise existing serialised errors.
*/ const serializeError$1 = (subject, allowUnknown = false)=>{
    try {
        const existingSerializedError = isSerializedError(subject);
        if (existingSerializedError) return existingSerializedError;
        if (typeof subject === "object" && subject !== null) {
            const serializedErr = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$serialize$2d$error$2d$cjs$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["serializeError"])(subject);
            if (!serializedErr.name && allowUnknown) return subject;
            const ret = {
                ...serializedErr,
                name: serializedErr.name || "Error",
                message: serializedErr.message || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$json$2d$stringify$2d$safe$2f$stringify$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(subject) || "Unknown error; error serialization could not find a message.",
                stack: serializedErr.stack || "",
                [SERIALIZED_KEY]: SERIALIZED_VALUE
            };
            let target = ret;
            const maxDepth = 5;
            for(let i = 0; i < maxDepth; i++){
                if (typeof target === "object" && target !== null && "cause" in target && target.cause) {
                    target = target.cause = serializeError$1(target.cause, true);
                    continue;
                }
                break;
            }
            return ret;
        }
        throw new Error("Error is not an object; strange throw value.");
    } catch  {
        if (allowUnknown) return subject;
        try {
            return {
                ...serializeError$1(new Error(typeof subject === "string" ? subject : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$json$2d$stringify$2d$safe$2f$stringify$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(subject)), false),
                stack: "",
                [SERIALIZED_KEY]: SERIALIZED_VALUE
            };
        } catch  {
            return {
                name: "Could not serialize source error",
                message: "Serializing the source error failed.",
                stack: "",
                [SERIALIZED_KEY]: SERIALIZED_VALUE
            };
        }
    }
};
/**
* Check if an object or a string is a serialised error created by
* {@link serializeError}.
*/ const isSerializedError = (value)=>{
    try {
        if (typeof value === "string") {
            const parsed = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
                [SERIALIZED_KEY]: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].literal(SERIALIZED_VALUE),
                name: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].enum([
                    ...Array.from(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$serialize$2d$error$2d$cjs$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["errorConstructors"].keys())
                ]),
                message: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
                stack: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string()
            }).passthrough().safeParse(JSON.parse(value));
            if (parsed.success) return parsed.data;
        }
        if (typeof value === "object" && value !== null) {
            if (Object.hasOwn(value, SERIALIZED_KEY) && value[SERIALIZED_KEY] === SERIALIZED_VALUE) return value;
        }
    } catch  {}
};
/**
* Deserialise an error created by {@link serializeError}.
*
* Ensures we only deserialise errors that meet a minimum level of
* applicability, inclusive of error handling to ensure that badly serialized
* errors are still handled.
*/ const deserializeError$1 = (subject, allowUnknown = false)=>{
    const requiredFields = [
        "name",
        "message"
    ];
    try {
        if (!requiredFields.every((field)=>{
            return Object.hasOwn(subject, field);
        })) throw new Error();
        const deserializedErr = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$serialize$2d$error$2d$cjs$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["deserializeError"])(subject);
        if ("cause" in deserializedErr) deserializedErr.cause = deserializeError$1(deserializedErr.cause, true);
        return deserializedErr;
    } catch  {
        if (allowUnknown) return subject;
        const err = /* @__PURE__ */ new Error("Unknown error; could not reserialize");
        /**
		* Remove the stack so that it's not misleadingly shown as the Inngest
		* internals.
		*/ err.stack = void 0;
        return err;
    }
};
let ErrCode = /* @__PURE__ */ function(ErrCode$1) {
    ErrCode$1["NESTING_STEPS"] = "NESTING_STEPS";
    /**
	* Legacy v0 execution error code for when a function has changed and no
	* longer matches its in-progress state.
	*
	* @deprecated Not for use in latest execution method.
	*/ ErrCode$1["NON_DETERMINISTIC_FUNCTION"] = "NON_DETERMINISTIC_FUNCTION";
    /**
	* Legacy v0 execution error code for when a function is found to be using
	* async actions after memoziation has occurred, which v0 doesn't support.
	*
	* @deprecated Not for use in latest execution method.
	*/ ErrCode$1["ASYNC_DETECTED_AFTER_MEMOIZATION"] = "ASYNC_DETECTED_AFTER_MEMOIZATION";
    /**
	* Legacy v0 execution error code for when a function is found to be using
	* steps after a non-step async action has occurred.
	*
	* @deprecated Not for use in latest execution method.
	*/ ErrCode$1["STEP_USED_AFTER_ASYNC"] = "STEP_USED_AFTER_ASYNC";
    ErrCode$1["AUTOMATIC_PARALLEL_INDEXING"] = "AUTOMATIC_PARALLEL_INDEXING";
    return ErrCode$1;
}({});
const prettyErrorSplitter = "=================================================";
/**
* Given an unknown `err`, mutate it to minify any pretty errors that it
* contains.
*/ const minifyPrettyError = (err)=>{
    try {
        if (!isError(err)) return err;
        if (!err.message.includes(prettyErrorSplitter)) return err;
        const sanitizedMessage = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$strip$2d$ansi$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(err.message);
        const message = sanitizedMessage.split("  ")[1]?.split("\n")[0]?.trim() || err.message;
        err.message = [
            sanitizedMessage.split("\n\nCode: ")[1]?.split("\n\n")[0]?.trim() || void 0,
            message
        ].filter(Boolean).join(" - ");
        if (err.stack) {
            const stackRest = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$strip$2d$ansi$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(err.stack).split(`${prettyErrorSplitter}\n`).slice(2).join("\n");
            err.stack = `${err.name}: ${err.message}\n${stackRest}`;
        }
        return err;
    } catch (_noopErr) {
        return err;
    }
};
/**
* Given an `err`, return a boolean representing whether it is in the shape of
* an `Error` or not.
*/ const isError = (err)=>{
    try {
        if (err instanceof Error) return true;
        if (typeof err !== "object" || err === null) return false;
        return Object.hasOwn(err, "name") && Object.hasOwn(err, "message");
    } catch (_noopErr) {
        return false;
    }
};
/**
* Given an `unknown` object, retrieve the `message` property from it, or fall
* back to the `fallback` string if it doesn't exist or is empty.
*/ const getErrorMessage = (err, fallback)=>{
    const { message } = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
        message: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().min(1)
    }).catch({
        message: fallback
    }).parse(err);
    return message;
};
/**
* Given a {@link PrettyError}, return a nicely-formatted string ready to log
* or throw.
*
* Useful for ensuring that errors are logged in a consistent, helpful format
* across the SDK by prompting for key pieces of information.
*/ const prettyError = ({ type = "error", whatHappened, otherwise, reassurance, toFixNow, why, consequences, stack, code })=>{
    const { icon, colorFn } = {
        error: {
            icon: "❌",
            colorFn: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$chalk$2f$source$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].red
        },
        warn: {
            icon: "⚠️",
            colorFn: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$chalk$2f$source$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].yellow
        }
    }[type];
    let header = `${icon}  ${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$chalk$2f$source$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].bold.underline(whatHappened.trim())}`;
    if (stack) header += "\n" + [
        .../* @__PURE__ */ new Error().stack?.split("\n").slice(1).filter(Boolean) || []
    ].join("\n");
    let toFixNowStr = (Array.isArray(toFixNow) ? toFixNow.map((s)=>s.trim()).filter(Boolean).map((s, i)=>`\t${i + 1}. ${s}`).join("\n") : toFixNow?.trim()) ?? "";
    if (Array.isArray(toFixNow) && toFixNowStr) toFixNowStr = `To fix this, you can take one of the following courses of action:\n\n${toFixNowStr}`;
    let body = [
        reassurance?.trim(),
        why?.trim(),
        consequences?.trim()
    ].filter(Boolean).join(" ");
    body += body ? `\n\n${toFixNowStr}` : toFixNowStr;
    const trailer = [
        otherwise?.trim()
    ].filter(Boolean).join(" ");
    const message = [
        prettyErrorSplitter,
        header,
        body,
        trailer,
        code ? `Code: ${code}` : "",
        prettyErrorSplitter
    ].filter(Boolean).join("\n\n");
    return colorFn(message);
};
const fixEventKeyMissingSteps = [
    "Set the `INNGEST_EVENT_KEY` environment variable",
    `Pass a key to the \`new Inngest()\` constructor using the \`eventKey\` option`,
    `Use \`inngest.setEventKey()\` at runtime`
];
/**
* An error that, when thrown, indicates internally that an outgoing operation
* contains an error.
*
* We use this because serialized `data` sent back to Inngest may differ from
* the error instance itself due to middleware.
*
* @internal
*/ var OutgoingResultError = class extends Error {
    result;
    constructor(result){
        super("OutgoingOpError");
        this.result = result;
    }
};
/**
* Create a function that will rethrow an error with a prefix added to the
* message.
*
* Useful for adding context to errors that are rethrown.
*
* @example
* ```ts
* await doSomeAction().catch(rethrowError("Failed to do some action"));
* ```
*/ const rethrowError = (prefix)=>{
    return (err)=>{
        try {
            err.message &&= `${prefix}; ${err.message}`;
        } catch (_noopErr) {} finally{
            throw err;
        }
    };
};
/**
* Legacy v0 execution error for functions that don't support mixing steps and
* regular async actions.
*/ const functionStoppedRunningErr = (code)=>{
    return prettyError({
        whatHappened: "Your function was stopped from running",
        why: "We detected a mix of asynchronous logic, some using step tooling and some not.",
        consequences: "This can cause unexpected behaviour when a function is paused and resumed and is therefore strongly discouraged; we stopped your function to ensure nothing unexpected happened!",
        stack: true,
        toFixNow: "Ensure that your function is either entirely step-based or entirely non-step-based, by either wrapping all asynchronous logic in `step.run()` calls or by removing all `step.*()` calls.",
        otherwise: "For more information on why step functions work in this manner, see https://www.inngest.com/docs/functions/multi-step#gotchas",
        code
    });
};
;
 //# sourceMappingURL=errors.js.map
}),
"[project]/node_modules/inngest/types.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "StepOpCode",
    ()=>StepOpCode,
    "err",
    ()=>err,
    "functionConfigSchema",
    ()=>functionConfigSchema,
    "inBandSyncRequestBodySchema",
    ()=>inBandSyncRequestBodySchema,
    "incomingOpSchema",
    ()=>incomingOpSchema,
    "jsonErrorSchema",
    ()=>jsonErrorSchema,
    "logLevels",
    ()=>logLevels,
    "ok",
    ()=>ok,
    "sendEventResponseSchema",
    ()=>sendEventResponseSchema,
    "types_exports",
    ()=>types_exports
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$_virtual$2f$rolldown_runtime$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/inngest/_virtual/rolldown_runtime.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/zod/v3/index.js [app-route] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__ = __turbopack_context__.i("[project]/node_modules/zod/v3/external.js [app-route] (ecmascript) <export * as z>");
;
;
//#region src/types.ts
var types_exports = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$_virtual$2f$rolldown_runtime$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["__export"])({
    StepOpCode: ()=>StepOpCode,
    err: ()=>err,
    functionConfigSchema: ()=>functionConfigSchema,
    inBandSyncRequestBodySchema: ()=>inBandSyncRequestBodySchema,
    incomingOpSchema: ()=>incomingOpSchema,
    jsonErrorSchema: ()=>jsonErrorSchema,
    logLevels: ()=>logLevels,
    ok: ()=>ok,
    sendEventResponseSchema: ()=>sendEventResponseSchema
});
const baseJsonErrorSchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
    name: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().trim().optional(),
    error: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().trim().optional(),
    message: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().trim().optional(),
    stack: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().trim().optional()
});
const maybeJsonErrorSchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].lazy(()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
        name: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().trim(),
        message: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().trim(),
        stack: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().trim().optional(),
        cause: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].union([
            maybeJsonErrorSchema,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].unknown()
        ]).optional()
    }));
const jsonErrorSchema = baseJsonErrorSchema.extend({
    cause: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].union([
        maybeJsonErrorSchema,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].unknown()
    ]).optional()
}).passthrough().catch({}).transform((val)=>{
    return {
        ...val,
        name: val.name || "Error",
        message: val.message || val.error || "Unknown error",
        stack: val.stack
    };
});
/**
* Unique codes for the different types of operation that can be sent to Inngest
* from SDK step functions.
*/ let StepOpCode = /* @__PURE__ */ function(StepOpCode$1) {
    StepOpCode$1["WaitForSignal"] = "WaitForSignal";
    StepOpCode$1["WaitForEvent"] = "WaitForEvent";
    /**
	* Legacy equivalent to `"StepRun"`. Has mixed data wrapping (e.g. `data` or
	* `data.data` depending on SDK version), so this is phased out in favour of
	* `"StepRun"`, which never wraps.
	*
	* Note that it is still used for v0 executions for backwards compatibility.
	*
	* @deprecated Only used for v0 executions; use `"StepRun"` instead.
	*/ StepOpCode$1["Step"] = "Step";
    StepOpCode$1["StepRun"] = "StepRun";
    StepOpCode$1["StepError"] = "StepError";
    StepOpCode$1["StepPlanned"] = "StepPlanned";
    StepOpCode$1["Sleep"] = "Sleep";
    /**
	* Used to signify that the executor has requested that a step run, but we
	* could not find that step.
	*
	* This is likely indicative that a step was renamed or removed from the
	* function.
	*/ StepOpCode$1["StepNotFound"] = "StepNotFound";
    StepOpCode$1["InvokeFunction"] = "InvokeFunction";
    StepOpCode$1["AiGateway"] = "AIGateway";
    StepOpCode$1["Gateway"] = "Gateway";
    return StepOpCode$1;
}({});
const incomingOpSchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
    id: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().min(1),
    data: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].any().optional(),
    error: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].any().optional(),
    input: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].any().optional()
});
const sendEventResponseSchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
    ids: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].array(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string()).default([]),
    status: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].number().default(0),
    error: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().optional()
});
/**
* A set of log levels that can be used to control the amount of logging output
* from various parts of the Inngest library.
*
* @public
*/ const logLevels = [
    "fatal",
    "error",
    "warn",
    "info",
    "debug",
    "silent"
];
/**
* This schema is used internally to share the shape of a concurrency option
* when validating config. We cannot add comments to Zod fields, so we just use
* an extra type check to ensure it matches our exported expectations.
*/ const concurrencyOptionSchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].strictObject({
    limit: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].number(),
    key: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().optional(),
    scope: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].enum([
        "fn",
        "env",
        "account"
    ]).optional()
});
/**
* The schema used to represent an individual function being synced with
* Inngest.
*
* Note that this should only be used to validate the shape of a config object
* and not used for feature compatibility, such as feature X being exclusive
* with feature Y; these should be handled on the Inngest side.
*/ const functionConfigSchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].strictObject({
    name: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().optional(),
    id: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
    triggers: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].array(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].union([
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].strictObject({
            event: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
            expression: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().optional()
        }),
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].strictObject({
            cron: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string()
        })
    ])),
    steps: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].record(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].strictObject({
        id: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
        name: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
        runtime: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].strictObject({
            type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].union([
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].literal("http"),
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].literal("ws")
            ]),
            url: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string()
        }),
        retries: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].strictObject({
            attempts: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].number().optional()
        }).optional()
    })),
    idempotency: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().optional(),
    batchEvents: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].strictObject({
        maxSize: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].number(),
        timeout: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
        key: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().optional(),
        if: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().optional()
    }).optional(),
    rateLimit: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].strictObject({
        key: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().optional(),
        limit: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].number(),
        period: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().transform((x)=>x)
    }).optional(),
    throttle: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].strictObject({
        key: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().optional(),
        limit: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].number(),
        period: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().transform((x)=>x),
        burst: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].number().optional()
    }).optional(),
    singleton: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].strictObject({
        key: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().optional(),
        mode: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].enum([
            "skip",
            "cancel"
        ])
    }).optional(),
    cancel: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].array(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].strictObject({
        event: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
        if: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().optional(),
        timeout: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().optional()
    })).optional(),
    debounce: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].strictObject({
        key: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().optional(),
        period: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().transform((x)=>x),
        timeout: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().transform((x)=>x).optional()
    }).optional(),
    timeouts: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].strictObject({
        start: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().transform((x)=>x).optional(),
        finish: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().transform((x)=>x).optional()
    }).optional(),
    priority: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].strictObject({
        run: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().optional()
    }).optional(),
    concurrency: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].union([
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].number(),
        concurrencyOptionSchema.transform((x)=>x),
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].array(concurrencyOptionSchema.transform((x)=>x)).min(1).max(2)
    ]).optional()
});
const ok = (data)=>{
    return {
        ok: true,
        value: data
    };
};
const err = (error)=>{
    return {
        ok: false,
        error
    };
};
const inBandSyncRequestBodySchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].strictObject({
    url: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string()
});
;
 //# sourceMappingURL=types.js.map
}),
"[project]/node_modules/inngest/components/execution/InngestExecution.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "InngestExecution",
    ()=>InngestExecution,
    "InngestExecution_exports",
    ()=>InngestExecution_exports,
    "PREFERRED_EXECUTION_VERSION",
    ()=>PREFERRED_EXECUTION_VERSION
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$_virtual$2f$rolldown_runtime$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/inngest/_virtual/rolldown_runtime.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/inngest/helpers/consts.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$debug$2f$src$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/debug/src/index.js [app-route] (ecmascript)");
;
;
;
//#region src/components/execution/InngestExecution.ts
var InngestExecution_exports = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$_virtual$2f$rolldown_runtime$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["__export"])({
    ExecutionVersion: ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ExecutionVersion"],
    InngestExecution: ()=>InngestExecution,
    PREFERRED_EXECUTION_VERSION: ()=>PREFERRED_EXECUTION_VERSION
});
/**
* The preferred execution version that will be used by the SDK when handling
* brand new runs where the Executor is allowing us to choose.
*
* Changing this should not ever be a breaking change, as this will only change
* new runs, not existing ones.
*/ const PREFERRED_EXECUTION_VERSION = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ExecutionVersion"].V1;
var InngestExecution = class {
    debug;
    constructor(options){
        this.options = options;
        this.debug = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$debug$2f$src$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(`${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["debugPrefix"]}:${this.options.runId}`);
    }
};
;
 //# sourceMappingURL=InngestExecution.js.map
}),
"[project]/node_modules/inngest/api/schema.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "batchSchema",
    ()=>batchSchema,
    "errorSchema",
    ()=>errorSchema,
    "stepsSchemas",
    ()=>stepsSchemas
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/inngest/helpers/consts.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/inngest/types.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/zod/v3/index.js [app-route] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__ = __turbopack_context__.i("[project]/node_modules/zod/v3/external.js [app-route] (ecmascript) <export * as z>");
;
;
;
//#region src/api/schema.ts
const errorSchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
    error: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
    status: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].number()
});
const v0StepSchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].record(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].any().refine((v)=>typeof v !== "undefined", {
    message: "Values in steps must be defined"
})).optional().nullable();
const v1StepSchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].record(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
    type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].literal("data").optional().default("data"),
    data: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].any().refine((v)=>typeof v !== "undefined", {
        message: "Data in steps must be defined"
    })
}).strict().or(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
    type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].literal("error").optional().default("error"),
    error: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["jsonErrorSchema"]
}).strict()).or(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
    type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].literal("input").optional().default("input"),
    input: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].any().refine((v)=>typeof v !== "undefined", {
        message: "If input is present it must not be `undefined`"
    })
}).strict()).or(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].any().transform((v)=>({
        type: "data",
        data: v
    })))).default({});
const v2StepSchema = v1StepSchema;
const stepsSchemas = {
    [__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ExecutionVersion"].V0]: v0StepSchema,
    [__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ExecutionVersion"].V1]: v1StepSchema,
    [__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ExecutionVersion"].V2]: v2StepSchema
};
const batchSchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].array(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].record(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].any()).transform((v)=>v));
;
 //# sourceMappingURL=schema.js.map
}),
"[project]/node_modules/inngest/helpers/functions.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "cacheFn",
    ()=>cacheFn,
    "fetchAllFnData",
    ()=>fetchAllFnData,
    "parseFnData",
    ()=>parseFnData,
    "undefinedToNull",
    ()=>undefinedToNull,
    "waterfall",
    ()=>waterfall
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/inngest/helpers/consts.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$errors$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/inngest/helpers/errors.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/inngest/types.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$api$2f$schema$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/inngest/api/schema.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$components$2f$execution$2f$InngestExecution$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/inngest/components/execution/InngestExecution.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/zod/v3/index.js [app-route] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$ZodError$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/zod/v3/ZodError.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__ = __turbopack_context__.i("[project]/node_modules/zod/v3/external.js [app-route] (ecmascript) <export * as z>");
;
;
;
;
;
;
//#region src/helpers/functions.ts
/**
* Wraps a function with a cache. When the returned function is run, it will
* cache the result and return it on subsequent calls.
*/ const cacheFn = (fn)=>{
    const key = "value";
    const cache = /* @__PURE__ */ new Map();
    return (...args)=>{
        if (!cache.has(key)) cache.set(key, fn(...args));
        return cache.get(key);
    };
};
/**
* Given an array of functions, return a new function that will run each
* function in series and return the result of the final function. Regardless of
* if the functions are synchronous or asynchronous, they'll be made into an
* async promise chain.
*
* If an error is thrown, the waterfall will stop and return the error.
*
* Because this needs to support both sync and async functions, it only allows
* functions that accept a single argument.
*/ const waterfall = (fns, transform)=>{
    return (...args)=>{
        return fns.reduce(async (acc, fn)=>{
            const prev = await acc;
            const output = await fn(prev);
            if (transform) return await transform(prev, output);
            if (typeof output === "undefined") return prev;
            return output;
        }, Promise.resolve(args[0]));
    };
};
/**
* Given a value `v`, return `v` if it's not undefined, otherwise return `null`.
*/ const undefinedToNull = (v)=>{
    return typeof v === "undefined" ? null : v;
};
const fnDataVersionSchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
    version: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].literal(-1).or(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].literal(0)).or(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].literal(1)).or(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].literal(2)).optional().transform((v)=>{
        if (typeof v === "undefined") {
            console.debug(`No request version specified by executor; defaulting to v${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$components$2f$execution$2f$InngestExecution$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["PREFERRED_EXECUTION_VERSION"]}`);
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$components$2f$execution$2f$InngestExecution$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["PREFERRED_EXECUTION_VERSION"];
        }
        return v === -1 ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$components$2f$execution$2f$InngestExecution$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["PREFERRED_EXECUTION_VERSION"] : v;
    })
});
const parseFnData = (data)=>{
    let version;
    try {
        ({ version } = fnDataVersionSchema.parse(data));
        return ({
            [__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ExecutionVersion"].V0]: ()=>({
                    version: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ExecutionVersion"].V0,
                    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
                        event: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].record(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].any()),
                        events: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].array(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].record(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].any())).default([]),
                        steps: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$api$2f$schema$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["stepsSchemas"][__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ExecutionVersion"].V0],
                        ctx: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
                            run_id: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
                            attempt: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].number().default(0),
                            stack: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
                                stack: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].array(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string()).nullable().transform((v)=>Array.isArray(v) ? v : []),
                                current: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].number()
                            }).passthrough().optional().nullable()
                        }).optional().nullable(),
                        use_api: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].boolean().default(false)
                    }).parse(data)
                }),
            [__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ExecutionVersion"].V1]: ()=>({
                    version: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ExecutionVersion"].V1,
                    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
                        event: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].record(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].any()),
                        events: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].array(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].record(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].any())).default([]),
                        steps: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$api$2f$schema$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["stepsSchemas"][__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ExecutionVersion"].V1],
                        ctx: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
                            run_id: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
                            attempt: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].number().default(0),
                            disable_immediate_execution: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].boolean().default(false),
                            use_api: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].boolean().default(false),
                            stack: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
                                stack: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].array(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string()).nullable().transform((v)=>Array.isArray(v) ? v : []),
                                current: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].number()
                            }).passthrough().optional().nullable()
                        }).optional().nullable()
                    }).parse(data)
                }),
            [__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ExecutionVersion"].V2]: ()=>({
                    version: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ExecutionVersion"].V2,
                    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
                        event: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].record(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].any()),
                        events: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].array(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].record(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].any())).default([]),
                        steps: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$api$2f$schema$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["stepsSchemas"][__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ExecutionVersion"].V2],
                        ctx: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
                            run_id: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
                            attempt: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].number().default(0),
                            disable_immediate_execution: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].boolean().default(false),
                            use_api: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].boolean().default(false),
                            stack: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
                                stack: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].array(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string()).nullable().transform((v)=>Array.isArray(v) ? v : []),
                                current: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].number()
                            }).passthrough().optional().nullable()
                        }).optional().nullable()
                    }).parse(data)
                })
        })[version]();
    } catch (err$1) {
        throw new Error(parseFailureErr(err$1));
    }
};
const fetchAllFnData = async ({ data, api, version })=>{
    const result = {
        ...data
    };
    try {
        if (result.version === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ExecutionVersion"].V0 && result.use_api || result.version === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ExecutionVersion"].V1 && result.ctx?.use_api) {
            if (!result.ctx?.run_id) return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["err"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$errors$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["prettyError"])({
                whatHappened: "failed to attempt retrieving data from API",
                consequences: "function execution can't continue",
                why: "run_id is missing from context",
                stack: true
            }));
            const [evtResp, stepResp] = await Promise.all([
                api.getRunBatch(result.ctx.run_id),
                api.getRunSteps(result.ctx.run_id, version)
            ]);
            if (evtResp.ok) result.events = evtResp.value;
            else return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["err"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$errors$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["prettyError"])({
                whatHappened: "failed to retrieve list of events",
                consequences: "function execution can't continue",
                why: evtResp.error?.error,
                stack: true
            }));
            if (stepResp.ok) result.steps = stepResp.value;
            else return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["err"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$errors$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["prettyError"])({
                whatHappened: "failed to retrieve steps for function run",
                consequences: "function execution can't continue",
                why: stepResp.error?.error,
                stack: true
            }));
        }
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ok"])(result);
    } catch (error) {
        console.error(error);
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["err"])(parseFailureErr(error));
    }
};
const parseFailureErr = (err$1)=>{
    let why;
    if (err$1 instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$ZodError$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZodError"]) why = err$1.toString();
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$errors$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["prettyError"])({
        whatHappened: "Failed to parse data from executor.",
        consequences: "Function execution can't continue.",
        toFixNow: "Make sure that your API is set up to parse incoming request bodies as JSON, like body-parser for Express (https://expressjs.com/en/resources/middleware/body-parser.html).",
        stack: true,
        why
    });
};
;
 //# sourceMappingURL=functions.js.map
}),
"[project]/node_modules/inngest/helpers/net.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "fetchWithAuthFallback",
    ()=>fetchWithAuthFallback,
    "signDataWithKey",
    ()=>signDataWithKey
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hash$2e$js$2f$lib$2f$hash$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/hash.js/lib/hash.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$canonicalize$2f$lib$2f$canonicalize$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/canonicalize/lib/canonicalize.js [app-route] (ecmascript)");
;
;
//#region src/helpers/net.ts
const { hmac, sha256 } = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hash$2e$js$2f$lib$2f$hash$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"];
/**
* Send an HTTP request with the given signing key. If the response is a 401 or
* 403, then try again with the fallback signing key
*/ async function fetchWithAuthFallback({ authToken, authTokenFallback, fetch, options, url }) {
    let res = await fetch(url, {
        ...options,
        headers: {
            ...options?.headers,
            Authorization: `Bearer ${authToken}`
        }
    });
    if ([
        401,
        403
    ].includes(res.status) && authTokenFallback) res = await fetch(url, {
        ...options,
        headers: {
            ...options?.headers,
            Authorization: `Bearer ${authTokenFallback}`
        }
    });
    return res;
}
function signDataWithKey(data, signingKey, ts) {
    const encoded = typeof data === "string" ? data : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$canonicalize$2f$lib$2f$canonicalize$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(data);
    const key = signingKey.replace(/signkey-\w+-/, "");
    return hmac(sha256, key).update(encoded).update(ts).digest("hex");
}
;
 //# sourceMappingURL=net.js.map
}),
"[project]/node_modules/inngest/helpers/promises.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

//#region src/helpers/promises.ts
/**
* Some environments don't allow access to the global queueMicrotask(). While we
* had assumed this was only true for those powered by earlier versions of Node
* (<14) that we don't officially support, Vercel's Edge Functions also obscure
* the function in dev, even though the platform it's based on (Cloudflare
* Workers) appropriately exposes it. Even worse, production Vercel Edge
* Functions can see the function, but it immediately blows up the function when
* used.
*
* Therefore, we can fall back to a reasonable alternative of
* `Promise.resolve().then(fn)` instead. This _may_ be slightly slower in modern
* environments, but at least we can still work in these environments.
*/ __turbopack_context__.s([
    "createDeferredPromise",
    ()=>createDeferredPromise,
    "createDeferredPromiseWithStack",
    ()=>createDeferredPromiseWithStack,
    "createTimeoutPromise",
    ()=>createTimeoutPromise,
    "resolveAfterPending",
    ()=>resolveAfterPending,
    "resolveNextTick",
    ()=>resolveNextTick,
    "retryWithBackoff",
    ()=>retryWithBackoff,
    "runAsPromise",
    ()=>runAsPromise
]);
const shimQueueMicrotask = (callback)=>{
    Promise.resolve().then(callback);
};
/**
* Returns a Promise that resolves after the current event loop's microtasks
* have finished, but before the next event loop tick.
*/ const resolveAfterPending = (count = 100)=>{
    /**
	* This uses a brute force implementation that will continue to enqueue
	* microtasks 10 times before resolving. This is to ensure that the microtask
	* queue is drained, even if the microtask queue is being manipulated by other
	* code.
	*
	* While this still doesn't guarantee that the microtask queue is drained,
	* it's our best bet for giving other non-controlled promises a chance to
	* resolve before we continue without resorting to falling in to the next
	* tick.
	*/ return new Promise((resolve)=>{
        let i = 0;
        const iterate = ()=>{
            shimQueueMicrotask(()=>{
                if (i++ > count) return resolve();
                iterate();
            });
        };
        iterate();
    });
};
/**
* Creates and returns Promise that can be resolved or rejected with the
* returned `resolve` and `reject` functions.
*
* Resolving or rejecting the function will return a new set of Promise control
* functions. These can be ignored if the original Promise is all that's needed.
*/ const createDeferredPromise = ()=>{
    let resolve;
    let reject;
    return {
        promise: new Promise((_resolve, _reject)=>{
            resolve = (value)=>{
                _resolve(value);
                return createDeferredPromise();
            };
            reject = (reason)=>{
                _reject(reason);
                return createDeferredPromise();
            };
        }),
        resolve,
        reject
    };
};
/**
* Creates and returns a deferred Promise that can be resolved or rejected with
* the returned `resolve` and `reject` functions.
*
* For each Promise resolved or rejected this way, this will also keep a stack
* of all unhandled Promises, resolved or rejected.
*
* Once a Promise is read, it is removed from the stack.
*/ const createDeferredPromiseWithStack = ()=>{
    const settledPromises = [];
    let rotateQueue = ()=>{};
    const results = async function*() {
        while(true){
            const next = settledPromises.shift();
            if (next) yield next;
            else await new Promise((resolve)=>{
                rotateQueue = resolve;
            });
        }
    }();
    const shimDeferredPromise = (deferred)=>{
        const originalResolve = deferred.resolve;
        const originalReject = deferred.reject;
        deferred.resolve = (value)=>{
            settledPromises.push(deferred.promise);
            rotateQueue();
            return shimDeferredPromise(originalResolve(value));
        };
        deferred.reject = (reason)=>{
            settledPromises.push(deferred.promise);
            rotateQueue();
            return shimDeferredPromise(originalReject(reason));
        };
        return deferred;
    };
    return {
        deferred: shimDeferredPromise(createDeferredPromise()),
        results
    };
};
/**
* Creates a Promise that will resolve after the given duration, along with
* methods to start, clear, and reset the timeout.
*/ const createTimeoutPromise = (duration)=>{
    const { promise, resolve } = createDeferredPromise();
    let timeout;
    let ret;
    const start = ()=>{
        if (timeout) return ret;
        timeout = setTimeout(()=>{
            resolve();
        }, duration);
        return ret;
    };
    const clear = ()=>{
        clearTimeout(timeout);
        timeout = void 0;
    };
    const reset = ()=>{
        clear();
        return start();
    };
    ret = Object.assign(promise, {
        start,
        clear,
        reset
    });
    return ret;
};
/**
* Take any function and safely promisify such that both synchronous and
* asynchronous errors are caught and returned as a rejected Promise.
*
* The passed `fn` can be undefined to support functions that may conditionally
* be defined.
*/ const runAsPromise = (fn)=>{
    return Promise.resolve().then(fn);
};
/**
* Returns a Promise that resolve after the current event loop tick.
*/ const resolveNextTick = ()=>{
    return new Promise((resolve)=>setTimeout(resolve));
};
const retryWithBackoff = async (fn, opts)=>{
    const maxAttempts = opts?.maxAttempts || 5;
    const baseDelay = opts?.baseDelay ?? 100;
    for(let attempt = 1; attempt <= maxAttempts; attempt++)try {
        return await fn();
    } catch (err) {
        if (attempt >= maxAttempts) throw err;
        const jitter = Math.random() * baseDelay;
        const delay = baseDelay * Math.pow(2, attempt - 1) + jitter;
        await new Promise((resolve)=>setTimeout(resolve, delay));
    }
    throw new Error("Max retries reached; this should be unreachable.");
};
;
 //# sourceMappingURL=promises.js.map
}),
"[project]/node_modules/inngest/helpers/ServerTiming.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "ServerTiming",
    ()=>ServerTiming,
    "ServerTiming_exports",
    ()=>ServerTiming_exports
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$_virtual$2f$rolldown_runtime$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/inngest/_virtual/rolldown_runtime.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$promises$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/inngest/helpers/promises.js [app-route] (ecmascript)");
;
;
//#region src/helpers/ServerTiming.ts
var ServerTiming_exports = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$_virtual$2f$rolldown_runtime$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["__export"])({
    ServerTiming: ()=>ServerTiming
});
/**
* A class to manage timing functions and arbitrary periods of time before
* generating a `Server-Timing` header for use in HTTP responses.
*
* This is a very simple implementation that does not support nested timings or
* fractions of a millisecond.
*/ var ServerTiming = class {
    timings = {};
    /**
	* Start a timing. Returns a function that, when called, will stop the timing
	* and add it to the header.
	*/ start(name, description) {
        if (!this.timings[name]) this.timings[name] = {
            description: description ?? "",
            timers: []
        };
        const index = this.timings[name].timers.push({
            start: Date.now()
        }) - 1;
        return ()=>{
            const target = this.timings[name];
            if (!target) return console.warn(`Timing "${name}" does not exist`);
            const timer = target.timers[index];
            if (!timer) return console.warn(`Timer ${index} for timing "${name}" does not exist`);
            timer.end = Date.now();
        };
    }
    /**
	* Add a piece of arbitrary, untimed information to the header. Common use
	* cases would be cache misses.
	*
	* @example
	* ```
	* timer.append("cache", "miss");
	* ```
	*/ append(key, value) {
        this.timings[key] = {
            description: value,
            timers: []
        };
    }
    /**
	* Wrap a function in a timing. The timing will be stopped and added to the
	* header when the function resolves or rejects.
	*
	* The return value of the function will be returned from this function.
	*/ async wrap(name, fn, description) {
        const stop = this.start(name, description);
        try {
            return await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$promises$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["runAsPromise"])(fn);
        } finally{
            stop();
        }
    }
    /**
	* Generate the `Server-Timing` header.
	*/ getHeader() {
        return Object.entries(this.timings).reduce((acc, [name, { description, timers }])=>{
            if (!timers.some((timer)=>timer.end)) return acc;
            const dur = timers.reduce((acc$1, { start, end })=>{
                if (!start || !end) return acc$1;
                return acc$1 + (end - start);
            }, 0);
            const entry = [
                name,
                description ? `desc="${description}"` : "",
                dur ? `dur=${dur}` : ""
            ].filter(Boolean).join(";");
            return [
                ...acc,
                entry
            ];
        }, []).join(", ");
    }
};
;
 //# sourceMappingURL=ServerTiming.js.map
}),
"[project]/node_modules/inngest/helpers/stream.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "createStream",
    ()=>createStream
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$strings$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/inngest/helpers/strings.js [app-route] (ecmascript)");
;
//#region src/helpers/stream.ts
/**
* Creates a {@link ReadableStream} that sends a `value` every `interval`
* milliseconds as a heartbeat, intended to keep a stream open.
*
* Returns the `stream` itself and a `finalize` function that can be used to
* close the stream and send a final value.
*/ const createStream = (opts)=>{
    /**
	* We need to resolve this promise with both the stream and the `finalize`
	* function, but having them both instantiated synchronously is difficult, as
	* we need access to the stream's internals too.
	*
	* We create this cheeky deferred promise to grab the internal `finalize`
	* value. Be warned that simpler solutions may appear to compile, but fail at
	* runtime due to variables not being assigned; make sure to test your code!
	*/ let passFinalize;
    const finalizeP = new Promise((resolve)=>{
        passFinalize = resolve;
    });
    const interval = opts?.interval ?? 3e3;
    const value = opts?.value ?? " ";
    return new Promise(async (resolve, reject)=>{
        try {
            const stream = new ReadableStream({
                start (controller) {
                    const encoder = new TextEncoder();
                    const heartbeat = setInterval(()=>{
                        controller.enqueue(encoder.encode(value));
                    }, interval);
                    const finalize = (data)=>{
                        clearInterval(heartbeat);
                        Promise.resolve(data).then((resolvedData)=>{
                            controller.enqueue(encoder.encode((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$strings$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["stringify"])(resolvedData)));
                            controller.close();
                        });
                    };
                    passFinalize(finalize);
                }
            });
            resolve({
                stream,
                finalize: await finalizeP
            });
        } catch (err) {
            reject(err);
        }
    });
};
;
 //# sourceMappingURL=stream.js.map
}),
"[project]/node_modules/inngest/components/InngestCommHandler.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "InngestCommHandler",
    ()=>InngestCommHandler
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/inngest/helpers/consts.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$version$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/inngest/version.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$strings$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/inngest/helpers/strings.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$env$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/inngest/helpers/env.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$devserver$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/inngest/helpers/devserver.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$enum$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/inngest/helpers/enum.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$errors$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/inngest/helpers/errors.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/inngest/types.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$components$2f$execution$2f$InngestExecution$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/inngest/components/execution/InngestExecution.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$functions$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/inngest/helpers/functions.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$net$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/inngest/helpers/net.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$promises$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/inngest/helpers/promises.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$ServerTiming$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/inngest/helpers/ServerTiming.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$stream$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/inngest/helpers/stream.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$debug$2f$src$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/debug/src/index.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/zod/v3/index.js [app-route] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__ = __turbopack_context__.i("[project]/node_modules/zod/v3/external.js [app-route] (ecmascript) <export * as z>");
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
//#region src/components/InngestCommHandler.ts
/**
* A schema for the response from Inngest when registering.
*/ const registerResSchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
    status: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].number().default(200),
    skipped: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].boolean().optional().default(false),
    modified: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].boolean().optional().default(false),
    error: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().default("Successfully registered")
});
/**
* `InngestCommHandler` is a class for handling incoming requests from Inngest (or
* Inngest's tooling such as the dev server or CLI) and taking appropriate
* action for any served functions.
*
* All handlers (Next.js, RedwoodJS, Remix, Deno Fresh, etc.) are created using
* this class; the exposed `serve` function will - most commonly - create an
* instance of `InngestCommHandler` and then return `instance.createHandler()`.
*
* See individual parameter details for more information, or see the
* source code for an existing handler, e.g.
* {@link https://github.com/inngest/inngest-js/blob/main/src/next.ts}
*
* @example
* ```
* // my-custom-handler.ts
* import {
*   InngestCommHandler,
*   type ServeHandlerOptions,
* } from "./components/InngestCommHandler";
*
* export const serve = (options: ServeHandlerOptions) => {
*   const handler = new InngestCommHandler({
*     frameworkName: "my-custom-handler",
*     ...options,
*     handler: (req: Request) => {
*       return {
*         body: () => req.json(),
*         headers: (key) => req.headers.get(key),
*         method: () => req.method,
*         url: () => new URL(req.url, `https://${req.headers.get("host") || ""}`),
*         transformResponse: ({ body, status, headers }) => {
*           return new Response(body, { status, headers });
*         },
*       };
*     },
*   });
*
*   return handler.createHandler();
* };
* ```
*
* @public
*/ var InngestCommHandler = class {
    /**
	* The ID of this serve handler, e.g. `"my-app"`. It's recommended that this
	* value represents the overarching app/service that this set of functions is
	* being served from.
	*/ id;
    /**
	* The handler specified during instantiation of the class.
	*/ handler;
    /**
	* The URL of the Inngest function registration endpoint.
	*/ inngestRegisterUrl;
    /**
	* The name of the framework this handler is designed for. Should be
	* lowercase, alphanumeric characters inclusive of `-` and `/`.
	*/ frameworkName;
    /**
	* The signing key used to validate requests from Inngest. This is
	* intentionally mutable so that we can pick up the signing key from the
	* environment during execution if needed.
	*/ signingKey;
    /**
	* The same as signingKey, except used as a fallback when auth fails using the
	* primary signing key.
	*/ signingKeyFallback;
    /**
	* A property that can be set to indicate whether we believe we are in
	* production mode.
	*
	* Should be set every time a request is received.
	*/ _mode;
    /**
	* The localized `fetch` implementation used by this handler.
	*/ fetch;
    /**
	* The host used to access the Inngest serve endpoint, e.g.:
	*
	*     "https://myapp.com"
	*
	* By default, the library will try to infer this using request details such
	* as the "Host" header and request path, but sometimes this isn't possible
	* (e.g. when running in a more controlled environments such as AWS Lambda or
	* when dealing with proxies/redirects).
	*
	* Provide the custom hostname here to ensure that the path is reported
	* correctly when registering functions with Inngest.
	*
	* To also provide a custom path, use `servePath`.
	*/ _serveHost;
    /**
	* The path to the Inngest serve endpoint. e.g.:
	*
	*     "/some/long/path/to/inngest/endpoint"
	*
	* By default, the library will try to infer this using request details such
	* as the "Host" header and request path, but sometimes this isn't possible
	* (e.g. when running in a more controlled environments such as AWS Lambda or
	* when dealing with proxies/redirects).
	*
	* Provide the custom path (excluding the hostname) here to ensure that the
	* path is reported correctly when registering functions with Inngest.
	*
	* To also provide a custom hostname, use `serveHost`.
	*/ _servePath;
    /**
	* The minimum level to log from the Inngest serve handler.
	*/ logLevel;
    streaming;
    /**
	* A private collection of just Inngest functions, as they have been passed
	* when instantiating the class.
	*/ rawFns;
    client;
    /**
	* A private collection of functions that are being served. This map is used
	* to find and register functions when interacting with Inngest Cloud.
	*/ fns = {};
    env = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$env$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["allProcessEnv"])();
    allowExpiredSignatures;
    _options;
    skipSignatureValidation;
    constructor(options){
        this._options = options;
        /**
		* v2 -> v3 migration error.
		*
		* If a serve handler is passed a client as the first argument, it'll be
		* spread in to these options. We should be able to detect this by picking
		* up a unique property on the object.
		*/ if (Object.hasOwn(options, "eventKey")) throw new Error(`${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["logPrefix"]} You've passed an Inngest client as the first argument to your serve handler. This is no longer supported in v3; please pass the Inngest client as the \`client\` property of an options object instead. See https://www.inngest.com/docs/sdk/migration`);
        this.frameworkName = options.frameworkName;
        this.client = options.client;
        if (options.id) console.warn(`${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["logPrefix"]} The \`id\` serve option is deprecated and will be removed in v4`);
        this.id = options.id || this.client.id;
        this.handler = options.handler;
        /**
		* Provide a hidden option to allow expired signatures to be accepted during
		* testing.
		*/ this.allowExpiredSignatures = Boolean(arguments["0"]?.__testingAllowExpiredSignatures);
        this.rawFns = options.functions.filter(Boolean);
        if (this.rawFns.length !== options.functions.length) console.warn(`Some functions passed to serve() are undefined and misconfigured.  Please check your imports.`);
        this.fns = this.rawFns.reduce((acc, fn)=>{
            const configs = fn["getConfig"]({
                baseUrl: new URL("https://example.com"),
                appPrefix: this.id
            });
            const fns = configs.reduce((acc$1, { id }, index)=>{
                return {
                    ...acc$1,
                    [id]: {
                        fn,
                        onFailure: Boolean(index)
                    }
                };
            }, {});
            configs.forEach(({ id })=>{
                if (acc[id]) throw new Error(`Duplicate function ID "${id}"; please change a function's name or provide an explicit ID to avoid conflicts.`);
            });
            return {
                ...acc,
                ...fns
            };
        }, {});
        this.inngestRegisterUrl = new URL("/fn/register", this.apiBaseUrl);
        this.signingKey = options.signingKey;
        this.signingKeyFallback = options.signingKeyFallback;
        this._serveHost = options.serveHost || this.env[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["envKeys"].InngestServeHost];
        this._servePath = options.servePath || this.env[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["envKeys"].InngestServePath];
        this.skipSignatureValidation = options.skipSignatureValidation || false;
        const defaultLogLevel = "info";
        this.logLevel = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].enum(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["logLevels"]).default(defaultLogLevel).catch((ctx)=>{
            this.log("warn", `Unknown log level passed: ${String(ctx.input)}; defaulting to ${defaultLogLevel}`);
            return defaultLogLevel;
        }).parse(options.logLevel || this.env[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["envKeys"].InngestLogLevel]);
        if (this.logLevel === "debug") {
            /**
			* `debug` is an old library; sometimes its runtime detection doesn't work
			* for newer pairings of framework/runtime.
			*
			* One silly symptom of this is that `Debug()` returns an anonymous
			* function with no extra properties instead of a `Debugger` instance if
			* the wrong code is consumed following a bad detection. This results in
			* the following `.enable()` call failing, so we just try carefully to
			* enable it here.
			*/ if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$debug$2f$src$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].enable && typeof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$debug$2f$src$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].enable === "function") __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$debug$2f$src$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].enable(`${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["debugPrefix"]}:*`);
        }
        const defaultStreamingOption = false;
        this.streaming = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].union([
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].enum([
                "allow",
                "force"
            ]),
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].literal(false)
        ]).default(defaultStreamingOption).catch((ctx)=>{
            this.log("warn", `Unknown streaming option passed: ${String(ctx.input)}; defaulting to ${String(defaultStreamingOption)}`);
            return defaultStreamingOption;
        }).parse(options.streaming || this.env[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["envKeys"].InngestStreaming]);
        this.fetch = options.fetch ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$env$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getFetch"])(options.fetch) : this.client["fetch"];
    }
    /**
	* Get the API base URL for the Inngest API.
	*
	* This is a getter to encourage checking the environment for the API base URL
	* each time it's accessed, as it may change during execution.
	*/ get apiBaseUrl() {
        return this._options.baseUrl || this.env[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["envKeys"].InngestApiBaseUrl] || this.env[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["envKeys"].InngestBaseUrl] || this.client.apiBaseUrl || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["defaultInngestApiBaseUrl"];
    }
    /**
	* Get the event API base URL for the Inngest API.
	*
	* This is a getter to encourage checking the environment for the event API
	* base URL each time it's accessed, as it may change during execution.
	*/ get eventApiBaseUrl() {
        return this._options.baseUrl || this.env[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["envKeys"].InngestEventApiBaseUrl] || this.env[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["envKeys"].InngestBaseUrl] || this.client.eventBaseUrl || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["defaultInngestEventBaseUrl"];
    }
    /**
	* The host used to access the Inngest serve endpoint, e.g.:
	*
	*     "https://myapp.com"
	*
	* By default, the library will try to infer this using request details such
	* as the "Host" header and request path, but sometimes this isn't possible
	* (e.g. when running in a more controlled environments such as AWS Lambda or
	* when dealing with proxies/redirects).
	*
	* Provide the custom hostname here to ensure that the path is reported
	* correctly when registering functions with Inngest.
	*
	* To also provide a custom path, use `servePath`.
	*/ get serveHost() {
        return this._serveHost || this.env[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["envKeys"].InngestServeHost];
    }
    /**
	* The path to the Inngest serve endpoint. e.g.:
	*
	*     "/some/long/path/to/inngest/endpoint"
	*
	* By default, the library will try to infer this using request details such
	* as the "Host" header and request path, but sometimes this isn't possible
	* (e.g. when running in a more controlled environments such as AWS Lambda or
	* when dealing with proxies/redirects).
	*
	* Provide the custom path (excluding the hostname) here to ensure that the
	* path is reported correctly when registering functions with Inngest.
	*
	* To also provide a custom hostname, use `serveHost`.
	*
	* This is a getter to encourage checking the environment for the serve path
	* each time it's accessed, as it may change during execution.
	*/ get servePath() {
        return this._servePath || this.env[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["envKeys"].InngestServePath];
    }
    get hashedEventKey() {
        if (!this.client["eventKey"] || this.client["eventKey"] === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["dummyEventKey"]) return;
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$strings$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["hashEventKey"])(this.client["eventKey"]);
    }
    get hashedSigningKey() {
        if (!this.signingKey) return;
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$strings$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["hashSigningKey"])(this.signingKey);
    }
    get hashedSigningKeyFallback() {
        if (!this.signingKeyFallback) return;
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$strings$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["hashSigningKey"])(this.signingKeyFallback);
    }
    /**
	* Returns a `boolean` representing whether this handler will stream responses
	* or not. Takes into account the user's preference and the platform's
	* capabilities.
	*/ async shouldStream(actions) {
        if (await actions.queryStringWithDefaults("testing for probe", __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["queryKeys"].Probe) !== void 0) return false;
        if (!actions.transformStreamingResponse) return false;
        if (this.streaming === "force") return true;
        return this.streaming === "allow" && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$env$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["platformSupportsStreaming"])(this.frameworkName, this.env);
    }
    /**
	* `createHandler` should be used to return a type-equivalent version of the
	* `handler` specified during instantiation.
	*
	* @example
	* ```
	* // my-custom-handler.ts
	* import {
	*   InngestCommHandler,
	*   type ServeHandlerOptions,
	* } from "./components/InngestCommHandler";
	*
	* export const serve = (options: ServeHandlerOptions) => {
	*   const handler = new InngestCommHandler({
	*     frameworkName: "my-custom-handler",
	*     ...options,
	*     handler: (req: Request) => {
	*       return {
	*         body: () => req.json(),
	*         headers: (key) => req.headers.get(key),
	*         method: () => req.method,
	*         url: () => new URL(req.url, `https://${req.headers.get("host") || ""}`),
	*         transformResponse: ({ body, status, headers }) => {
	*           return new Response(body, { status, headers });
	*         },
	*       };
	*     },
	*   });
	*
	*   return handler.createHandler();
	* };
	* ```
	*/ createHandler() {
        const handler = async (...args)=>{
            const timer = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$ServerTiming$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ServerTiming"]();
            /**
			* Used for testing, allow setting action overrides externally when
			* calling the handler. Always search the final argument.
			*/ const lastArg = args[args.length - 1];
            const actionOverrides = typeof lastArg === "object" && lastArg !== null && "actionOverrides" in lastArg && typeof lastArg["actionOverrides"] === "object" && lastArg["actionOverrides"] !== null ? lastArg["actionOverrides"] : {};
            /**
			* We purposefully `await` the handler, as it could be either sync or
			* async.
			*/ const rawActions = {
                ...await timer.wrap("handler", ()=>this.handler(...args)).catch((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$errors$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["rethrowError"])("Serve handler failed to run")),
                ...actionOverrides
            };
            /**
			* Mapped promisified handlers from userland `serve()` function mixed in
			* with some helpers.
			*/ const actions = {
                ...Object.entries(rawActions).reduce((acc, [key, value])=>{
                    if (typeof value !== "function") return acc;
                    return {
                        ...acc,
                        [key]: (reason, ...args$1)=>{
                            const errMessage = [
                                `Failed calling \`${key}\` from serve handler`,
                                reason
                            ].filter(Boolean).join(" when ");
                            const fn = ()=>value(...args$1);
                            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$promises$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["runAsPromise"])(fn).catch((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$errors$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["rethrowError"])(errMessage)).catch((err)=>{
                                this.log("error", err);
                                throw err;
                            });
                        }
                    };
                }, {}),
                queryStringWithDefaults: async (reason, key)=>{
                    const url = await actions.url(reason);
                    return await actions.queryString?.(reason, key, url) || url.searchParams.get(key) || void 0;
                },
                ...actionOverrides
            };
            const [env, expectedServerKind] = await Promise.all([
                actions.env?.("starting to handle request"),
                actions.headers("checking expected server kind", __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["headerKeys"].InngestServerKind)
            ]);
            this.env = {
                ...(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$env$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["allProcessEnv"])(),
                ...env
            };
            const getInngestHeaders = ()=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$env$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["inngestHeaders"])({
                    env: this.env,
                    framework: this.frameworkName,
                    client: this.client,
                    expectedServerKind: expectedServerKind || void 0,
                    extras: {
                        "Server-Timing": timer.getHeader()
                    }
                });
            const assumedMode = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$env$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getMode"])({
                env: this.env,
                client: this.client
            });
            if (assumedMode.isExplicit) this._mode = assumedMode;
            else {
                const serveIsProd = await actions.isProduction?.("starting to handle request");
                if (typeof serveIsProd === "boolean") this._mode = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$env$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Mode"]({
                    type: serveIsProd ? "cloud" : "dev",
                    isExplicit: false
                });
                else this._mode = assumedMode;
            }
            this.upsertKeysFromEnv();
            const methodP = actions.method("starting to handle request");
            const headerPromises = [
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["headerKeys"].TraceParent,
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["headerKeys"].TraceState
            ].map(async (header)=>{
                const value = await actions.headers(`fetching ${header} for forwarding`, header);
                return {
                    header,
                    value
                };
            });
            const contentLength = await actions.headers("checking signature for request", __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["headerKeys"].ContentLength).then((value)=>{
                if (!value) return;
                return Number.parseInt(value, 10);
            });
            const [signature, method, body] = await Promise.all([
                actions.headers("checking signature for request", __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["headerKeys"].Signature).then((headerSignature)=>{
                    return headerSignature ?? void 0;
                }),
                methodP,
                methodP.then((method$1)=>{
                    if (method$1 === "POST" || method$1 === "PUT") {
                        if (!contentLength) return "";
                        return actions.body(`checking body for request signing as method is ${method$1}`);
                    }
                    return "";
                })
            ]);
            const signatureValidation = this.validateSignature(signature, body);
            const headersToForwardP = Promise.all(headerPromises).then((fetchedHeaders)=>{
                return fetchedHeaders.reduce((acc, { header, value })=>{
                    if (value) acc[header] = value;
                    return acc;
                }, {});
            });
            const actionRes = timer.wrap("action", ()=>this.handleAction({
                    actions,
                    timer,
                    getInngestHeaders,
                    reqArgs: args,
                    signatureValidation,
                    body,
                    method,
                    headers: headersToForwardP
                }));
            /**
			* Prepares an action response by merging returned data to provide
			* trailing information such as `Server-Timing` headers.
			*
			* It should always prioritize the headers returned by the action, as they
			* may contain important information such as `Content-Type`.
			*/ const prepareActionRes = async (res)=>{
                const headers = {
                    ...getInngestHeaders(),
                    ...await headersToForwardP,
                    ...res.headers,
                    ...res.version === null ? {} : {
                        [__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["headerKeys"].RequestVersion]: (res.version ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$components$2f$execution$2f$InngestExecution$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["PREFERRED_EXECUTION_VERSION"]).toString()
                    }
                };
                let signature$1;
                try {
                    signature$1 = await signatureValidation.then((result)=>{
                        if (!result.success || !result.keyUsed) return;
                        return this.getResponseSignature(result.keyUsed, res.body);
                    });
                } catch (err) {
                    return {
                        ...res,
                        headers,
                        body: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$strings$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["stringify"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$errors$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["serializeError"])(err)),
                        status: 500
                    };
                }
                if (signature$1) headers[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["headerKeys"].Signature] = signature$1;
                return {
                    ...res,
                    headers
                };
            };
            if (await this.shouldStream(actions)) {
                if (await actions.method("starting streaming response") === "POST") {
                    const { stream, finalize } = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$stream$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createStream"])();
                    /**
					* Errors are handled by `handleAction` here to ensure that an
					* appropriate response is always given.
					*/ actionRes.then((res)=>{
                        return finalize(prepareActionRes(res));
                    });
                    return timer.wrap("res", ()=>{
                        return actions.transformStreamingResponse?.("starting streaming response", {
                            status: 201,
                            headers: getInngestHeaders(),
                            body: stream,
                            version: null
                        });
                    });
                }
            }
            return timer.wrap("res", async ()=>{
                return actionRes.then(prepareActionRes).then((actionRes$1)=>{
                    return actions.transformResponse("sending back response", actionRes$1);
                });
            });
        };
        /**
		* Some platforms check (at runtime) the length of the function being used
		* to handle an endpoint. If this is a variadic function, it will fail that
		* check.
		*
		* Therefore, we expect the arguments accepted to be the same length as the
		* `handler` function passed internally.
		*
		* We also set a name to avoid a common useless name in tracing such as
		* `"anonymous"` or `"bound function"`.
		*
		* https://github.com/getsentry/sentry-javascript/issues/3284
		*/ Object.defineProperties(handler, {
            name: {
                value: "InngestHandler"
            },
            length: {
                value: this.handler.length
            }
        });
        return handler;
    }
    get mode() {
        return this._mode;
    }
    set mode(m) {
        this._mode = m;
        if (m) this.client["mode"] = m;
    }
    /**
	* Given a set of functions to check if an action is available from the
	* instance's handler, enact any action that is found.
	*
	* This method can fetch varying payloads of data, but ultimately is the place
	* where _decisions_ are made regarding functionality.
	*
	* For example, if we find that we should be viewing the UI, this function
	* will decide whether the UI should be visible based on the payload it has
	* found (e.g. env vars, options, etc).
	*/ async handleAction({ actions, timer, getInngestHeaders, reqArgs, signatureValidation, body, method, headers }) {
        const isMissingBody = body === void 0;
        try {
            let url = await actions.url("starting to handle request");
            if (method === "POST") {
                if (isMissingBody) {
                    this.log("error", "Missing body when executing, possibly due to missing request body middleware");
                    return {
                        status: 500,
                        headers: {
                            "Content-Type": "application/json"
                        },
                        body: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$strings$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["stringify"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$errors$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["serializeError"])(/* @__PURE__ */ new Error("Missing request body when executing, possibly due to missing request body middleware"))),
                        version: void 0
                    };
                }
                const validationResult = await signatureValidation;
                if (!validationResult.success) return {
                    status: 401,
                    headers: {
                        "Content-Type": "application/json"
                    },
                    body: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$strings$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["stringify"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$errors$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["serializeError"])(validationResult.err)),
                    version: void 0
                };
                const rawProbe = await actions.queryStringWithDefaults("testing for probe", __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["queryKeys"].Probe);
                if (rawProbe) {
                    const probe$1 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$enum$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["enumFromValue"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["probe"], rawProbe);
                    if (!probe$1) return {
                        status: 400,
                        headers: {
                            "Content-Type": "application/json"
                        },
                        body: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$strings$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["stringify"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$errors$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["serializeError"])(/* @__PURE__ */ new Error(`Unknown probe "${rawProbe}"`))),
                        version: void 0
                    };
                    return ({
                        [__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["probe"].Trust]: ()=>({
                                status: 200,
                                headers: {
                                    "Content-Type": "application/json"
                                },
                                body: "",
                                version: void 0
                            })
                    })[probe$1]();
                }
                const fnId = await actions.queryStringWithDefaults("processing run request", __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["queryKeys"].FnId);
                if (!fnId) throw new Error("No function ID found in request");
                const stepId = await actions.queryStringWithDefaults("processing run request", __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["queryKeys"].StepId) || null;
                const { version: version$1, result } = this.runStep({
                    functionId: fnId,
                    data: body,
                    stepId,
                    timer,
                    reqArgs,
                    headers: await headers
                });
                const stepOutput = await result;
                /**
				* Functions can return `undefined`, but we'll always convert this to
				* `null`, as this is appropriately serializable by JSON.
				*/ const opDataUndefinedToNull = (op)=>{
                    op.data = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$functions$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["undefinedToNull"])(op.data);
                    return op;
                };
                const handler = {
                    "function-rejected": (result$1)=>{
                        return {
                            status: result$1.retriable ? 500 : 400,
                            headers: {
                                "Content-Type": "application/json",
                                [__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["headerKeys"].NoRetry]: result$1.retriable ? "false" : "true",
                                ...typeof result$1.retriable === "string" ? {
                                    [__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["headerKeys"].RetryAfter]: result$1.retriable
                                } : {}
                            },
                            body: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$strings$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["stringify"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$functions$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["undefinedToNull"])(result$1.error)),
                            version: version$1
                        };
                    },
                    "function-resolved": (result$1)=>{
                        return {
                            status: 200,
                            headers: {
                                "Content-Type": "application/json"
                            },
                            body: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$strings$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["stringify"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$functions$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["undefinedToNull"])(result$1.data)),
                            version: version$1
                        };
                    },
                    "step-not-found": (result$1)=>{
                        return {
                            status: 500,
                            headers: {
                                "Content-Type": "application/json",
                                [__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["headerKeys"].NoRetry]: "false"
                            },
                            body: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$strings$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["stringify"])({
                                error: `Could not find step "${result$1.step.displayName || result$1.step.id}" to run; timed out`
                            }),
                            version: version$1
                        };
                    },
                    "step-ran": (result$1)=>{
                        const step = opDataUndefinedToNull(result$1.step);
                        return {
                            status: 206,
                            headers: {
                                "Content-Type": "application/json",
                                ...typeof result$1.retriable !== "undefined" ? {
                                    [__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["headerKeys"].NoRetry]: result$1.retriable ? "false" : "true",
                                    ...typeof result$1.retriable === "string" ? {
                                        [__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["headerKeys"].RetryAfter]: result$1.retriable
                                    } : {}
                                } : {}
                            },
                            body: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$strings$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["stringify"])([
                                step
                            ]),
                            version: version$1
                        };
                    },
                    "steps-found": (result$1)=>{
                        const steps = result$1.steps.map(opDataUndefinedToNull);
                        return {
                            status: 206,
                            headers: {
                                "Content-Type": "application/json"
                            },
                            body: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$strings$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["stringify"])(steps),
                            version: version$1
                        };
                    }
                }[stepOutput.type];
                try {
                    return await handler(stepOutput);
                } catch (err) {
                    this.log("error", "Error handling execution result", err);
                    throw err;
                }
            }
            const env = getInngestHeaders()[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["headerKeys"].Environment] ?? null;
            if (method === "GET") return {
                status: 200,
                body: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$strings$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["stringify"])(await this.introspectionBody({
                    actions,
                    env,
                    signatureValidation,
                    url
                })),
                headers: {
                    "Content-Type": "application/json"
                },
                version: void 0
            };
            if (method === "PUT") {
                const [deployId, inBandSyncRequested] = await Promise.all([
                    actions.queryStringWithDefaults("processing deployment request", __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["queryKeys"].DeployId).then((deployId$1)=>{
                        return deployId$1 === "undefined" ? void 0 : deployId$1;
                    }),
                    Promise.resolve((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$env$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["parseAsBoolean"])(this.env[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["envKeys"].InngestAllowInBandSync])).then((allowInBandSync)=>{
                        if (allowInBandSync !== void 0 && !allowInBandSync) return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["syncKind"].OutOfBand;
                        return actions.headers("processing deployment request", __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["headerKeys"].InngestSyncKind);
                    }).then((kind)=>{
                        return kind === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["syncKind"].InBand;
                    })
                ]);
                if (inBandSyncRequested) {
                    if (isMissingBody) {
                        this.log("error", "Missing body when syncing, possibly due to missing request body middleware");
                        return {
                            status: 500,
                            headers: {
                                "Content-Type": "application/json"
                            },
                            body: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$strings$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["stringify"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$errors$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["serializeError"])(/* @__PURE__ */ new Error("Missing request body when syncing, possibly due to missing request body middleware"))),
                            version: void 0
                        };
                    }
                    if (!(await signatureValidation).success) return {
                        status: 401,
                        body: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$strings$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["stringify"])({
                            code: "sig_verification_failed"
                        }),
                        headers: {
                            "Content-Type": "application/json"
                        },
                        version: void 0
                    };
                    const res = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["inBandSyncRequestBodySchema"].safeParse(body);
                    if (!res.success) return {
                        status: 400,
                        body: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$strings$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["stringify"])({
                            code: "invalid_request",
                            message: res.error.message
                        }),
                        headers: {
                            "Content-Type": "application/json"
                        },
                        version: void 0
                    };
                    url = this.reqUrl(new URL(res.data.url));
                    const respBody = await this.inBandRegisterBody({
                        actions,
                        deployId,
                        env,
                        signatureValidation,
                        url
                    });
                    return {
                        status: 200,
                        body: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$strings$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["stringify"])(respBody),
                        headers: {
                            "Content-Type": "application/json",
                            [__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["headerKeys"].InngestSyncKind]: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["syncKind"].InBand
                        },
                        version: void 0
                    };
                }
                const { status, message, modified } = await this.register(this.reqUrl(url), deployId, getInngestHeaders);
                return {
                    status,
                    body: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$strings$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["stringify"])({
                        message,
                        modified
                    }),
                    headers: {
                        "Content-Type": "application/json",
                        [__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["headerKeys"].InngestSyncKind]: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["syncKind"].OutOfBand
                    },
                    version: void 0
                };
            }
        } catch (err) {
            return {
                status: 500,
                body: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$strings$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["stringify"])({
                    type: "internal",
                    ...(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$errors$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["serializeError"])(err)
                }),
                headers: {
                    "Content-Type": "application/json"
                },
                version: void 0
            };
        }
        return {
            status: 405,
            body: JSON.stringify({
                message: "No action found; request was likely not POST, PUT, or GET",
                mode: this._mode
            }),
            headers: {},
            version: void 0
        };
    }
    runStep({ functionId, stepId, data, timer, reqArgs, headers }) {
        const fn = this.fns[functionId];
        if (!fn) throw new Error(`Could not find function with ID "${functionId}"`);
        const immediateFnData = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$functions$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["parseFnData"])(data);
        let { version: version$1 } = immediateFnData;
        if (version$1 === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ExecutionVersion"].V1 && fn.fn["shouldOptimizeParallelism"]?.()) version$1 = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ExecutionVersion"].V2;
        const result = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$promises$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["runAsPromise"])(async ()=>{
            const anyFnData = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$functions$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["fetchAllFnData"])({
                data: immediateFnData,
                api: this.client["inngestApi"],
                version: version$1
            });
            if (!anyFnData.ok) throw new Error(anyFnData.error);
            const executionOptions = await ((s)=>s)({
                [__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ExecutionVersion"].V0]: ({ event, events, steps, ctx, version: version$2 })=>{
                    const stepState = Object.entries(steps ?? {}).reduce((acc, [id, data$1])=>{
                        return {
                            ...acc,
                            [id]: {
                                id,
                                data: data$1
                            }
                        };
                    }, {});
                    return {
                        version: version$2,
                        partialOptions: {
                            client: this.client,
                            runId: ctx?.run_id || "",
                            data: {
                                event,
                                events,
                                runId: ctx?.run_id || "",
                                attempt: ctx?.attempt ?? 0
                            },
                            stepState,
                            requestedRunStep: stepId === "step" ? void 0 : stepId || void 0,
                            timer,
                            isFailureHandler: fn.onFailure,
                            stepCompletionOrder: ctx?.stack?.stack ?? [],
                            reqArgs,
                            headers
                        }
                    };
                },
                [__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ExecutionVersion"].V1]: ({ event, events, steps, ctx, version: version$2 })=>{
                    const stepState = Object.entries(steps ?? {}).reduce((acc, [id, result$1])=>{
                        return {
                            ...acc,
                            [id]: result$1.type === "data" ? {
                                id,
                                data: result$1.data
                            } : result$1.type === "input" ? {
                                id,
                                input: result$1.input
                            } : {
                                id,
                                error: result$1.error
                            }
                        };
                    }, {});
                    return {
                        version: version$2,
                        partialOptions: {
                            client: this.client,
                            runId: ctx?.run_id || "",
                            data: {
                                event,
                                events,
                                runId: ctx?.run_id || "",
                                attempt: ctx?.attempt ?? 0
                            },
                            stepState,
                            requestedRunStep: stepId === "step" ? void 0 : stepId || void 0,
                            timer,
                            isFailureHandler: fn.onFailure,
                            disableImmediateExecution: ctx?.disable_immediate_execution,
                            stepCompletionOrder: ctx?.stack?.stack ?? [],
                            reqArgs,
                            headers
                        }
                    };
                },
                [__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ExecutionVersion"].V2]: ({ event, events, steps, ctx, version: version$2 })=>{
                    const stepState = Object.entries(steps ?? {}).reduce((acc, [id, result$1])=>{
                        return {
                            ...acc,
                            [id]: result$1.type === "data" ? {
                                id,
                                data: result$1.data
                            } : result$1.type === "input" ? {
                                id,
                                input: result$1.input
                            } : {
                                id,
                                error: result$1.error
                            }
                        };
                    }, {});
                    return {
                        version: version$2,
                        partialOptions: {
                            client: this.client,
                            runId: ctx?.run_id || "",
                            data: {
                                event,
                                events,
                                runId: ctx?.run_id || "",
                                attempt: ctx?.attempt ?? 0
                            },
                            stepState,
                            requestedRunStep: stepId === "step" ? void 0 : stepId || void 0,
                            timer,
                            isFailureHandler: fn.onFailure,
                            disableImmediateExecution: ctx?.disable_immediate_execution,
                            stepCompletionOrder: ctx?.stack?.stack ?? [],
                            reqArgs,
                            headers
                        }
                    };
                }
            })[version$1](anyFnData.value);
            return fn.fn["createExecution"](executionOptions).start();
        });
        return {
            version: version$1,
            result
        };
    }
    configs(url) {
        const configs = Object.values(this.rawFns).reduce((acc, fn)=>[
                ...acc,
                ...fn["getConfig"]({
                    baseUrl: url,
                    appPrefix: this.id
                })
            ], []);
        for (const config of configs){
            const check = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["functionConfigSchema"].safeParse(config);
            if (!check.success) {
                const errors = check.error.errors.map((err)=>err.message).join("; ");
                this.log("warn", `Config invalid for function "${config.id}" : ${errors}`);
            }
        }
        return configs;
    }
    /**
	* Return an Inngest serve endpoint URL given a potential `path` and `host`.
	*
	* Will automatically use the `serveHost` and `servePath` if they have been
	* set when registering.
	*/ reqUrl(url) {
        let ret = new URL(url);
        const serveHost = this.serveHost || this.env[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["envKeys"].InngestServeHost];
        const servePath = this.servePath || this.env[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["envKeys"].InngestServePath];
        if (servePath) ret.pathname = servePath;
        if (serveHost) ret = new URL(ret.pathname + ret.search, serveHost);
        return ret;
    }
    registerBody({ url, deployId }) {
        return {
            url: url.href,
            deployType: "ping",
            framework: this.frameworkName,
            appName: this.id,
            functions: this.configs(url),
            sdk: `js:v${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$version$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["version"]}`,
            v: "0.1",
            deployId: deployId || void 0,
            capabilities: {
                trust_probe: "v1",
                connect: "v1"
            },
            appVersion: this.client.appVersion
        };
    }
    async inBandRegisterBody({ actions, deployId, env, signatureValidation, url }) {
        const registerBody = this.registerBody({
            deployId,
            url
        });
        const introspectionBody = await this.introspectionBody({
            actions,
            env,
            signatureValidation,
            url
        });
        const body = {
            app_id: this.id,
            appVersion: this.client.appVersion,
            capabilities: registerBody.capabilities,
            env,
            framework: registerBody.framework,
            functions: registerBody.functions,
            inspection: introspectionBody,
            platform: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$env$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getPlatformName"])({
                ...(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$env$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["allProcessEnv"])(),
                ...this.env
            }),
            sdk_author: "inngest",
            sdk_language: "",
            sdk_version: "",
            sdk: registerBody.sdk,
            url: registerBody.url
        };
        if (introspectionBody.authentication_succeeded) {
            body.sdk_language = introspectionBody.sdk_language;
            body.sdk_version = introspectionBody.sdk_version;
        }
        return body;
    }
    async introspectionBody({ actions, env, signatureValidation, url }) {
        const registerBody = this.registerBody({
            url: this.reqUrl(url),
            deployId: null
        });
        if (!this._mode) throw new Error("No mode set; cannot introspect without mode");
        let introspection = {
            authentication_succeeded: null,
            extra: {
                is_mode_explicit: this._mode.isExplicit
            },
            has_event_key: this.client["eventKeySet"](),
            has_signing_key: Boolean(this.signingKey),
            function_count: registerBody.functions.length,
            mode: this._mode.type,
            schema_version: "2024-05-24"
        };
        if (this._mode.type === "cloud") try {
            if (!(await signatureValidation).success) throw new Error("Signature validation failed");
            introspection = {
                ...introspection,
                authentication_succeeded: true,
                api_origin: this.apiBaseUrl,
                app_id: this.id,
                capabilities: {
                    trust_probe: "v1",
                    connect: "v1"
                },
                env,
                event_api_origin: this.eventApiBaseUrl,
                event_key_hash: this.hashedEventKey ?? null,
                extra: {
                    ...introspection.extra,
                    is_streaming: await this.shouldStream(actions)
                },
                framework: this.frameworkName,
                sdk_language: "js",
                sdk_version: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$version$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["version"],
                serve_origin: this.serveHost ?? null,
                serve_path: this.servePath ?? null,
                signing_key_fallback_hash: this.hashedSigningKeyFallback ?? null,
                signing_key_hash: this.hashedSigningKey ?? null
            };
        } catch  {
            introspection = {
                ...introspection,
                authentication_succeeded: false
            };
        }
        return introspection;
    }
    async register(url, deployId, getHeaders) {
        const body = this.registerBody({
            url,
            deployId
        });
        let res;
        let registerURL = new URL(this.inngestRegisterUrl.href);
        if (this._mode && this._mode.isInferred && this._mode.isDev) {
            const host = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$env$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["devServerHost"])(this.env);
            if (await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$devserver$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["devServerAvailable"])(host, this.fetch)) registerURL = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$devserver$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["devServerUrl"])(host, "/fn/register");
        } else if (this._mode?.explicitDevUrl) registerURL = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$devserver$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["devServerUrl"])(this._mode.explicitDevUrl.href, "/fn/register");
        if (deployId) registerURL.searchParams.set(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["queryKeys"].DeployId, deployId);
        try {
            res = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$net$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["fetchWithAuthFallback"])({
                authToken: this.hashedSigningKey,
                authTokenFallback: this.hashedSigningKeyFallback,
                fetch: this.fetch,
                url: registerURL.href,
                options: {
                    method: "POST",
                    body: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$strings$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["stringify"])(body),
                    headers: {
                        ...getHeaders(),
                        [__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["headerKeys"].InngestSyncKind]: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["syncKind"].OutOfBand
                    },
                    redirect: "follow"
                }
            });
        } catch (err) {
            this.log("error", err);
            return {
                status: 500,
                message: `Failed to register${err instanceof Error ? `; ${err.message}` : ""}`,
                modified: false
            };
        }
        const raw = await res.text();
        let data = {};
        try {
            data = JSON.parse(raw);
        } catch (err) {
            this.log("warn", "Couldn't unpack register response:", err);
            let message = "Failed to register";
            if (err instanceof Error) message += `; ${err.message}`;
            message += `; status code: ${res.status}`;
            return {
                status: 500,
                message,
                modified: false
            };
        }
        let status;
        let error;
        let skipped;
        let modified;
        try {
            ({ status, error, skipped, modified } = registerResSchema.parse(data));
        } catch (err) {
            this.log("warn", "Invalid register response schema:", err);
            let message = "Failed to register";
            if (err instanceof Error) message += `; ${err.message}`;
            message += `; status code: ${res.status}`;
            return {
                status: 500,
                message,
                modified: false
            };
        }
        if (!skipped) this.log("debug", "registered inngest functions:", res.status, res.statusText, data);
        return {
            status,
            message: error,
            modified
        };
    }
    /**
	* Given an environment, upsert any missing keys. This is useful in
	* situations where environment variables are passed directly to handlers or
	* are otherwise difficult to access during initialization.
	*/ upsertKeysFromEnv() {
        if (this.env[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["envKeys"].InngestSigningKey]) {
            if (!this.signingKey) this.signingKey = String(this.env[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["envKeys"].InngestSigningKey]);
            this.client["inngestApi"].setSigningKey(this.signingKey);
        }
        if (this.env[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["envKeys"].InngestSigningKeyFallback]) {
            if (!this.signingKeyFallback) this.signingKeyFallback = String(this.env[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["envKeys"].InngestSigningKeyFallback]);
            this.client["inngestApi"].setSigningKeyFallback(this.signingKeyFallback);
        }
        if (!this.client["eventKeySet"]() && this.env[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["envKeys"].InngestEventKey]) this.client.setEventKey(String(this.env[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["envKeys"].InngestEventKey]));
        if (this.env[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["envKeys"].InngestDevServerUrl]) this.log("warn", `Use of ${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["envKeys"].InngestDevServerUrl} has been deprecated in v3; please use ${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["envKeys"].InngestBaseUrl} instead. See https://www.inngest.com/docs/sdk/migration`);
    }
    /**
	* Validate the signature of a request and return the signing key used to
	* validate it.
	*/ async validateSignature(sig, body) {
        try {
            if (this.skipSignatureValidation) return {
                success: true,
                keyUsed: ""
            };
            if (this._mode && !this._mode.isCloud) return {
                success: true,
                keyUsed: ""
            };
            if (!this.signingKey) throw new Error(`No signing key found in client options or ${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["envKeys"].InngestSigningKey} env var. Find your keys at https://app.inngest.com/secrets`);
            if (!sig) throw new Error(`No ${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["headerKeys"].Signature} provided`);
            return {
                success: true,
                keyUsed: new RequestSignature(sig).verifySignature({
                    body,
                    allowExpiredSignatures: this.allowExpiredSignatures,
                    signingKey: this.signingKey,
                    signingKeyFallback: this.signingKeyFallback
                })
            };
        } catch (err) {
            return {
                success: false,
                err
            };
        }
    }
    getResponseSignature(key, body) {
        const now = Date.now();
        const mac = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$net$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["signDataWithKey"])(body, key, now.toString());
        return `t=${now}&s=${mac}`;
    }
    /**
	* Log to stdout/stderr if the log level is set to include the given level.
	* The default log level is `"info"`.
	*
	* This is an abstraction over `console.log` and will try to use the correct
	* method for the given log level.  For example, `log("error", "foo")` will
	* call `console.error("foo")`.
	*/ log(level, ...args) {
        const logLevels$1 = [
            "debug",
            "info",
            "warn",
            "error",
            "fatal",
            "silent"
        ];
        const logLevelSetting = logLevels$1.indexOf(this.logLevel);
        if (logLevels$1.indexOf(level) >= logLevelSetting) {
            let logger = console.log;
            if (Object.hasOwn(console, level)) logger = console[level];
            logger(`${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["logPrefix"]} ${level} -`, ...args);
        }
    }
};
var RequestSignature = class {
    timestamp;
    signature;
    constructor(sig){
        const params = new URLSearchParams(sig);
        this.timestamp = params.get("t") || "";
        this.signature = params.get("s") || "";
        if (!this.timestamp || !this.signature) throw new Error(`Invalid ${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["headerKeys"].Signature} provided`);
    }
    hasExpired(allowExpiredSignatures) {
        if (allowExpiredSignatures) return false;
        return Date.now() - /* @__PURE__ */ new Date(Number.parseInt(this.timestamp) * 1e3).valueOf() > 1e3 * 60 * 5;
    }
    #verifySignature({ body, signingKey, allowExpiredSignatures }) {
        if (this.hasExpired(allowExpiredSignatures)) throw new Error("Signature has expired");
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$net$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["signDataWithKey"])(body, signingKey, this.timestamp) !== this.signature) throw new Error("Invalid signature");
    }
    verifySignature({ body, signingKey, signingKeyFallback, allowExpiredSignatures }) {
        try {
            this.#verifySignature({
                body,
                signingKey,
                allowExpiredSignatures
            });
            return signingKey;
        } catch (err) {
            if (!signingKeyFallback) throw err;
            this.#verifySignature({
                body,
                signingKey: signingKeyFallback,
                allowExpiredSignatures
            });
            return signingKeyFallback;
        }
    }
};
;
 //# sourceMappingURL=InngestCommHandler.js.map
}),
"[project]/node_modules/inngest/next.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "frameworkName",
    ()=>frameworkName,
    "serve",
    ()=>serve
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$env$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/inngest/helpers/env.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$components$2f$InngestCommHandler$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/inngest/components/InngestCommHandler.js [app-route] (ecmascript)");
;
;
//#region src/next.ts
/**
* The name of the framework, used to identify the framework in Inngest
* dashboards and during testing.
*/ const frameworkName = "nextjs";
const isRecord = (val)=>{
    return typeof val === "object" && val !== null;
};
const isFunction = (val)=>{
    return typeof val === "function";
};
const isNext12ApiResponse = (val)=>{
    return isRecord(val) && isFunction(val.setHeader) && isFunction(val.status) && isFunction(val.send);
};
/**
* In Next.js, serve and register any declared functions with Inngest, making
* them available to be triggered by events.
*
* Supports Next.js 12+, both serverless and edge.
*
* @example Next.js <=12 or the pages router can export the handler directly
* ```ts
* export default serve({ client: inngest, functions: [fn1, fn2] });
* ```
*
* @example Next.js >=13 with the `app` dir must export individual methods
* ```ts
* export const { GET, POST, PUT } = serve({
*            client: inngest,
*            functions: [fn1, fn2],
* });
* ```
*
* @public
*/ const serve = (options)=>{
    /**
	* Next.js 13 uses
	* {@link https://beta.nextjs.org/docs/routing/route-handlers Route Handlers}
	* to declare API routes instead of a generic catch-all method that was
	* available using the `pages/api` directory.
	*
	* This means that users must now export a function for each method supported
	* by the endpoint. For us, this means requiring a user explicitly exports
	* `GET`, `POST`, and `PUT` functions.
	*
	* Because of this, we'll add circular references to those property names of
	* the returned handler, meaning we can write some succinct code to export
	* them. Thanks, @goodoldneon.
	*
	* @example
	* ```ts
	* export const { GET, POST, PUT } = serve(...);
	* ```
	*
	* See {@link https://beta.nextjs.org/docs/routing/route-handlers}
	*/ const baseFn = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$components$2f$InngestCommHandler$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["InngestCommHandler"]({
        frameworkName,
        ...options,
        handler: (reqMethod, ...args)=>{
            const [expectedReq, res] = args;
            const req = expectedReq;
            const getHeader = (key)=>{
                const header = typeof req.headers.get === "function" ? req.headers.get(key) : req.headers[key];
                return Array.isArray(header) ? header[0] : header;
            };
            return {
                body: ()=>typeof req.json === "function" ? req.json() : req.body,
                headers: getHeader,
                method: ()=>{
                    return reqMethod || req.method || "";
                },
                isProduction: ()=>{
                    /**
					* Vercel Edge Functions do not allow dynamic access to environment
					* variables, so we'll manage production checks directly here.
					*
					* We try/catch to avoid situations where Next.js is being used in
					* environments where `process.env` is not accessible or polyfilled.
					*/ try {
                        return ("TURBOPACK compile-time value", "development") === "production";
                    } catch (_err) {}
                },
                queryString: (key, url)=>{
                    const qs = req.query?.[key] || url.searchParams.get(key);
                    return Array.isArray(qs) ? qs[0] : qs;
                },
                url: ()=>{
                    let absoluteUrl;
                    try {
                        absoluteUrl = new URL(req.url);
                    } catch  {}
                    if (absoluteUrl) {
                        /**
						* `req.url` here should may be the full URL, including query string.
						* There are some caveats, however, where Next.js will obfuscate
						* the host. For example, in the case of `host.docker.internal`,
						* Next.js will instead set the host here to `localhost`.
						*
						* To avoid this, we'll try to parse the URL from `req.url`, but
						* also use the `host` header if it's available.
						*/ const host$1 = options.serveHost || getHeader("host");
                        if (host$1) {
                            const hostWithProtocol = new URL(host$1.includes("://") ? host$1 : `${absoluteUrl.protocol}//${host$1}`);
                            absoluteUrl.protocol = hostWithProtocol.protocol;
                            absoluteUrl.host = hostWithProtocol.host;
                            absoluteUrl.port = hostWithProtocol.port;
                            absoluteUrl.username = hostWithProtocol.username;
                            absoluteUrl.password = hostWithProtocol.password;
                        }
                        return absoluteUrl;
                    }
                    let scheme = "https";
                    const host = options.serveHost || getHeader("host") || "";
                    try {
                        if (("TURBOPACK compile-time value", "development") === "development") scheme = "http";
                    } catch (_err) {}
                    return new URL(req.url, `${scheme}://${host}`);
                },
                transformResponse: ({ body, headers, status })=>{
                    /**
					* Carefully attempt to set headers and data on the response object
					* for Next.js 12 support.
					*
					* This also assumes that we're not using Next.js 15, where the `res`
					* object is repopulated as a `RouteContext` object. We expect these
					* methods to NOT be defined in Next.js 15.
					*
					* We could likely use `instanceof ServerResponse` to better check the
					* type of this, though Next.js 12 had issues with this due to not
					* instantiating the response correctly.
					*/ if (isNext12ApiResponse(res)) {
                        for (const [key, value] of Object.entries(headers))res.setHeader(key, value);
                        res.status(status);
                        res.send(body);
                        /**
						* If we're here, we're in a serverless endpoint (not edge), so
						* we've correctly sent the response and can return `undefined`.
						*
						* Next.js 13 edge requires that the return value is typed as
						* `Response`, so we still enforce that as we cannot dynamically
						* adjust typing based on the environment.
						*/ return;
                    }
                    return new ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$env$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getResponse"])())(body, {
                        status,
                        headers
                    });
                },
                transformStreamingResponse: ({ body, headers, status })=>{
                    return new Response(body, {
                        status,
                        headers
                    });
                }
            };
        }
    }).createHandler();
    const fn = baseFn.bind(null, void 0);
    /**
	* Ensure we have a non-variadic length to avoid issues with forced type
	* checking.
	*/ Object.defineProperty(fn, "length", {
        value: 1
    });
    return Object.defineProperties(fn, {
        GET: {
            value: baseFn.bind(null, "GET")
        },
        POST: {
            value: baseFn.bind(null, "POST")
        },
        PUT: {
            value: baseFn.bind(null, "PUT")
        }
    });
};
;
 //# sourceMappingURL=next.js.map
}),
"[project]/node_modules/inngest/components/InngestMiddleware.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "InngestMiddleware",
    ()=>InngestMiddleware,
    "getHookStack",
    ()=>getHookStack
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$functions$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/inngest/helpers/functions.js [app-route] (ecmascript)");
;
//#region src/components/InngestMiddleware.ts
/**
* A middleware that can be registered with Inngest to hook into various
* lifecycles of the SDK and affect input and output of Inngest functionality.
*
* See {@link https://innge.st/middleware}
*
* @example
*
* ```ts
* export const inngest = new Inngest({
*   middleware: [
*     new InngestMiddleware({
*       name: "My Middleware",
*       init: () => {
*         // ...
*       }
*     })
*   ]
* });
* ```
*
* @public
*/ var InngestMiddleware = class InngestMiddleware {
    get [Symbol.toStringTag]() {
        return InngestMiddleware.Tag;
    }
    /**
	* The name of this middleware. Used primarily for debugging and logging
	* purposes.
	*/ name;
    /**
	* This function is used to initialize your middleware and register any hooks
	* you want to use. It will be called once when the SDK is initialized, and
	* should be used to store any state you want to use in other parts of your
	* middleware.
	*
	* It can be synchronous or asynchronous, in which case the client will wait
	* for it to resolve before continuing to initialize the next middleware.
	*
	* Multiple clients could be used in the same application with differing
	* middleware, so do not store state in global variables or assume that your
	* middleware will only be used once.
	*
	* Must return an object detailing the hooks you want to register.
	*/ init;
    constructor({ name, init }){
        this.name = name;
        this.init = init;
    }
};
(function(_InngestMiddleware) {
    _InngestMiddleware.Tag = "Inngest.Middleware";
})(InngestMiddleware || (InngestMiddleware = {}));
/**
* Given some middleware and an entrypoint, runs the initializer for the given
* `key` and returns functions that will pass arguments through a stack of each
* given hook in a middleware's lifecycle.
*
* Lets the middleware initialize before starting.
*/ const getHookStack = async (middleware, key, arg, transforms)=>{
    const hookDirs = hookDirections[key];
    if (!hookDirs) throw new Error(`No hook directions found for key "${String(key)}". This is likely a bug in the Inngest SDK.`);
    const hooksRegistered = await (await middleware).reduce((acc, mw)=>{
        const fn = mw[key];
        if (fn) return [
            ...acc,
            fn
        ];
        return acc;
    }, []).reduce(async (acc, fn)=>{
        return [
            ...await acc,
            await fn(arg)
        ];
    }, Promise.resolve([]));
    const ret = {};
    for (const hook of hooksRegistered){
        const hookKeys = Object.keys(hook);
        for (const key$1 of hookKeys){
            let fns = [
                hook[key$1]
            ];
            const existingWaterfall = ret[key$1];
            if (existingWaterfall) if (hookDirs[key$1] === "forward") fns = [
                existingWaterfall,
                hook[key$1]
            ];
            else fns = [
                hook[key$1],
                existingWaterfall
            ];
            const transform = transforms[key$1];
            ret[key$1] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$functions$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["waterfall"])(fns, transform);
        }
    }
    for (const k of Object.keys(ret)){
        const key$1 = k;
        ret[key$1] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$functions$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["cacheFn"])(ret[key$1]);
    }
    return ret;
};
/**
* The direction of each hook that exists in the middleware lifecycle.
* This is used to determine whether hooks found in a stack run forwards or
* backwards, creating onion-like behaviour.
*/ const hookDirections = {
    onFunctionRun: {
        transformInput: "forward",
        beforeMemoization: "forward",
        afterMemoization: "backward",
        beforeExecution: "forward",
        afterExecution: "backward",
        transformOutput: "backward",
        beforeResponse: "forward",
        finished: "forward"
    },
    onSendEvent: {
        transformInput: "forward",
        transformOutput: "backward"
    }
};
;
 //# sourceMappingURL=InngestMiddleware.js.map
}),
"[project]/node_modules/inngest/components/RetryAfterError.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "RetryAfterError",
    ()=>RetryAfterError
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ms$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/ms/index.js [app-route] (ecmascript)");
;
//#region src/components/RetryAfterError.ts
/**
* An error that, when thrown, indicates to Inngest that the function should be
* retried after a given amount of time.
*
* A `message` must be provided, as well as a `retryAfter` parameter, which can
* be a `number` of milliseconds, an `ms`-compatible time string, or a `Date`.
*
* An optional `cause` can be provided to provide more context to the error.
*
* @public
*/ var RetryAfterError = class extends Error {
    /**
	* The underlying cause of the error, if any.
	*
	* This will be serialized and sent to Inngest.
	*/ cause;
    /**
	* The time after which the function should be retried. Represents either a
	* number of milliseconds or a RFC3339 date.
	*/ retryAfter;
    constructor(message, retryAfter, options){
        super(message);
        if (retryAfter instanceof Date) this.retryAfter = retryAfter.toISOString();
        else {
            const seconds = `${Math.ceil((typeof retryAfter === "string" ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ms$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(retryAfter) : retryAfter) / 1e3)}`;
            if (!isFinite(Number(seconds))) throw new Error("retryAfter must be a number of milliseconds, a ms-compatible string, or a Date");
            this.retryAfter = seconds;
        }
        this.cause = options?.cause;
    }
};
;
 //# sourceMappingURL=RetryAfterError.js.map
}),
"[project]/node_modules/inngest/helpers/temporal.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

//#region src/helpers/temporal.ts
/**
* Asserts that the given `input` is a `Temporal.Duration` object.
*/ __turbopack_context__.s([
    "getISOString",
    ()=>getISOString,
    "isTemporalDuration",
    ()=>isTemporalDuration
]);
const isTemporalDuration = (input)=>{
    try {
        return input[Symbol.toStringTag] === "Temporal.Duration";
    } catch  {
        return false;
    }
};
/**
* Asserts that the given `input` is a `Temporal.TimeZone` object.
*/ const isTemporalInstant = (input)=>{
    try {
        return input[Symbol.toStringTag] === "Temporal.Instant";
    } catch  {
        return false;
    }
};
/**
* Asserts that the given `input` is a `Temporal.ZonedDateTime` object.
*/ const isTemporalZonedDateTime = (input)=>{
    try {
        return input[Symbol.toStringTag] === "Temporal.ZonedDateTime";
    } catch  {
        return false;
    }
};
/**
* Converts a given `Date`, `string`, `Temporal.Instant`, or
* `Temporal.ZonedDateTime` to an ISO 8601 string.
*/ const getISOString = (time)=>{
    if (typeof time === "string") return new Date(time).toISOString();
    if (time instanceof Date) return time.toISOString();
    if (isTemporalZonedDateTime(time)) return time.toInstant().toString();
    if (isTemporalInstant(time)) return time.toString();
    throw new TypeError("Invalid date input");
};
;
 //# sourceMappingURL=temporal.js.map
}),
"[project]/node_modules/inngest/components/InngestFunctionReference.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

//#region src/components/InngestFunctionReference.ts
/**
* A reference to an `InngestFunction` that can be used to represent both local
* and remote functions without pulling in the full function definition (i.e.
* dependencies).
*
* These references can be invoked in the same manner as a regular
* `InngestFunction`.
*
* To create a reference function, use the {@link referenceFunction} helper.
*
* @public
*/ __turbopack_context__.s([
    "InngestFunctionReference",
    ()=>InngestFunctionReference,
    "referenceFunction",
    ()=>referenceFunction
]);
var InngestFunctionReference = class {
    constructor(opts){
        this.opts = opts;
    }
};
/**
* Create a reference to an `InngestFunction` that can be used to represent both
* local and remote functions without pulling in the full function definition
* (i.e. dependencies).
*
* These references can be invoked in the same manner as a regular
* `InngestFunction`.
*
* @public
*/ const referenceFunction = ({ functionId, appId })=>{
    return new InngestFunctionReference({
        functionId,
        appId
    });
};
;
 //# sourceMappingURL=InngestFunctionReference.js.map
}),
"[project]/node_modules/inngest/components/execution/als.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

//#region src/components/execution/als.ts
/**
* A local-only symbol used as a key in global state to store the async local
* storage instance.
*/ __turbopack_context__.s([
    "getAsyncCtx",
    ()=>getAsyncCtx,
    "getAsyncLocalStorage",
    ()=>getAsyncLocalStorage
]);
const alsSymbol = Symbol.for("inngest:als");
/**
* Retrieve the async context for the current execution.
*/ const getAsyncCtx = async ()=>{
    return getAsyncLocalStorage().then((als)=>als.getStore());
};
/**
* Get a singleton instance of `AsyncLocalStorage` used to store and retrieve
* async context for the current execution.
*/ const getAsyncLocalStorage = async ()=>{
    globalThis[alsSymbol] ??= new Promise(async (resolve)=>{
        try {
            const { AsyncLocalStorage } = await __turbopack_context__.A("[externals]/node:async_hooks [external] (node:async_hooks, cjs, async loader)");
            resolve(new AsyncLocalStorage());
        } catch (_err) {
            console.warn("node:async_hooks is not supported in this runtime. Experimental async context is disabled.");
            resolve({
                getStore: ()=>void 0,
                run: (_, fn)=>fn()
            });
        }
    });
    return globalThis[alsSymbol];
};
;
 //# sourceMappingURL=als.js.map
}),
"[project]/node_modules/inngest/components/Fetch.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "fetch",
    ()=>fetch
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$components$2f$execution$2f$als$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/inngest/components/execution/als.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$components$2f$InngestStepTools$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/inngest/components/InngestStepTools.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$debug$2f$src$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/debug/src/index.js [app-route] (ecmascript)");
;
;
;
//#region src/components/Fetch.ts
const globalFetch = globalThis.fetch;
const debug = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$debug$2f$src$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])("inngest:fetch");
const createFetchShim = ()=>{
    let stepFetch;
    const fetch$1 = async (input, init)=>{
        const ctx = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$components$2f$execution$2f$als$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getAsyncCtx"])();
        if (!ctx) {
            if (!stepFetch.fallback) throw new Error("step.fetch() called outside of a function and had no fallback set");
            debug("step.fetch() called outside of a function; falling back to global fetch");
            return stepFetch.fallback(input, init);
        }
        if (ctx.executingStep) {
            if (!stepFetch.fallback) throw new Error(`step.fetch() called inside step "${ctx.executingStep.id}" and had no fallback set`);
            debug(`step.fetch() called inside step "${ctx.executingStep.id}"; falling back to global fetch`);
            return stepFetch.fallback(input, init);
        }
        const targetUrl = new URL(input instanceof Request ? input.url : input.toString());
        debug("step.fetch() shimming request to", targetUrl.hostname);
        const jsonRes = await ctx.ctx.step[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$components$2f$InngestStepTools$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["gatewaySymbol"]](`step.fetch: ${targetUrl.hostname}`, input, init);
        return new Response(jsonRes.body, {
            headers: jsonRes.headers,
            status: jsonRes.status
        });
    };
    const optionsRef = {
        fallback: globalFetch
    };
    const extras = {
        config: (options)=>{
            Object.assign(optionsRef, options);
            Object.assign(stepFetch, optionsRef);
            return stepFetch;
        },
        ...optionsRef
    };
    stepFetch = Object.assign(fetch$1, extras);
    return stepFetch;
};
/**
* `fetch` is a Fetch API-compatible function that can be used to make any HTTP
* code durable if it's called within an Inngest function.
*
* It will gracefully fall back to the global `fetch` if called outside of this
* context, and a custom fallback can be set using the `config` method.
*
* @example Basic usage
* ```ts
* import { fetch } from "inngest";
*
* const api = new MyProductApi({ fetch });
* ```
*
* @example Setting a custom fallback
* ```ts
* import { fetch } from "inngest";
*
* const api = new MyProductApi({
*            fetch: fetch.config({ fallback: myCustomFetch }),
* });
* ```
*
* @example Do not allow fallback
* ```ts
* import { fetch } from "inngest";
*
* const api = new MyProductApi({
*            fetch: fetch.config({ fallback: undefined }),
* });
* ```
*/ const fetch = createFetchShim();
;
 //# sourceMappingURL=Fetch.js.map
}),
"[project]/node_modules/inngest/components/InngestStepTools.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "STEP_INDEXING_SUFFIX",
    ()=>STEP_INDEXING_SUFFIX,
    "createStepTools",
    ()=>createStepTools,
    "gatewaySymbol",
    ()=>gatewaySymbol,
    "getStepOptions",
    ()=>getStepOptions,
    "invokePayloadSchema",
    ()=>invokePayloadSchema
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/inngest/helpers/consts.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$strings$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/inngest/helpers/strings.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/inngest/types.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$temporal$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/inngest/helpers/temporal.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$components$2f$InngestFunction$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/inngest/components/InngestFunction.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$components$2f$InngestFunctionReference$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/inngest/components/InngestFunctionReference.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$components$2f$Fetch$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/inngest/components/Fetch.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/zod/v3/index.js [app-route] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__ = __turbopack_context__.i("[project]/node_modules/zod/v3/external.js [app-route] (ecmascript) <export * as z>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$inngest$2f$ai$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@inngest/ai/dist/index.js [app-route] (ecmascript)");
;
;
;
;
;
;
;
;
;
//#region src/components/InngestStepTools.ts
const getStepOptions = (options)=>{
    if (typeof options === "string") return {
        id: options
    };
    return options;
};
/**
* Suffix used to namespace steps that are automatically indexed.
*/ const STEP_INDEXING_SUFFIX = ":";
/**
* Create a new set of step function tools ready to be used in a step function.
* This function should be run and a fresh set of tools provided every time a
* function is run.
*
* An op stack (function state) is passed in as well as some mutable properties
* that the tools can use to submit a new op.
*/ const createStepTools = (client, execution, stepHandler)=>{
    /**
	* A local helper used to create tools that can be used to submit an op.
	*
	* When using this function, a generic type should be provided which is the
	* function signature exposed to the user.
	*/ const createTool = (matchOp, opts)=>{
        return async (...args)=>{
            return stepHandler({
                args,
                matchOp,
                opts
            });
        };
    };
    /**
	* Create a new step run tool that can be used to run a step function using
	* `step.run()` as a shim.
	*/ const createStepRun = (type)=>{
        return createTool(({ id, name }, _fn, ...input)=>{
            const opts = {
                ...input.length ? {
                    input
                } : {},
                ...type ? {
                    type
                } : {}
            };
            return {
                id,
                op: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["StepOpCode"].StepPlanned,
                name: id,
                displayName: name ?? id,
                ...Object.keys(opts).length ? {
                    opts
                } : {}
            };
        }, {
            fn: (_, fn, ...input)=>fn(...input)
        });
    };
    /**
	* Define the set of tools the user has access to for their step functions.
	*
	* Each key is the function name and is expected to run `createTool` and pass
	* a generic type for that function as it will appear in the user's code.
	*/ const tools = {
        sendEvent: createTool(({ id, name })=>{
            return {
                id,
                op: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["StepOpCode"].StepPlanned,
                name: "sendEvent",
                displayName: name ?? id,
                opts: {
                    type: "step.sendEvent"
                }
            };
        }, {
            fn: (_idOrOptions, payload)=>{
                return client["_send"]({
                    payload,
                    headers: execution["options"]["headers"]
                });
            }
        }),
        waitForSignal: createTool(({ id, name }, opts)=>{
            return {
                id,
                op: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["StepOpCode"].WaitForSignal,
                name: opts.signal,
                displayName: name ?? id,
                opts: {
                    signal: opts.signal,
                    timeout: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$strings$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["timeStr"])(opts.timeout),
                    conflict: opts.onConflict
                }
            };
        }),
        sendSignal: createTool(({ id, name }, opts)=>{
            return {
                id,
                op: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["StepOpCode"].StepPlanned,
                name: "sendSignal",
                displayName: name ?? id,
                opts: {
                    type: "step.sendSignal",
                    signal: opts.signal
                }
            };
        }, {
            fn: (_idOrOptions, opts)=>{
                return client["_sendSignal"]({
                    signal: opts.signal,
                    data: opts.data,
                    headers: execution["options"]["headers"]
                });
            }
        }),
        waitForEvent: createTool(({ id, name }, opts)=>{
            const matchOpts = {
                timeout: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$strings$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["timeStr"])(typeof opts === "string" ? opts : opts.timeout)
            };
            if (typeof opts !== "string") {
                if (opts?.match) matchOpts.if = `event.${opts.match} == async.${opts.match}`;
                else if (opts?.if) matchOpts.if = opts.if;
            }
            return {
                id,
                op: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["StepOpCode"].WaitForEvent,
                name: opts.event,
                opts: matchOpts,
                displayName: name ?? id
            };
        }),
        run: createStepRun(),
        ai: {
            infer: createTool(({ id, name }, options)=>{
                const { model, body, ...rest } = options;
                const modelCopy = {
                    ...model
                };
                options.model.onCall?.(modelCopy, options.body);
                return {
                    id,
                    op: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["StepOpCode"].AiGateway,
                    displayName: name ?? id,
                    opts: {
                        type: "step.ai.infer",
                        url: modelCopy.url,
                        headers: modelCopy.headers,
                        auth_key: modelCopy.authKey,
                        format: modelCopy.format,
                        body,
                        ...rest
                    }
                };
            }),
            wrap: createStepRun("step.ai.wrap"),
            models: {
                ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$inngest$2f$ai$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["models"]
            }
        },
        sleep: createTool(({ id, name }, time)=>{
            /**
			* The presence of this operation in the returned stack indicates that the
			* sleep is over and we should continue execution.
			*/ const msTimeStr = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$strings$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["timeStr"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$temporal$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isTemporalDuration"])(time) ? time.total({
                unit: "milliseconds"
            }) : time);
            return {
                id,
                op: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["StepOpCode"].Sleep,
                name: msTimeStr,
                displayName: name ?? id
            };
        }),
        sleepUntil: createTool(({ id, name }, time)=>{
            try {
                const iso = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$temporal$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getISOString"])(time);
                /**
				* The presence of this operation in the returned stack indicates that the
				* sleep is over and we should continue execution.
				*/ return {
                    id,
                    op: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["StepOpCode"].Sleep,
                    name: iso,
                    displayName: name ?? id
                };
            } catch (err) {
                /**
				* If we're here, it's because the date is invalid. We'll throw a custom
				* error here to standardise this response.
				*/ console.warn("Invalid `Date`, date string, `Temporal.Instant`, or `Temporal.ZonedDateTime` passed to sleepUntil;", err);
                throw new Error(`Invalid \`Date\`, date string, \`Temporal.Instant\`, or \`Temporal.ZonedDateTime\` passed to sleepUntil: ${time}`);
            }
        }),
        invoke: createTool(({ id, name }, invokeOpts)=>{
            const optsSchema = invokePayloadSchema.extend({
                timeout: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].union([
                    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].number(),
                    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
                    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].date()
                ]).optional()
            });
            const parsedFnOpts = optsSchema.extend({
                _type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].literal("fullId").optional().default("fullId"),
                function: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().min(1)
            }).or(optsSchema.extend({
                _type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].literal("fnInstance").optional().default("fnInstance"),
                function: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].instanceof(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$components$2f$InngestFunction$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["InngestFunction"])
            })).or(optsSchema.extend({
                _type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].literal("refInstance").optional().default("refInstance"),
                function: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].instanceof(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$components$2f$InngestFunctionReference$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["InngestFunctionReference"])
            })).safeParse(invokeOpts);
            if (!parsedFnOpts.success) throw new Error(`Invalid invocation options passed to invoke; must include either a function or functionId.`);
            const { _type, function: fn, data, user, v, timeout } = parsedFnOpts.data;
            const opts = {
                payload: {
                    data,
                    user,
                    v
                },
                function_id: "",
                timeout: typeof timeout === "undefined" ? void 0 : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$strings$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["timeStr"])(timeout)
            };
            switch(_type){
                case "fnInstance":
                    opts.function_id = fn.id(fn["client"].id);
                    break;
                case "fullId":
                    console.warn(`${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["logPrefix"]} Invoking function with \`function: string\` is deprecated and will be removed in v4.0.0; use an imported function or \`referenceFunction()\` instead. See https://innge.st/ts-referencing-functions`);
                    opts.function_id = fn;
                    break;
                case "refInstance":
                    opts.function_id = [
                        fn.opts.appId || client.id,
                        fn.opts.functionId
                    ].filter(Boolean).join("-");
                    break;
            }
            return {
                id,
                op: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["StepOpCode"].InvokeFunction,
                displayName: name ?? id,
                opts
            };
        }),
        fetch: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$components$2f$Fetch$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["fetch"]
    };
    tools[gatewaySymbol] = createTool(({ id, name }, input, init)=>{
        const url = input instanceof Request ? input.url : input.toString();
        const headers = {};
        if (input instanceof Request) input.headers.forEach((value, key)=>{
            headers[key] = value;
        });
        else if (init?.headers) new Headers(init.headers).forEach((value, key)=>{
            headers[key] = value;
        });
        return {
            id,
            op: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["StepOpCode"].Gateway,
            displayName: name ?? id,
            opts: {
                url,
                method: init?.method ?? "GET",
                headers,
                body: init?.body
            }
        };
    });
    return tools;
};
const gatewaySymbol = Symbol.for("inngest.step.gateway");
/**
* The event payload portion of the options for `step.invoke()`. This does not
* include non-payload options like `timeout` or the function to invoke.
*/ const invokePayloadSchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
    data: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].record(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].any()).optional(),
    user: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].record(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].any()).optional(),
    v: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().optional()
});
;
 //# sourceMappingURL=InngestStepTools.js.map
}),
"[project]/node_modules/inngest/components/execution/v0.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "createV0InngestExecution",
    ()=>createV0InngestExecution,
    "v0_exports",
    ()=>v0_exports
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$_virtual$2f$rolldown_runtime$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/inngest/_virtual/rolldown_runtime.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$components$2f$NonRetriableError$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/inngest/components/NonRetriableError.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$errors$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/inngest/helpers/errors.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/inngest/types.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$components$2f$execution$2f$InngestExecution$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/inngest/components/execution/InngestExecution.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$functions$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/inngest/helpers/functions.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$promises$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/inngest/helpers/promises.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$components$2f$InngestMiddleware$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/inngest/components/InngestMiddleware.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$components$2f$RetryAfterError$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/inngest/components/RetryAfterError.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$components$2f$InngestStepTools$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/inngest/components/InngestStepTools.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/zod/v3/index.js [app-route] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__ = __turbopack_context__.i("[project]/node_modules/zod/v3/external.js [app-route] (ecmascript) <export * as z>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hash$2e$js$2f$lib$2f$hash$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/hash.js/lib/hash.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$canonicalize$2f$lib$2f$canonicalize$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/canonicalize/lib/canonicalize.js [app-route] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
;
;
;
//#region src/components/execution/v0.ts
var v0_exports = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$_virtual$2f$rolldown_runtime$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["__export"])({
    V0InngestExecution: ()=>V0InngestExecution,
    _internals: ()=>_internals,
    createV0InngestExecution: ()=>createV0InngestExecution
});
const { sha1 } = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hash$2e$js$2f$lib$2f$hash$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"];
const createV0InngestExecution = (options)=>{
    return new V0InngestExecution(options);
};
var V0InngestExecution = class extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$components$2f$execution$2f$InngestExecution$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["InngestExecution"] {
    state;
    execution;
    userFnToRun;
    fnArg;
    constructor(options){
        super(options);
        this.userFnToRun = this.getUserFnToRun();
        this.state = this.createExecutionState();
        this.fnArg = this.createFnArg();
    }
    start() {
        this.debug("starting V0 execution");
        return this.execution ??= this._start().then((result)=>{
            this.debug("result:", result);
            return result;
        });
    }
    async _start() {
        this.state.hooks = await this.initializeMiddleware();
        try {
            await this.transformInput();
            await this.state.hooks.beforeMemoization?.();
            if (this.state.opStack.length === 0 && !this.options.requestedRunStep) {
                await this.state.hooks.afterMemoization?.();
                await this.state.hooks.beforeExecution?.();
            }
            const userFnPromise = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$promises$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["runAsPromise"])(()=>this.userFnToRun(this.fnArg));
            let pos = -1;
            do {
                if (pos >= 0) {
                    if (!this.options.requestedRunStep && pos === this.state.opStack.length - 1) {
                        await this.state.hooks.afterMemoization?.();
                        await this.state.hooks.beforeExecution?.();
                    }
                    this.state.tickOps = {};
                    const incomingOp = this.state.opStack[pos];
                    this.state.currentOp = this.state.allFoundOps[incomingOp.id];
                    if (!this.state.currentOp) /**
					* We're trying to resume the function, but we can't find where to go.
					*
					* This means that either the function has changed or there are async
					* actions in-between steps that we haven't noticed in previous
					* executions.
					*
					* Whichever the case, this is bad and we can't continue in this
					* undefined state.
					*/ throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$components$2f$NonRetriableError$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NonRetriableError"]((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$errors$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["prettyError"])({
                        whatHappened: " Your function was stopped from running",
                        why: "We couldn't resume your function's state because it may have changed since the run started or there are async actions in-between steps that we haven't noticed in previous executions.",
                        consequences: "Continuing to run the function may result in unexpected behaviour, so we've stopped your function to ensure nothing unexpected happened!",
                        toFixNow: "Ensure that your function is either entirely step-based or entirely non-step-based, by either wrapping all asynchronous logic in `step.run()` calls or by removing all `step.*()` calls.",
                        otherwise: "For more information on why step functions work in this manner, see https://www.inngest.com/docs/functions/multi-step#gotchas",
                        stack: true,
                        code: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$errors$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ErrCode"].NON_DETERMINISTIC_FUNCTION
                    }));
                    this.state.currentOp.fulfilled = true;
                    if (typeof incomingOp.data !== "undefined") this.state.currentOp.resolve(incomingOp.data);
                    else this.state.currentOp.reject(incomingOp.error);
                }
                await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$promises$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["resolveAfterPending"])();
                this.state.reset();
                pos++;
            }while (pos < this.state.opStack.length)
            await this.state.hooks.afterMemoization?.();
            const discoveredOps = Object.values(this.state.tickOps).map(tickOpToOutgoing);
            const runStep = this.options.requestedRunStep || this.getEarlyExecRunStep(discoveredOps);
            if (runStep) {
                const userFnOp = this.state.allFoundOps[runStep];
                const stepToRun = userFnOp?.fn;
                if (!stepToRun) throw new Error(`Bad stack; executor requesting to run unknown step "${runStep}"`);
                const outgoingUserFnOp = {
                    ...tickOpToOutgoing(userFnOp),
                    op: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["StepOpCode"].Step
                };
                await this.state.hooks.beforeExecution?.();
                this.state.executingStep = true;
                const { type: _type, ...rest } = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$promises$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["runAsPromise"])(stepToRun).finally(()=>{
                    this.state.executingStep = false;
                }).catch(async (error)=>{
                    return await this.transformOutput({
                        error
                    }, outgoingUserFnOp);
                }).then(async (data)=>{
                    await this.state.hooks?.afterExecution?.();
                    return await this.transformOutput({
                        data
                    }, outgoingUserFnOp);
                });
                return {
                    type: "step-ran",
                    ctx: this.fnArg,
                    ops: this.ops,
                    step: {
                        ...outgoingUserFnOp,
                        ...rest
                    }
                };
            }
            if (!discoveredOps.length) {
                const fnRet = await Promise.race([
                    userFnPromise.then((data)=>({
                            type: "complete",
                            data
                        })),
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$promises$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["resolveNextTick"])().then(()=>({
                            type: "incomplete"
                        }))
                ]);
                if (fnRet.type === "complete") {
                    await this.state.hooks.afterExecution?.();
                    if (Object.values(this.state.allFoundOps).every((op)=>{
                        return op.fulfilled;
                    })) return await this.transformOutput({
                        data: fnRet.data
                    });
                } else if (!this.state.hasUsedTools) {
                    this.state.nonStepFnDetected = true;
                    const data = await userFnPromise;
                    await this.state.hooks.afterExecution?.();
                    return await this.transformOutput({
                        data
                    });
                } else if (!Object.values(this.state.allFoundOps).some((op)=>{
                    return op.fulfilled === false;
                })) throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$components$2f$NonRetriableError$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NonRetriableError"]((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$errors$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["functionStoppedRunningErr"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$errors$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ErrCode"].ASYNC_DETECTED_AFTER_MEMOIZATION));
            }
            await this.state.hooks.afterExecution?.();
            return {
                type: "steps-found",
                ctx: this.fnArg,
                ops: this.ops,
                steps: discoveredOps
            };
        } catch (error) {
            return await this.transformOutput({
                error
            });
        } finally{
            await this.state.hooks.beforeResponse?.();
        }
    }
    async initializeMiddleware() {
        const ctx = this.options.data;
        return await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$components$2f$InngestMiddleware$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getHookStack"])(this.options.fn["middleware"], "onFunctionRun", {
            ctx,
            fn: this.options.fn,
            steps: Object.values(this.options.stepState),
            reqArgs: this.options.reqArgs
        }, {
            transformInput: (prev, output)=>{
                return {
                    ctx: {
                        ...prev.ctx,
                        ...output?.ctx
                    },
                    fn: this.options.fn,
                    steps: prev.steps.map((step, i)=>({
                            ...step,
                            ...output?.steps?.[i]
                        })),
                    reqArgs: prev.reqArgs
                };
            },
            transformOutput: (prev, output)=>{
                return {
                    result: {
                        ...prev.result,
                        ...output?.result
                    },
                    step: prev.step
                };
            }
        });
    }
    createExecutionState() {
        const state = {
            allFoundOps: {},
            tickOps: {},
            tickOpHashes: {},
            currentOp: void 0,
            hasUsedTools: false,
            reset: ()=>{
                state.tickOpHashes = {};
                state.allFoundOps = {
                    ...state.allFoundOps,
                    ...state.tickOps
                };
            },
            nonStepFnDetected: false,
            executingStep: false,
            opStack: this.options.stepCompletionOrder.reduce((acc, stepId)=>{
                const stepState = this.options.stepState[stepId];
                if (!stepState) return acc;
                return [
                    ...acc,
                    stepState
                ];
            }, [])
        };
        return state;
    }
    get ops() {
        return Object.fromEntries(Object.entries(this.state.allFoundOps).map(([id, op])=>[
                id,
                {
                    id: op.id,
                    rawArgs: op.rawArgs,
                    data: op.data,
                    error: op.error,
                    fulfilled: op.fulfilled,
                    seen: true
                }
            ]));
    }
    getUserFnToRun() {
        if (!this.options.isFailureHandler) return this.options.fn["fn"];
        if (!this.options.fn["onFailureFn"]) /**
		* Somehow, we've ended up detecting that this is a failure handler but
		* doesn't have an `onFailure` function. This should never happen.
		*/ throw new Error("Cannot find function `onFailure` handler");
        return this.options.fn["onFailureFn"];
    }
    createFnArg() {
        this.state.tickOps = this.state.allFoundOps;
        /**
		* Create a unique hash of an operation using only a subset of the operation's
		* properties; will never use `data` and will guarantee the order of the
		* object so we don't rely on individual tools for that.
		*
		* If the operation already contains an ID, the current ID will be used
		* instead, so that users can provide their own IDs.
		*/ const hashOp = (op)=>{
            /**
			* It's difficult for v0 to understand whether or not an op has
			* historically contained a custom ID, as all step usage now require them.
			*
			* For this reason, we make the assumption that steps in v0 do not have a
			* custom ID and generate one for them as we would in all recommendations
			* and examples.
			*/ const obj = {
                parent: this.state.currentOp?.id ?? null,
                op: op.op,
                name: op.name,
                opts: op.op === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["StepOpCode"].StepPlanned ? null : op.opts ?? null
            };
            const collisionHash = _internals.hashData(obj);
            const pos = this.state.tickOpHashes[collisionHash] = (this.state.tickOpHashes[collisionHash] ?? -1) + 1;
            return {
                ...op,
                id: _internals.hashData({
                    pos,
                    ...obj
                })
            };
        };
        const stepHandler = ({ args, matchOp, opts })=>{
            if (this.state.nonStepFnDetected) throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$components$2f$NonRetriableError$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NonRetriableError"]((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$errors$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["functionStoppedRunningErr"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$errors$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ErrCode"].STEP_USED_AFTER_ASYNC));
            if (this.state.executingStep) throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$components$2f$NonRetriableError$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NonRetriableError"]((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$errors$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["prettyError"])({
                whatHappened: "Your function was stopped from running",
                why: "We detected that you have nested `step.*` tooling.",
                consequences: "Nesting `step.*` tooling is not supported.",
                stack: true,
                toFixNow: "Make sure you're not using `step.*` tooling inside of other `step.*` tooling. If you need to compose steps together, you can create a new async function and call it from within your step function, or use promise chaining.",
                otherwise: "For more information on step functions with Inngest, see https://www.inngest.com/docs/functions/multi-step",
                code: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$errors$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ErrCode"].NESTING_STEPS
            }));
            this.state.hasUsedTools = true;
            const stepOptions = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$components$2f$InngestStepTools$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getStepOptions"])(args[0]);
            const opId = hashOp(matchOp(stepOptions, ...args.slice(1)));
            return new Promise((resolve, reject)=>{
                this.state.tickOps[opId.id] = {
                    ...opId,
                    ...opts?.fn ? {
                        fn: ()=>opts.fn?.(...args)
                    } : {},
                    rawArgs: args,
                    resolve,
                    reject,
                    fulfilled: false
                };
            });
        };
        const step = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$components$2f$InngestStepTools$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createStepTools"])(this.options.client, this, stepHandler);
        let fnArg = {
            ...this.options.data,
            step
        };
        if (this.options.isFailureHandler) {
            const eventData = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
                error: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["jsonErrorSchema"]
            }).parse(fnArg.event?.data);
            fnArg = {
                ...fnArg,
                error: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$errors$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["deserializeError"])(eventData.error)
            };
        }
        return this.options.transformCtx?.(fnArg) ?? fnArg;
    }
    /**
	* Using middleware, transform input before running.
	*/ async transformInput() {
        const inputMutations = await this.state.hooks?.transformInput?.({
            ctx: {
                ...this.fnArg
            },
            steps: Object.values(this.options.stepState),
            fn: this.options.fn,
            reqArgs: this.options.reqArgs
        });
        if (inputMutations?.ctx) this.fnArg = inputMutations.ctx;
        if (inputMutations?.steps) this.state.opStack = [
            ...inputMutations.steps
        ];
    }
    getEarlyExecRunStep(ops) {
        if (ops.length !== 1) return;
        const op = ops[0];
        if (op && op.op === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["StepOpCode"].StepPlanned) return op.id;
    }
    /**
	* Using middleware, transform output before returning.
	*/ async transformOutput(dataOrError, step) {
        const output = {
            ...dataOrError
        };
        if (typeof output.error !== "undefined") output.data = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$errors$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["serializeError"])(output.error);
        const transformedOutput = await this.state.hooks?.transformOutput?.({
            result: {
                ...output
            },
            step
        });
        const { data, error } = {
            ...output,
            ...transformedOutput?.result
        };
        if (!step) await this.state.hooks?.finished?.({
            result: {
                ...typeof error !== "undefined" ? {
                    error
                } : {
                    data
                }
            }
        });
        if (typeof error !== "undefined") {
            /**
			* Ensure we give middleware the chance to decide on retriable behaviour
			* by looking at the error returned from output transformation.
			*/ let retriable = !(error instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$components$2f$NonRetriableError$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NonRetriableError"]);
            if (retriable && error instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$components$2f$RetryAfterError$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["RetryAfterError"]) retriable = error.retryAfter;
            const serializedError = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$errors$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["serializeError"])(error);
            return {
                type: "function-rejected",
                ctx: this.fnArg,
                ops: this.ops,
                error: serializedError,
                retriable
            };
        }
        return {
            type: "function-resolved",
            ctx: this.fnArg,
            ops: this.ops,
            data: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$functions$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["undefinedToNull"])(data)
        };
    }
};
const tickOpToOutgoing = (op)=>{
    return {
        op: op.op,
        id: op.id,
        name: op.name,
        opts: op.opts
    };
};
const hashData = (op)=>{
    return sha1().update((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$canonicalize$2f$lib$2f$canonicalize$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(op)).digest("hex");
};
/**
* Exported for testing.
*/ const _internals = {
    hashData
};
;
 //# sourceMappingURL=v0.js.map
}),
"[project]/node_modules/inngest/components/execution/otel/access.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

//#region src/components/execution/otel/access.ts
/**
* A map of Inngest clients to their OTel span processors. This is used to
* ensure that we only create one span processor per client, and that we can
* access the span processor from the client without exposing the OTel
* libraries to the user.
*/ __turbopack_context__.s([
    "clientProcessorMap",
    ()=>clientProcessorMap
]);
const clientProcessorMap = /* @__PURE__ */ new WeakMap();
;
 //# sourceMappingURL=access.js.map
}),
"[project]/node_modules/inngest/components/StepError.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "StepError",
    ()=>StepError
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$errors$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/inngest/helpers/errors.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/inngest/types.js [app-route] (ecmascript)");
;
;
//#region src/components/StepError.ts
/**
* An error that represents a step exhausting all retries and failing. This is
* thrown by an Inngest step if it fails.
*
* It's synonymous with an `Error`, with the addition of the `stepId` that
* failed.
*
* @public
*/ var StepError = class extends Error {
    cause;
    constructor(stepId, err){
        const parsedErr = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["jsonErrorSchema"].parse(err);
        super(parsedErr.message);
        this.stepId = stepId;
        this.name = parsedErr.name;
        this.stepId = stepId;
        this.stack = parsedErr.stack ?? void 0;
        this.cause = parsedErr.cause ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$errors$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["deserializeError"])(parsedErr.cause, true) : void 0;
    }
};
;
 //# sourceMappingURL=StepError.js.map
}),
"[project]/node_modules/inngest/components/execution/v1.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "createV1InngestExecution",
    ()=>createV1InngestExecution,
    "v1_exports",
    ()=>v1_exports
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$_virtual$2f$rolldown_runtime$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/inngest/_virtual/rolldown_runtime.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/inngest/helpers/consts.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$version$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/inngest/version.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$components$2f$NonRetriableError$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/inngest/components/NonRetriableError.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$errors$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/inngest/helpers/errors.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/inngest/types.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$components$2f$execution$2f$InngestExecution$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/inngest/components/execution/InngestExecution.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$functions$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/inngest/helpers/functions.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$promises$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/inngest/helpers/promises.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$components$2f$execution$2f$als$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/inngest/components/execution/als.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$components$2f$InngestMiddleware$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/inngest/components/InngestMiddleware.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$components$2f$execution$2f$otel$2f$access$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/inngest/components/execution/otel/access.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$components$2f$RetryAfterError$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/inngest/components/RetryAfterError.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$components$2f$StepError$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/inngest/components/StepError.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$components$2f$InngestStepTools$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/inngest/components/InngestStepTools.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/zod/v3/index.js [app-route] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__ = __turbopack_context__.i("[project]/node_modules/zod/v3/external.js [app-route] (ecmascript) <export * as z>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hash$2e$js$2f$lib$2f$hash$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/hash.js/lib/hash.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$opentelemetry$2f$api$2f$build$2f$esm$2f$trace$2d$api$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@opentelemetry/api/build/esm/trace-api.js [app-route] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
//#region src/components/execution/v1.ts
var v1_exports = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$_virtual$2f$rolldown_runtime$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["__export"])({
    _internals: ()=>_internals,
    createV1InngestExecution: ()=>createV1InngestExecution
});
const { sha1 } = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hash$2e$js$2f$lib$2f$hash$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"];
const createV1InngestExecution = (options)=>{
    return new V1InngestExecution(options);
};
var V1InngestExecution = class extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$components$2f$execution$2f$InngestExecution$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["InngestExecution"] {
    state;
    fnArg;
    checkpointHandlers;
    timeoutDuration = 1e3 * 10;
    execution;
    userFnToRun;
    /**
	* If we're supposed to run a particular step via `requestedRunStep`, this
	* will be a `Promise` that resolves after no steps have been found for
	* `timeoutDuration` milliseconds.
	*
	* If we're not supposed to run a particular step, this will be `undefined`.
	*/ timeout;
    constructor(options){
        super(options);
        this.userFnToRun = this.getUserFnToRun();
        this.state = this.createExecutionState();
        this.fnArg = this.createFnArg();
        this.checkpointHandlers = this.createCheckpointHandlers();
        this.initializeTimer(this.state);
        this.debug("created new V1 execution for run;", this.options.requestedRunStep ? `wanting to run step "${this.options.requestedRunStep}"` : "discovering steps");
        this.debug("existing state keys:", Object.keys(this.state.stepState));
    }
    /**
	* Idempotently start the execution of the user's function.
	*/ start() {
        if (!this.execution) {
            this.debug("starting V1 execution");
            const tracer = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$opentelemetry$2f$api$2f$build$2f$esm$2f$trace$2d$api$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["trace"].getTracer("inngest", __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$version$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["version"]);
            this.execution = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$components$2f$execution$2f$als$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getAsyncLocalStorage"])().then((als)=>{
                return als.run({
                    app: this.options.client,
                    ctx: this.fnArg
                }, async ()=>{
                    return tracer.startActiveSpan("inngest.execution", (span)=>{
                        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$components$2f$execution$2f$otel$2f$access$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["clientProcessorMap"].get(this.options.client)?.declareStartingSpan({
                            span,
                            runId: this.options.runId,
                            traceparent: this.options.headers[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["headerKeys"].TraceParent],
                            tracestate: this.options.headers[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["headerKeys"].TraceState]
                        });
                        return this._start().then((result)=>{
                            this.debug("result:", result);
                            return result;
                        }).finally(()=>{
                            span.end();
                        });
                    });
                });
            });
        }
        return this.execution;
    }
    /**
	* Starts execution of the user's function and the core loop.
	*/ async _start() {
        try {
            const allCheckpointHandler = this.getCheckpointHandler("");
            this.state.hooks = await this.initializeMiddleware();
            await this.startExecution();
            for await (const checkpoint of this.state.loop){
                await allCheckpointHandler(checkpoint);
                const result = await this.getCheckpointHandler(checkpoint.type)(checkpoint);
                if (result) return result;
            }
        } catch (error) {
            return await this.transformOutput({
                error
            });
        } finally{
            this.state.loop.return();
            await this.state.hooks?.beforeResponse?.();
        }
        /**
		* If we're here, the generator somehow finished without returning a value.
		* This should never happen.
		*/ throw new Error("Core loop finished without returning a value");
    }
    /**
	* Creates a handler for every checkpoint type, defining what to do when we
	* reach that checkpoint in the core loop.
	*/ createCheckpointHandlers() {
        return {
            "": (checkpoint)=>{
                this.debug("checkpoint:", checkpoint);
            },
            "function-resolved": async (checkpoint)=>{
                return await this.transformOutput({
                    data: checkpoint.data
                });
            },
            "function-rejected": async (checkpoint)=>{
                return await this.transformOutput({
                    error: checkpoint.error
                });
            },
            "steps-found": async ({ steps })=>{
                const stepResult = await this.tryExecuteStep(steps);
                if (stepResult) {
                    const transformResult = await this.transformOutput(stepResult);
                    /**
					* Transforming output will always return either function rejection or
					* resolution. In most cases, this can be immediately returned, but in
					* this particular case we want to handle it differently.
					*/ if (transformResult.type === "function-resolved") return {
                        type: "step-ran",
                        ctx: transformResult.ctx,
                        ops: transformResult.ops,
                        step: _internals.hashOp({
                            ...stepResult,
                            data: transformResult.data
                        })
                    };
                    else if (transformResult.type === "function-rejected") return {
                        type: "step-ran",
                        ctx: transformResult.ctx,
                        ops: transformResult.ops,
                        step: _internals.hashOp({
                            ...stepResult,
                            error: transformResult.error
                        }),
                        retriable: transformResult.retriable
                    };
                    return transformResult;
                }
                const newSteps = await this.filterNewSteps(Array.from(this.state.steps.values()));
                if (newSteps) return {
                    type: "steps-found",
                    ctx: this.fnArg,
                    ops: this.ops,
                    steps: newSteps
                };
            },
            "step-not-found": ({ step })=>{
                return {
                    type: "step-not-found",
                    ctx: this.fnArg,
                    ops: this.ops,
                    step
                };
            }
        };
    }
    getCheckpointHandler(type) {
        return this.checkpointHandlers[type];
    }
    async tryExecuteStep(steps) {
        const hashedStepIdToRun = this.options.requestedRunStep || this.getEarlyExecRunStep(steps);
        if (!hashedStepIdToRun) return;
        const step = steps.find((step$1)=>step$1.hashedId === hashedStepIdToRun && step$1.fn);
        if (step) return await this.executeStep(step);
        this.timeout?.reset();
    }
    /**
	* Given a list of outgoing ops, decide if we can execute an op early and
	* return the ID of the step to execute if we can.
	*/ getEarlyExecRunStep(steps) {
        /**
		* We may have been disabled due to parallelism, in which case we can't
		* immediately execute unless explicitly requested.
		*/ if (this.options.disableImmediateExecution) return;
        const unfulfilledSteps = steps.filter((step)=>!step.fulfilled);
        if (unfulfilledSteps.length !== 1) return;
        const op = unfulfilledSteps[0];
        if (op && op.op === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["StepOpCode"].StepPlanned) return op.hashedId;
    }
    async filterNewSteps(foundSteps) {
        if (this.options.requestedRunStep) return;
        /**
		* Gather any steps that aren't memoized and report them.
		*/ const newSteps = foundSteps.filter((step)=>!step.fulfilled);
        if (!newSteps.length) return;
        /**
		* Warn if we've found new steps but haven't yet seen all previous
		* steps. This may indicate that step presence isn't determinate.
		*/ let knownSteps = 0;
        for (const step of foundSteps)if (step.fulfilled) knownSteps++;
        if (!(this.state.stepsToFulfill === knownSteps)) console.warn((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$errors$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["prettyError"])({
            type: "warn",
            whatHappened: "Function may be indeterminate",
            why: "We found new steps before seeing all previous steps, which may indicate that the function is non-deterministic.",
            consequences: "This may cause unexpected behaviour as Inngest executes your function.",
            reassurance: "This is expected if a function is updated in the middle of a run, but may indicate a bug if not."
        }));
        /**
		* We're finishing up; let's trigger the last of the hooks.
		*/ await this.state.hooks?.afterMemoization?.();
        await this.state.hooks?.beforeExecution?.();
        await this.state.hooks?.afterExecution?.();
        const stepList = newSteps.map((step)=>({
                displayName: step.displayName,
                op: step.op,
                id: step.hashedId,
                name: step.name,
                opts: step.opts
            }));
        /**
		* We also run `onSendEvent` middleware hooks against `step.invoke()` steps
		* to ensure that their `data` is transformed correctly.
		*/ return await this.transformNewSteps(stepList);
    }
    /**
	* Using middleware, transform any newly-found steps before returning them to
	* an Inngest Server.
	*/ async transformNewSteps(steps) {
        return Promise.all(steps.map(async (step)=>{
            if (step.op !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["StepOpCode"].InvokeFunction) return step;
            /**
			* For each event being sent, create a new `onSendEvent` hook stack to
			* process it. We do this as middleware hooks are intended to run once
			* during each lifecycle (onFunctionRun or onSendEvent) and here, a hook
			* is run for every single event.
			*
			* This is done because a developer can use this hook to filter out
			* events entirely; if we batch all of the events together, we can't
			* tell which ones were filtered out if we're processing >1 invocation
			* here.
			*/ const transformedPayload = await (await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$components$2f$InngestMiddleware$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getHookStack"])(this.options.fn["middleware"], "onSendEvent", void 0, {
                transformInput: (prev, output)=>{
                    return {
                        ...prev,
                        ...output
                    };
                },
                transformOutput: (prev, output)=>{
                    return {
                        result: {
                            ...prev.result,
                            ...output?.result
                        }
                    };
                }
            })).transformInput?.({
                payloads: [
                    {
                        ...step.opts?.payload ?? {},
                        name: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["internalEvents"].FunctionInvoked
                    }
                ]
            });
            const newPayload = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$components$2f$InngestStepTools$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["invokePayloadSchema"].parse(transformedPayload?.payloads?.[0] ?? {});
            return {
                ...step,
                opts: {
                    ...step.opts,
                    payload: {
                        ...step.opts?.payload ?? {},
                        ...newPayload
                    }
                }
            };
        }));
    }
    async executeStep({ id, name, opts, fn, displayName }) {
        this.timeout?.clear();
        await this.state.hooks?.afterMemoization?.();
        await this.state.hooks?.beforeExecution?.();
        const outgoingOp = {
            id,
            op: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["StepOpCode"].StepRun,
            name,
            opts,
            displayName
        };
        this.state.executingStep = outgoingOp;
        const store = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$components$2f$execution$2f$als$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getAsyncCtx"])();
        if (store) store.executingStep = {
            id,
            name: displayName
        };
        this.debug(`executing step "${id}"`);
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$promises$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["runAsPromise"])(fn).finally(async ()=>{
            if (store) delete store.executingStep;
            await this.state.hooks?.afterExecution?.();
        }).then((data)=>{
            return {
                ...outgoingOp,
                data
            };
        }).catch((error)=>{
            return {
                ...outgoingOp,
                op: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["StepOpCode"].StepError,
                error
            };
        });
    }
    /**
	* Starts execution of the user's function, including triggering checkpoints
	* and middleware hooks where appropriate.
	*/ async startExecution() {
        /**
		* Mutate input as neccessary based on middleware.
		*/ await this.transformInput();
        /**
		* Start the timer to time out the run if needed.
		*/ this.timeout?.start();
        await this.state.hooks?.beforeMemoization?.();
        /**
		* If we had no state to begin with, immediately end the memoization phase.
		*/ if (this.state.allStateUsed()) {
            await this.state.hooks?.afterMemoization?.();
            await this.state.hooks?.beforeExecution?.();
        }
        /**
		* Trigger the user's function.
		*/ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$promises$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["runAsPromise"])(()=>this.userFnToRun(this.fnArg)).finally(async ()=>{
            await this.state.hooks?.afterMemoization?.();
            await this.state.hooks?.beforeExecution?.();
            await this.state.hooks?.afterExecution?.();
        }).then((data)=>{
            this.state.setCheckpoint({
                type: "function-resolved",
                data
            });
        }).catch((error)=>{
            this.state.setCheckpoint({
                type: "function-rejected",
                error
            });
        });
    }
    /**
	* Using middleware, transform input before running.
	*/ async transformInput() {
        const inputMutations = await this.state.hooks?.transformInput?.({
            ctx: {
                ...this.fnArg
            },
            steps: Object.values(this.state.stepState),
            fn: this.options.fn,
            reqArgs: this.options.reqArgs
        });
        if (inputMutations?.ctx) this.fnArg = inputMutations.ctx;
        if (inputMutations?.steps) this.state.stepState = Object.fromEntries(inputMutations.steps.map((step)=>[
                step.id,
                step
            ]));
    }
    /**
	* Using middleware, transform output before returning.
	*/ async transformOutput(dataOrError) {
        const output = {
            ...dataOrError
        };
        /**
		* If we've been given an error and it's one that we just threw from a step,
		* we should return a `NonRetriableError` to stop execution.
		*/ if (typeof output.error !== "undefined") output.data = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$errors$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["serializeError"])(output.error);
        const isStepExecution = Boolean(this.state.executingStep);
        const transformedOutput = await this.state.hooks?.transformOutput?.({
            result: {
                ...output
            },
            step: this.state.executingStep
        });
        const { data, error } = {
            ...output,
            ...transformedOutput?.result
        };
        if (!isStepExecution) await this.state.hooks?.finished?.({
            result: {
                ...typeof error !== "undefined" ? {
                    error
                } : {
                    data
                }
            }
        });
        if (typeof error !== "undefined") {
            /**
			* Ensure we give middleware the chance to decide on retriable behaviour
			* by looking at the error returned from output transformation.
			*/ let retriable = !(error instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$components$2f$NonRetriableError$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NonRetriableError"] || error instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$components$2f$StepError$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["StepError"]);
            if (retriable && error instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$components$2f$RetryAfterError$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["RetryAfterError"]) retriable = error.retryAfter;
            const serializedError = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$errors$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["minifyPrettyError"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$errors$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["serializeError"])(error));
            return {
                type: "function-rejected",
                ctx: this.fnArg,
                ops: this.ops,
                error: serializedError,
                retriable
            };
        }
        return {
            type: "function-resolved",
            ctx: this.fnArg,
            ops: this.ops,
            data: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$functions$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["undefinedToNull"])(data)
        };
    }
    createExecutionState() {
        const d = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$promises$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createDeferredPromiseWithStack"])();
        let checkpointResolve = d.deferred.resolve;
        const checkpointResults = d.results;
        const loop = async function*(cleanUp) {
            try {
                while(true){
                    const res = (await checkpointResults.next()).value;
                    if (res) yield res;
                }
            } finally{
                cleanUp?.();
            }
        }(()=>{
            this.timeout?.clear();
            checkpointResults.return();
        });
        const stepsToFulfill = Object.keys(this.options.stepState).length;
        return {
            stepState: this.options.stepState,
            stepsToFulfill,
            steps: /* @__PURE__ */ new Map(),
            loop,
            hasSteps: Boolean(stepsToFulfill),
            stepCompletionOrder: [
                ...this.options.stepCompletionOrder
            ],
            remainingStepsToBeSeen: new Set(this.options.stepCompletionOrder),
            setCheckpoint: (checkpoint)=>{
                ({ resolve: checkpointResolve } = checkpointResolve(checkpoint));
            },
            allStateUsed: ()=>{
                return this.state.remainingStepsToBeSeen.size === 0;
            }
        };
    }
    get ops() {
        return Object.fromEntries(this.state.steps);
    }
    createFnArg() {
        const step = this.createStepTools();
        let fnArg = {
            ...this.options.data,
            step
        };
        /**
		* Handle use of the `onFailure` option by deserializing the error.
		*/ if (this.options.isFailureHandler) {
            const eventData = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
                error: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["jsonErrorSchema"]
            }).parse(fnArg.event?.data);
            fnArg = {
                ...fnArg,
                error: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$errors$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["deserializeError"])(eventData.error)
            };
        }
        return this.options.transformCtx?.(fnArg) ?? fnArg;
    }
    createStepTools() {
        /**
		* A list of steps that have been found and are being rolled up before being
		* reported to the core loop.
		*/ const foundStepsToReport = /* @__PURE__ */ new Map();
        /**
		* A map of the subset of found steps to report that have not yet been
		* handled. Used for fast access to steps that need to be handled in order.
		*/ const unhandledFoundStepsToReport = /* @__PURE__ */ new Map();
        /**
		* A map of the latest sequential step indexes found for each step ID. Used
		* to ensure that we don't index steps in parallel.
		*
		* Note that these must be sequential; if we've seen or assigned `a:1`,
		* `a:2` and `a:4`, the latest sequential step index is `2`.
		*
		*/ const expectedNextStepIndexes = /* @__PURE__ */ new Map();
        /**
		* An ordered list of step IDs that have yet to be handled in this
		* execution. Used to ensure that we handle steps in the order they were
		* found and based on the `stepCompletionOrder` in this execution's state.
		*/ const remainingStepCompletionOrder = this.state.stepCompletionOrder.slice();
        /**
		* A promise that's used to ensure that step reporting cannot be run more than
		* once in a given asynchronous time span.
		*/ let foundStepsReportPromise;
        /**
		* A promise that's used to represent middleware hooks running before
		* execution.
		*/ let beforeExecHooksPromise;
        /**
		* A flag used to ensure that we only warn about parallel indexing once per
		* execution to avoid spamming the console.
		*/ let warnOfParallelIndexing = false;
        /**
		* Counts the number of times we've extended this tick.
		*/ let tickExtensionCount = 0;
        /**
		* Given a colliding step ID, maybe warn the user about parallel indexing.
		*/ const maybeWarnOfParallelIndexing = (collisionId)=>{
            if (warnOfParallelIndexing) return;
            if (this.state.steps.has(collisionId)) {
                if (!foundStepsToReport.has(collisionId)) {
                    warnOfParallelIndexing = true;
                    console.warn((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$errors$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["prettyError"])({
                        type: "warn",
                        whatHappened: "We detected that you have multiple steps with the same ID.",
                        code: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$errors$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ErrCode"].AUTOMATIC_PARALLEL_INDEXING,
                        why: `This can happen if you're using the same ID for multiple steps across different chains of parallel work. We found the issue with step "${collisionId}".`,
                        reassurance: "Your function is still running, though it may exhibit unexpected behaviour.",
                        consequences: "Using the same IDs across parallel chains of work can cause unexpected behaviour.",
                        toFixNow: "We recommend using a unique ID for each step, especially those happening in parallel."
                    }));
                }
            }
        };
        /**
		* A helper used to report steps to the core loop. Used after adding an item
		* to `foundStepsToReport`.
		*/ const reportNextTick = ()=>{
            if (foundStepsReportPromise) return;
            let extensionPromise;
            if (++tickExtensionCount >= 10) {
                tickExtensionCount = 0;
                extensionPromise = new Promise((resolve)=>setTimeout(resolve));
            } else extensionPromise = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$promises$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["resolveAfterPending"])();
            foundStepsReportPromise = extensionPromise.then(()=>beforeExecHooksPromise).then(()=>{
                foundStepsReportPromise = void 0;
                for(let i = 0; i < remainingStepCompletionOrder.length; i++){
                    const nextStepId = remainingStepCompletionOrder[i];
                    if (!nextStepId) continue;
                    if (unhandledFoundStepsToReport.get(nextStepId)?.handle()) {
                        remainingStepCompletionOrder.splice(i, 1);
                        unhandledFoundStepsToReport.delete(nextStepId);
                        reportNextTick();
                        return;
                    }
                }
                const steps = [
                    ...foundStepsToReport.values()
                ];
                foundStepsToReport.clear();
                unhandledFoundStepsToReport.clear();
                this.state.setCheckpoint({
                    type: "steps-found",
                    steps
                });
            });
        };
        /**
		* A helper used to push a step to the list of steps to report.
		*/ const pushStepToReport = (step)=>{
            foundStepsToReport.set(step.id, step);
            unhandledFoundStepsToReport.set(step.hashedId, step);
            reportNextTick();
        };
        const stepHandler = async ({ args, matchOp, opts })=>{
            await beforeExecHooksPromise;
            const stepOptions = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$components$2f$InngestStepTools$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getStepOptions"])(args[0]);
            const opId = matchOp(stepOptions, ...args.slice(1));
            if (this.state.executingStep) /**
			* If a step is found after asynchronous actions during another step's
			* execution, everything is fine. The problem here is if we've found
			* that a step nested inside another a step, which is something we don't
			* support at the time of writing.
			*
			* In this case, we could use something like Async Hooks to understand
			* how the step is being triggered, though this isn't available in all
			* environments.
			*
			* Therefore, we'll only show a warning here to indicate that this is
			* potentially an issue.
			*/ console.warn((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$errors$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["prettyError"])({
                whatHappened: `We detected that you have nested \`step.*\` tooling in \`${opId.displayName ?? opId.id}\``,
                consequences: "Nesting `step.*` tooling is not supported.",
                type: "warn",
                reassurance: "It's possible to see this warning if steps are separated by regular asynchronous calls, which is fine.",
                stack: true,
                toFixNow: "Make sure you're not using `step.*` tooling inside of other `step.*` tooling. If you need to compose steps together, you can create a new async function and call it from within your step function, or use promise chaining.",
                code: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$errors$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ErrCode"].NESTING_STEPS
            }));
            if (this.state.steps.has(opId.id)) {
                const originalId = opId.id;
                maybeWarnOfParallelIndexing(originalId);
                const expectedNextIndex = expectedNextStepIndexes.get(originalId) ?? 1;
                for(let i = expectedNextIndex;; i++){
                    const newId = originalId + __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$components$2f$InngestStepTools$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["STEP_INDEXING_SUFFIX"] + i;
                    if (!this.state.steps.has(newId)) {
                        expectedNextStepIndexes.set(originalId, i + 1);
                        opId.id = newId;
                        break;
                    }
                }
            }
            const { promise, resolve, reject } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$promises$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createDeferredPromise"])();
            const hashedId = _internals.hashId(opId.id);
            const stepState = this.state.stepState[hashedId];
            let isFulfilled = false;
            if (stepState) {
                stepState.seen = true;
                this.state.remainingStepsToBeSeen.delete(hashedId);
                if (typeof stepState.input === "undefined") isFulfilled = true;
            }
            let extraOpts;
            let fnArgs = [
                ...args
            ];
            if (typeof stepState?.input !== "undefined" && Array.isArray(stepState.input)) switch(opId.op){
                case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["StepOpCode"].StepPlanned:
                    fnArgs = [
                        ...args.slice(0, 2),
                        ...stepState.input
                    ];
                    extraOpts = {
                        input: [
                            ...stepState.input
                        ]
                    };
                    break;
                case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["StepOpCode"].AiGateway:
                    extraOpts = {
                        body: {
                            ...typeof opId.opts?.body === "object" ? {
                                ...opId.opts.body
                            } : {},
                            ...stepState.input[0]
                        }
                    };
                    break;
            }
            const step = {
                ...opId,
                opts: {
                    ...opId.opts,
                    ...extraOpts
                },
                rawArgs: fnArgs,
                hashedId,
                input: stepState?.input,
                fn: opts?.fn ? ()=>opts.fn?.(...fnArgs) : void 0,
                promise,
                fulfilled: isFulfilled,
                hasStepState: Boolean(stepState),
                displayName: opId.displayName ?? opId.id,
                handled: false,
                handle: ()=>{
                    if (step.handled) return false;
                    step.handled = true;
                    if (isFulfilled && stepState) {
                        stepState.fulfilled = true;
                        Promise.all([
                            stepState.data,
                            stepState.error,
                            stepState.input
                        ]).then(()=>{
                            if (typeof stepState.data !== "undefined") resolve(stepState.data);
                            else {
                                this.state.recentlyRejectedStepError = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$components$2f$StepError$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["StepError"](opId.id, stepState.error);
                                reject(this.state.recentlyRejectedStepError);
                            }
                        });
                    }
                    return true;
                }
            };
            this.state.steps.set(opId.id, step);
            this.state.hasSteps = true;
            pushStepToReport(step);
            /**
			* If this is the last piece of state we had, we've now finished
			* memoizing.
			*/ if (!beforeExecHooksPromise && this.state.allStateUsed()) await (beforeExecHooksPromise = (async ()=>{
                await this.state.hooks?.afterMemoization?.();
                await this.state.hooks?.beforeExecution?.();
            })());
            return promise;
        };
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$components$2f$InngestStepTools$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createStepTools"])(this.options.client, this, stepHandler);
    }
    getUserFnToRun() {
        if (!this.options.isFailureHandler) return this.options.fn["fn"];
        if (!this.options.fn["onFailureFn"]) /**
		* Somehow, we've ended up detecting that this is a failure handler but
		* doesn't have an `onFailure` function. This should never happen.
		*/ throw new Error("Cannot find function `onFailure` handler");
        return this.options.fn["onFailureFn"];
    }
    initializeTimer(state) {
        if (!this.options.requestedRunStep) return;
        this.timeout = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$promises$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createTimeoutPromise"])(this.timeoutDuration);
        this.timeout.then(async ()=>{
            await this.state.hooks?.afterMemoization?.();
            await this.state.hooks?.beforeExecution?.();
            await this.state.hooks?.afterExecution?.();
            state.setCheckpoint({
                type: "step-not-found",
                step: {
                    id: this.options.requestedRunStep,
                    op: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["StepOpCode"].StepNotFound
                }
            });
        });
    }
    async initializeMiddleware() {
        const ctx = this.options.data;
        return await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$components$2f$InngestMiddleware$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getHookStack"])(this.options.fn["middleware"], "onFunctionRun", {
            ctx,
            fn: this.options.fn,
            steps: Object.values(this.options.stepState),
            reqArgs: this.options.reqArgs
        }, {
            transformInput: (prev, output)=>{
                return {
                    ctx: {
                        ...prev.ctx,
                        ...output?.ctx
                    },
                    fn: this.options.fn,
                    steps: prev.steps.map((step, i)=>({
                            ...step,
                            ...output?.steps?.[i]
                        })),
                    reqArgs: prev.reqArgs
                };
            },
            transformOutput: (prev, output)=>{
                return {
                    result: {
                        ...prev.result,
                        ...output?.result
                    },
                    step: prev.step
                };
            }
        });
    }
};
const hashId = (id)=>{
    return sha1().update(id).digest("hex");
};
const hashOp = (op)=>{
    return {
        ...op,
        id: hashId(op.id)
    };
};
/**
* Exported for testing.
*/ const _internals = {
    hashOp,
    hashId
};
;
 //# sourceMappingURL=v1.js.map
}),
"[project]/node_modules/inngest/components/execution/v2.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "createV2InngestExecution",
    ()=>createV2InngestExecution,
    "v2_exports",
    ()=>v2_exports
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$_virtual$2f$rolldown_runtime$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/inngest/_virtual/rolldown_runtime.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/inngest/helpers/consts.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$version$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/inngest/version.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$components$2f$NonRetriableError$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/inngest/components/NonRetriableError.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$errors$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/inngest/helpers/errors.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/inngest/types.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$components$2f$execution$2f$InngestExecution$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/inngest/components/execution/InngestExecution.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$functions$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/inngest/helpers/functions.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$promises$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/inngest/helpers/promises.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$components$2f$execution$2f$als$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/inngest/components/execution/als.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$components$2f$InngestMiddleware$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/inngest/components/InngestMiddleware.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$components$2f$execution$2f$otel$2f$access$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/inngest/components/execution/otel/access.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$components$2f$RetryAfterError$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/inngest/components/RetryAfterError.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$components$2f$StepError$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/inngest/components/StepError.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$components$2f$InngestStepTools$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/inngest/components/InngestStepTools.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/zod/v3/index.js [app-route] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__ = __turbopack_context__.i("[project]/node_modules/zod/v3/external.js [app-route] (ecmascript) <export * as z>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hash$2e$js$2f$lib$2f$hash$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/hash.js/lib/hash.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$opentelemetry$2f$api$2f$build$2f$esm$2f$trace$2d$api$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@opentelemetry/api/build/esm/trace-api.js [app-route] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
//#region src/components/execution/v2.ts
var v2_exports = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$_virtual$2f$rolldown_runtime$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["__export"])({
    _internals: ()=>_internals,
    createV2InngestExecution: ()=>createV2InngestExecution
});
const { sha1 } = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hash$2e$js$2f$lib$2f$hash$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"];
const createV2InngestExecution = (options)=>{
    return new V2InngestExecution(options);
};
var V2InngestExecution = class extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$components$2f$execution$2f$InngestExecution$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["InngestExecution"] {
    state;
    fnArg;
    checkpointHandlers;
    timeoutDuration = 1e3 * 10;
    execution;
    userFnToRun;
    /**
	* If we're supposed to run a particular step via `requestedRunStep`, this
	* will be a `Promise` that resolves after no steps have been found for
	* `timeoutDuration` milliseconds.
	*
	* If we're not supposed to run a particular step, this will be `undefined`.
	*/ timeout;
    constructor(options){
        super(options);
        this.userFnToRun = this.getUserFnToRun();
        this.state = this.createExecutionState();
        this.fnArg = this.createFnArg();
        this.checkpointHandlers = this.createCheckpointHandlers();
        this.initializeTimer(this.state);
        this.debug("created new V2 execution for run;", this.options.requestedRunStep ? `wanting to run step "${this.options.requestedRunStep}"` : "discovering steps");
        this.debug("existing state keys:", Object.keys(this.state.stepState));
    }
    /**
	* Idempotently start the execution of the user's function.
	*/ start() {
        if (!this.execution) {
            this.debug("starting V2 execution");
            const tracer = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$opentelemetry$2f$api$2f$build$2f$esm$2f$trace$2d$api$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["trace"].getTracer("inngest", __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$version$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["version"]);
            this.execution = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$components$2f$execution$2f$als$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getAsyncLocalStorage"])().then((als)=>{
                return als.run({
                    app: this.options.client,
                    ctx: this.fnArg
                }, async ()=>{
                    return tracer.startActiveSpan("inngest.execution", (span)=>{
                        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$components$2f$execution$2f$otel$2f$access$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["clientProcessorMap"].get(this.options.client)?.declareStartingSpan({
                            span,
                            runId: this.options.runId,
                            traceparent: this.options.headers[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["headerKeys"].TraceParent],
                            tracestate: this.options.headers[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["headerKeys"].TraceState]
                        });
                        return this._start().then((result)=>{
                            this.debug("result:", result);
                            return result;
                        }).finally(()=>{
                            span.end();
                        });
                    });
                });
            });
        }
        return this.execution;
    }
    /**
	* Starts execution of the user's function and the core loop.
	*/ async _start() {
        try {
            const allCheckpointHandler = this.getCheckpointHandler("");
            this.state.hooks = await this.initializeMiddleware();
            await this.startExecution();
            for await (const checkpoint of this.state.loop){
                await allCheckpointHandler(checkpoint);
                const result = await this.getCheckpointHandler(checkpoint.type)(checkpoint);
                if (result) return result;
            }
        } catch (error) {
            return await this.transformOutput({
                error
            });
        } finally{
            this.state.loop.return();
            await this.state.hooks?.beforeResponse?.();
        }
        /**
		* If we're here, the generator somehow finished without returning a value.
		* This should never happen.
		*/ throw new Error("Core loop finished without returning a value");
    }
    /**
	* Creates a handler for every checkpoint type, defining what to do when we
	* reach that checkpoint in the core loop.
	*/ createCheckpointHandlers() {
        return {
            "": (checkpoint)=>{
                this.debug("checkpoint:", checkpoint);
            },
            "function-resolved": async (checkpoint)=>{
                return await this.transformOutput({
                    data: checkpoint.data
                });
            },
            "function-rejected": async (checkpoint)=>{
                return await this.transformOutput({
                    error: checkpoint.error
                });
            },
            "steps-found": async ({ steps })=>{
                const stepResult = await this.tryExecuteStep(steps);
                if (stepResult) {
                    const transformResult = await this.transformOutput(stepResult);
                    /**
					* Transforming output will always return either function rejection or
					* resolution. In most cases, this can be immediately returned, but in
					* this particular case we want to handle it differently.
					*/ if (transformResult.type === "function-resolved") return {
                        type: "step-ran",
                        ctx: transformResult.ctx,
                        ops: transformResult.ops,
                        step: _internals.hashOp({
                            ...stepResult,
                            data: transformResult.data
                        })
                    };
                    else if (transformResult.type === "function-rejected") return {
                        type: "step-ran",
                        ctx: transformResult.ctx,
                        ops: transformResult.ops,
                        step: _internals.hashOp({
                            ...stepResult,
                            error: transformResult.error
                        }),
                        retriable: transformResult.retriable
                    };
                    return transformResult;
                }
                const newSteps = await this.filterNewSteps(Array.from(this.state.steps.values()));
                if (newSteps) return {
                    type: "steps-found",
                    ctx: this.fnArg,
                    ops: this.ops,
                    steps: newSteps
                };
            },
            "step-not-found": ({ step })=>{
                return {
                    type: "step-not-found",
                    ctx: this.fnArg,
                    ops: this.ops,
                    step
                };
            }
        };
    }
    getCheckpointHandler(type) {
        return this.checkpointHandlers[type];
    }
    async tryExecuteStep(steps) {
        const hashedStepIdToRun = this.options.requestedRunStep || this.getEarlyExecRunStep(steps);
        if (!hashedStepIdToRun) return;
        const step = steps.find((step$1)=>step$1.hashedId === hashedStepIdToRun && step$1.fn);
        if (step) return await this.executeStep(step);
        this.timeout?.reset();
    }
    /**
	* Given a list of outgoing ops, decide if we can execute an op early and
	* return the ID of the step to execute if we can.
	*/ getEarlyExecRunStep(steps) {
        /**
		* We may have been disabled due to parallelism, in which case we can't
		* immediately execute unless explicitly requested.
		*/ if (this.options.disableImmediateExecution) return;
        const unfulfilledSteps = steps.filter((step)=>!step.fulfilled);
        if (unfulfilledSteps.length !== 1) return;
        const op = unfulfilledSteps[0];
        if (op && op.op === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["StepOpCode"].StepPlanned) return op.hashedId;
    }
    async filterNewSteps(foundSteps) {
        if (this.options.requestedRunStep) return;
        /**
		* Gather any steps that aren't memoized and report them.
		*/ const newSteps = foundSteps.filter((step)=>!step.fulfilled);
        if (!newSteps.length) return;
        /**
		* Warn if we've found new steps but haven't yet seen all previous
		* steps. This may indicate that step presence isn't determinate.
		*/ let knownSteps = 0;
        for (const step of foundSteps)if (step.fulfilled) knownSteps++;
        if (!(this.state.stepsToFulfill === knownSteps)) console.warn((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$errors$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["prettyError"])({
            type: "warn",
            whatHappened: "Function may be indeterminate",
            why: "We found new steps before seeing all previous steps, which may indicate that the function is non-deterministic.",
            consequences: "This may cause unexpected behaviour as Inngest executes your function.",
            reassurance: "This is expected if a function is updated in the middle of a run, but may indicate a bug if not."
        }));
        /**
		* We're finishing up; let's trigger the last of the hooks.
		*/ await this.state.hooks?.afterMemoization?.();
        await this.state.hooks?.beforeExecution?.();
        await this.state.hooks?.afterExecution?.();
        const stepList = newSteps.map((step)=>({
                displayName: step.displayName,
                op: step.op,
                id: step.hashedId,
                name: step.name,
                opts: step.opts
            }));
        /**
		* We also run `onSendEvent` middleware hooks against `step.invoke()` steps
		* to ensure that their `data` is transformed correctly.
		*/ return await this.transformNewSteps(stepList);
    }
    /**
	* Using middleware, transform any newly-found steps before returning them to
	* an Inngest Server.
	*/ async transformNewSteps(steps) {
        return Promise.all(steps.map(async (step)=>{
            if (step.op !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["StepOpCode"].InvokeFunction) return step;
            /**
			* For each event being sent, create a new `onSendEvent` hook stack to
			* process it. We do this as middleware hooks are intended to run once
			* during each lifecycle (onFunctionRun or onSendEvent) and here, a hook
			* is run for every single event.
			*
			* This is done because a developer can use this hook to filter out
			* events entirely; if we batch all of the events together, we can't
			* tell which ones were filtered out if we're processing >1 invocation
			* here.
			*/ const transformedPayload = await (await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$components$2f$InngestMiddleware$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getHookStack"])(this.options.fn["middleware"], "onSendEvent", void 0, {
                transformInput: (prev, output)=>{
                    return {
                        ...prev,
                        ...output
                    };
                },
                transformOutput: (prev, output)=>{
                    return {
                        result: {
                            ...prev.result,
                            ...output?.result
                        }
                    };
                }
            })).transformInput?.({
                payloads: [
                    {
                        ...step.opts?.payload ?? {},
                        name: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["internalEvents"].FunctionInvoked
                    }
                ]
            });
            const newPayload = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$components$2f$InngestStepTools$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["invokePayloadSchema"].parse(transformedPayload?.payloads?.[0] ?? {});
            return {
                ...step,
                opts: {
                    ...step.opts,
                    payload: {
                        ...step.opts?.payload ?? {},
                        ...newPayload
                    }
                }
            };
        }));
    }
    async executeStep({ id, name, opts, fn, displayName }) {
        this.timeout?.clear();
        await this.state.hooks?.afterMemoization?.();
        await this.state.hooks?.beforeExecution?.();
        const outgoingOp = {
            id,
            op: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["StepOpCode"].StepRun,
            name,
            opts,
            displayName
        };
        this.state.executingStep = outgoingOp;
        const store = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$components$2f$execution$2f$als$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getAsyncCtx"])();
        if (store) store.executingStep = {
            id,
            name: displayName
        };
        this.debug(`executing step "${id}"`);
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$promises$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["runAsPromise"])(fn).finally(async ()=>{
            if (store) delete store.executingStep;
            await this.state.hooks?.afterExecution?.();
        }).then((data)=>{
            return {
                ...outgoingOp,
                data
            };
        }).catch((error)=>{
            return {
                ...outgoingOp,
                op: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["StepOpCode"].StepError,
                error
            };
        });
    }
    /**
	* Starts execution of the user's function, including triggering checkpoints
	* and middleware hooks where appropriate.
	*/ async startExecution() {
        /**
		* Mutate input as neccessary based on middleware.
		*/ await this.transformInput();
        /**
		* Start the timer to time out the run if needed.
		*/ this.timeout?.start();
        await this.state.hooks?.beforeMemoization?.();
        /**
		* If we had no state to begin with, immediately end the memoization phase.
		*/ if (this.state.allStateUsed()) {
            await this.state.hooks?.afterMemoization?.();
            await this.state.hooks?.beforeExecution?.();
        }
        /**
		* Trigger the user's function.
		*/ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$promises$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["runAsPromise"])(()=>this.userFnToRun(this.fnArg)).finally(async ()=>{
            await this.state.hooks?.afterMemoization?.();
            await this.state.hooks?.beforeExecution?.();
            await this.state.hooks?.afterExecution?.();
        }).then((data)=>{
            this.state.setCheckpoint({
                type: "function-resolved",
                data
            });
        }).catch((error)=>{
            this.state.setCheckpoint({
                type: "function-rejected",
                error
            });
        });
    }
    /**
	* Using middleware, transform input before running.
	*/ async transformInput() {
        const inputMutations = await this.state.hooks?.transformInput?.({
            ctx: {
                ...this.fnArg
            },
            steps: Object.values(this.state.stepState),
            fn: this.options.fn,
            reqArgs: this.options.reqArgs
        });
        if (inputMutations?.ctx) this.fnArg = inputMutations.ctx;
        if (inputMutations?.steps) this.state.stepState = Object.fromEntries(inputMutations.steps.map((step)=>[
                step.id,
                step
            ]));
    }
    /**
	* Using middleware, transform output before returning.
	*/ async transformOutput(dataOrError) {
        const output = {
            ...dataOrError
        };
        /**
		* If we've been given an error and it's one that we just threw from a step,
		* we should return a `NonRetriableError` to stop execution.
		*/ if (typeof output.error !== "undefined") output.data = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$errors$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["serializeError"])(output.error);
        const isStepExecution = Boolean(this.state.executingStep);
        const transformedOutput = await this.state.hooks?.transformOutput?.({
            result: {
                ...output
            },
            step: this.state.executingStep
        });
        const { data, error } = {
            ...output,
            ...transformedOutput?.result
        };
        if (!isStepExecution) await this.state.hooks?.finished?.({
            result: {
                ...typeof error !== "undefined" ? {
                    error
                } : {
                    data
                }
            }
        });
        if (typeof error !== "undefined") {
            /**
			* Ensure we give middleware the chance to decide on retriable behaviour
			* by looking at the error returned from output transformation.
			*/ let retriable = !(error instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$components$2f$NonRetriableError$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NonRetriableError"] || error instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$components$2f$StepError$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["StepError"]);
            if (retriable && error instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$components$2f$RetryAfterError$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["RetryAfterError"]) retriable = error.retryAfter;
            const serializedError = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$errors$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["minifyPrettyError"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$errors$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["serializeError"])(error));
            return {
                type: "function-rejected",
                ctx: this.fnArg,
                ops: this.ops,
                error: serializedError,
                retriable
            };
        }
        return {
            type: "function-resolved",
            ctx: this.fnArg,
            ops: this.ops,
            data: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$functions$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["undefinedToNull"])(data)
        };
    }
    createExecutionState() {
        const d = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$promises$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createDeferredPromiseWithStack"])();
        let checkpointResolve = d.deferred.resolve;
        const checkpointResults = d.results;
        const loop = async function*(cleanUp) {
            try {
                while(true){
                    const res = (await checkpointResults.next()).value;
                    if (res) yield res;
                }
            } finally{
                cleanUp?.();
            }
        }(()=>{
            this.timeout?.clear();
            checkpointResults.return();
        });
        const stepsToFulfill = Object.keys(this.options.stepState).length;
        return {
            stepState: this.options.stepState,
            stepsToFulfill,
            steps: /* @__PURE__ */ new Map(),
            loop,
            hasSteps: Boolean(stepsToFulfill),
            stepCompletionOrder: [
                ...this.options.stepCompletionOrder
            ],
            remainingStepsToBeSeen: new Set(this.options.stepCompletionOrder),
            setCheckpoint: (checkpoint)=>{
                ({ resolve: checkpointResolve } = checkpointResolve(checkpoint));
            },
            allStateUsed: ()=>{
                return this.state.remainingStepsToBeSeen.size === 0;
            }
        };
    }
    get ops() {
        return Object.fromEntries(this.state.steps);
    }
    createFnArg() {
        const step = this.createStepTools();
        let fnArg = {
            ...this.options.data,
            step
        };
        /**
		* Handle use of the `onFailure` option by deserializing the error.
		*/ if (this.options.isFailureHandler) {
            const eventData = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
                error: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["jsonErrorSchema"]
            }).parse(fnArg.event?.data);
            fnArg = {
                ...fnArg,
                error: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$errors$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["deserializeError"])(eventData.error)
            };
        }
        return this.options.transformCtx?.(fnArg) ?? fnArg;
    }
    createStepTools() {
        /**
		* A list of steps that have been found and are being rolled up before being
		* reported to the core loop.
		*/ const foundStepsToReport = /* @__PURE__ */ new Map();
        /**
		* A map of the subset of found steps to report that have not yet been
		* handled. Used for fast access to steps that need to be handled in order.
		*/ const unhandledFoundStepsToReport = /* @__PURE__ */ new Map();
        /**
		* A map of the latest sequential step indexes found for each step ID. Used
		* to ensure that we don't index steps in parallel.
		*
		* Note that these must be sequential; if we've seen or assigned `a:1`,
		* `a:2` and `a:4`, the latest sequential step index is `2`.
		*
		*/ const expectedNextStepIndexes = /* @__PURE__ */ new Map();
        /**
		* A promise that's used to ensure that step reporting cannot be run more than
		* once in a given asynchronous time span.
		*/ let foundStepsReportPromise;
        /**
		* A promise that's used to represent middleware hooks running before
		* execution.
		*/ let beforeExecHooksPromise;
        /**
		* A helper used to report steps to the core loop. Used after adding an item
		* to `foundStepsToReport`.
		*/ const reportNextTick = ()=>{
            if (foundStepsReportPromise) return;
            foundStepsReportPromise = new Promise((resolve)=>setImmediate(resolve)).then(()=>beforeExecHooksPromise).then(()=>{
                foundStepsReportPromise = void 0;
                for (const [hashedId, step] of unhandledFoundStepsToReport)if (step.handle()) {
                    unhandledFoundStepsToReport.delete(hashedId);
                    if (step.fulfilled) foundStepsToReport.delete(step.id);
                }
                if (foundStepsToReport.size) {
                    const steps = [
                        ...foundStepsToReport.values()
                    ];
                    foundStepsToReport.clear();
                    this.state.setCheckpoint({
                        type: "steps-found",
                        steps
                    });
                    return;
                }
            });
        };
        /**
		* A helper used to push a step to the list of steps to report.
		*/ const pushStepToReport = (step)=>{
            foundStepsToReport.set(step.id, step);
            unhandledFoundStepsToReport.set(step.hashedId, step);
            reportNextTick();
        };
        const stepHandler = async ({ args, matchOp, opts })=>{
            await beforeExecHooksPromise;
            const stepOptions = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$components$2f$InngestStepTools$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getStepOptions"])(args[0]);
            const opId = matchOp(stepOptions, ...args.slice(1));
            if (this.state.executingStep) /**
			* If a step is found after asynchronous actions during another step's
			* execution, everything is fine. The problem here is if we've found
			* that a step nested inside another a step, which is something we don't
			* support at the time of writing.
			*
			* In this case, we could use something like Async Hooks to understand
			* how the step is being triggered, though this isn't available in all
			* environments.
			*
			* Therefore, we'll only show a warning here to indicate that this is
			* potentially an issue.
			*/ console.warn((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$errors$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["prettyError"])({
                whatHappened: `We detected that you have nested \`step.*\` tooling in \`${opId.displayName ?? opId.id}\``,
                consequences: "Nesting `step.*` tooling is not supported.",
                type: "warn",
                reassurance: "It's possible to see this warning if steps are separated by regular asynchronous calls, which is fine.",
                stack: true,
                toFixNow: "Make sure you're not using `step.*` tooling inside of other `step.*` tooling. If you need to compose steps together, you can create a new async function and call it from within your step function, or use promise chaining.",
                code: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$errors$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ErrCode"].NESTING_STEPS
            }));
            if (this.state.steps.has(opId.id)) {
                const originalId = opId.id;
                const expectedNextIndex = expectedNextStepIndexes.get(originalId) ?? 1;
                for(let i = expectedNextIndex;; i++){
                    const newId = originalId + __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$components$2f$InngestStepTools$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["STEP_INDEXING_SUFFIX"] + i;
                    if (!this.state.steps.has(newId)) {
                        expectedNextStepIndexes.set(originalId, i + 1);
                        opId.id = newId;
                        break;
                    }
                }
            }
            const { promise, resolve, reject } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$promises$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createDeferredPromise"])();
            const hashedId = _internals.hashId(opId.id);
            const stepState = this.state.stepState[hashedId];
            let isFulfilled = false;
            if (stepState) {
                stepState.seen = true;
                this.state.remainingStepsToBeSeen.delete(hashedId);
                if (typeof stepState.input === "undefined") isFulfilled = true;
            }
            let extraOpts;
            let fnArgs = [
                ...args
            ];
            if (typeof stepState?.input !== "undefined" && Array.isArray(stepState.input)) switch(opId.op){
                case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["StepOpCode"].StepPlanned:
                    fnArgs = [
                        ...args.slice(0, 2),
                        ...stepState.input
                    ];
                    extraOpts = {
                        input: [
                            ...stepState.input
                        ]
                    };
                    break;
                case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["StepOpCode"].AiGateway:
                    extraOpts = {
                        body: {
                            ...typeof opId.opts?.body === "object" ? {
                                ...opId.opts.body
                            } : {},
                            ...stepState.input[0]
                        }
                    };
                    break;
            }
            const step = {
                ...opId,
                opts: {
                    ...opId.opts,
                    ...extraOpts
                },
                rawArgs: fnArgs,
                hashedId,
                input: stepState?.input,
                fn: opts?.fn ? ()=>opts.fn?.(...fnArgs) : void 0,
                promise,
                fulfilled: isFulfilled,
                hasStepState: Boolean(stepState),
                displayName: opId.displayName ?? opId.id,
                handled: false,
                handle: ()=>{
                    if (step.handled) return false;
                    step.handled = true;
                    if (isFulfilled && stepState) {
                        stepState.fulfilled = true;
                        Promise.all([
                            stepState.data,
                            stepState.error,
                            stepState.input
                        ]).then(()=>{
                            if (typeof stepState.data !== "undefined") resolve(stepState.data);
                            else {
                                this.state.recentlyRejectedStepError = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$components$2f$StepError$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["StepError"](opId.id, stepState.error);
                                reject(this.state.recentlyRejectedStepError);
                            }
                        });
                    }
                    return true;
                }
            };
            this.state.steps.set(opId.id, step);
            this.state.hasSteps = true;
            pushStepToReport(step);
            /**
			* If this is the last piece of state we had, we've now finished
			* memoizing.
			*/ if (!beforeExecHooksPromise && this.state.allStateUsed()) await (beforeExecHooksPromise = (async ()=>{
                await this.state.hooks?.afterMemoization?.();
                await this.state.hooks?.beforeExecution?.();
            })());
            return promise;
        };
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$components$2f$InngestStepTools$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createStepTools"])(this.options.client, this, stepHandler);
    }
    getUserFnToRun() {
        if (!this.options.isFailureHandler) return this.options.fn["fn"];
        if (!this.options.fn["onFailureFn"]) /**
		* Somehow, we've ended up detecting that this is a failure handler but
		* doesn't have an `onFailure` function. This should never happen.
		*/ throw new Error("Cannot find function `onFailure` handler");
        return this.options.fn["onFailureFn"];
    }
    initializeTimer(state) {
        if (!this.options.requestedRunStep) return;
        this.timeout = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$promises$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createTimeoutPromise"])(this.timeoutDuration);
        this.timeout.then(async ()=>{
            await this.state.hooks?.afterMemoization?.();
            await this.state.hooks?.beforeExecution?.();
            await this.state.hooks?.afterExecution?.();
            state.setCheckpoint({
                type: "step-not-found",
                step: {
                    id: this.options.requestedRunStep,
                    op: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["StepOpCode"].StepNotFound
                }
            });
        });
    }
    async initializeMiddleware() {
        const ctx = this.options.data;
        return await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$components$2f$InngestMiddleware$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getHookStack"])(this.options.fn["middleware"], "onFunctionRun", {
            ctx,
            fn: this.options.fn,
            steps: Object.values(this.options.stepState),
            reqArgs: this.options.reqArgs
        }, {
            transformInput: (prev, output)=>{
                return {
                    ctx: {
                        ...prev.ctx,
                        ...output?.ctx
                    },
                    fn: this.options.fn,
                    steps: prev.steps.map((step, i)=>({
                            ...step,
                            ...output?.steps?.[i]
                        })),
                    reqArgs: prev.reqArgs
                };
            },
            transformOutput: (prev, output)=>{
                return {
                    result: {
                        ...prev.result,
                        ...output?.result
                    },
                    step: prev.step
                };
            }
        });
    }
};
const hashId = (id)=>{
    return sha1().update(id).digest("hex");
};
const hashOp = (op)=>{
    return {
        ...op,
        id: hashId(op.id)
    };
};
/**
* Exported for testing.
*/ const _internals = {
    hashOp,
    hashId
};
;
 //# sourceMappingURL=v2.js.map
}),
"[project]/node_modules/inngest/components/InngestFunction.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "InngestFunction",
    ()=>InngestFunction
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/inngest/helpers/consts.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$strings$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/inngest/helpers/strings.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$components$2f$execution$2f$v0$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/inngest/components/execution/v0.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$components$2f$execution$2f$v1$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/inngest/components/execution/v1.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$components$2f$execution$2f$v2$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/inngest/components/execution/v2.js [app-route] (ecmascript)");
;
;
;
;
;
//#region src/components/InngestFunction.ts
/**
* A stateless Inngest function, wrapping up function configuration and any
* in-memory steps to run when triggered.
*
* This function can be "registered" to create a handler that Inngest can
* trigger remotely.
*
* @public
*/ var InngestFunction = class InngestFunction {
    static stepId = "step";
    static failureSuffix = "-failure";
    get [Symbol.toStringTag]() {
        return InngestFunction.Tag;
    }
    opts;
    fn;
    onFailureFn;
    client;
    middleware;
    /**
	* A stateless Inngest function, wrapping up function configuration and any
	* in-memory steps to run when triggered.
	*
	* This function can be "registered" to create a handler that Inngest can
	* trigger remotely.
	*/ constructor(client, opts, fn){
        this.client = client;
        this.opts = opts;
        this.fn = fn;
        this.onFailureFn = this.opts.onFailure;
        this.middleware = this.client["initializeMiddleware"](this.opts.middleware, {
            registerInput: {
                fn: this
            },
            prefixStack: this.client["middleware"]
        });
    }
    /**
	* The generated or given ID for this function.
	*/ id(prefix) {
        return [
            prefix,
            this.opts.id
        ].filter(Boolean).join("-");
    }
    /**
	* The generated or given ID for this function, prefixed with the app ID. This
	* is used for routing invokes and identifying the function across apps.
	*/ get absoluteId() {
        return this.id(this.client.id);
    }
    /**
	* The name of this function as it will appear in the Inngest Cloud UI.
	*/ get name() {
        return this.opts.name || this.id();
    }
    /**
	* The description of this function.
	*/ get description() {
        return this.opts.description;
    }
    /**
	* Retrieve the Inngest config for this function.
	*/ getConfig({ baseUrl, appPrefix, isConnect }) {
        const fnId = this.id(appPrefix);
        const stepUrl = new URL(baseUrl.href);
        stepUrl.searchParams.set(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["queryKeys"].FnId, fnId);
        stepUrl.searchParams.set(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["queryKeys"].StepId, InngestFunction.stepId);
        const { retries: attempts, cancelOn, idempotency, batchEvents, rateLimit, throttle, concurrency, debounce, timeouts, priority, singleton } = this.opts;
        /**
		* Convert retries into the format required when defining function
		* configuration.
		*/ const retries = typeof attempts === "undefined" ? void 0 : {
            attempts
        };
        const fn = {
            id: fnId,
            name: this.name,
            triggers: (this.opts.triggers ?? []).map((trigger)=>{
                if ("event" in trigger) return {
                    event: trigger.event,
                    expression: trigger.if
                };
                return {
                    cron: trigger.cron
                };
            }),
            steps: {
                [InngestFunction.stepId]: {
                    id: InngestFunction.stepId,
                    name: InngestFunction.stepId,
                    runtime: {
                        type: isConnect ? "ws" : "http",
                        url: stepUrl.href
                    },
                    retries
                }
            },
            idempotency,
            batchEvents,
            rateLimit,
            throttle,
            concurrency,
            debounce,
            priority,
            timeouts,
            singleton
        };
        if (cancelOn) fn.cancel = cancelOn.map(({ event, timeout, if: ifStr, match })=>{
            const ret = {
                event
            };
            if (timeout) ret.timeout = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$strings$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["timeStr"])(timeout);
            if (match) ret.if = `event.${match} == async.${match}`;
            else if (ifStr) ret.if = ifStr;
            return ret;
        }, []);
        const config = [
            fn
        ];
        if (this.onFailureFn) {
            const id = `${fn.id}${InngestFunction.failureSuffix}`;
            const name = `${fn.name ?? fn.id} (failure)`;
            const failureStepUrl = new URL(stepUrl.href);
            failureStepUrl.searchParams.set(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["queryKeys"].FnId, id);
            config.push({
                id,
                name,
                triggers: [
                    {
                        event: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["internalEvents"].FunctionFailed,
                        expression: `event.data.function_id == '${fnId}'`
                    }
                ],
                steps: {
                    [InngestFunction.stepId]: {
                        id: InngestFunction.stepId,
                        name: InngestFunction.stepId,
                        runtime: {
                            type: "http",
                            url: failureStepUrl.href
                        },
                        retries: {
                            attempts: 1
                        }
                    }
                }
            });
        }
        return config;
    }
    createExecution(opts) {
        const options = {
            fn: this,
            ...opts.partialOptions
        };
        return ({
            [__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ExecutionVersion"].V2]: ()=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$components$2f$execution$2f$v2$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createV2InngestExecution"])(options),
            [__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ExecutionVersion"].V1]: ()=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$components$2f$execution$2f$v1$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createV1InngestExecution"])(options),
            [__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ExecutionVersion"].V0]: ()=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$components$2f$execution$2f$v0$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createV0InngestExecution"])(options)
        })[opts.version]();
    }
    shouldOptimizeParallelism() {
        return this.opts.optimizeParallelism ?? this.client["options"].optimizeParallelism ?? false;
    }
};
(function(_InngestFunction) {
    _InngestFunction.Tag = "Inngest.Function";
})(InngestFunction || (InngestFunction = {}));
;
 //# sourceMappingURL=InngestFunction.js.map
}),
"[project]/node_modules/inngest/api/api.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "InngestApi",
    ()=>InngestApi
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/inngest/helpers/consts.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$strings$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/inngest/helpers/strings.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$devserver$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/inngest/helpers/devserver.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$errors$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/inngest/helpers/errors.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/inngest/types.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$api$2f$schema$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/inngest/api/schema.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$net$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/inngest/helpers/net.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/zod/v3/index.js [app-route] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__ = __turbopack_context__.i("[project]/node_modules/zod/v3/external.js [app-route] (ecmascript) <export * as z>");
;
;
;
;
;
;
;
;
//#region src/api/api.ts
const realtimeSubscriptionTokenSchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
    jwt: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string()
});
const sendSignalSuccessResponseSchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
    data: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
        run_id: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().min(1)
    })
});
var InngestApi = class {
    apiBaseUrl;
    signingKey;
    signingKeyFallback;
    fetch;
    mode;
    constructor({ baseUrl, signingKey, signingKeyFallback, fetch, mode }){
        this.apiBaseUrl = baseUrl;
        this.signingKey = signingKey;
        this.signingKeyFallback = signingKeyFallback;
        this.fetch = fetch;
        this.mode = mode;
    }
    get hashedKey() {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$strings$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["hashSigningKey"])(this.signingKey);
    }
    get hashedFallbackKey() {
        if (!this.signingKeyFallback) return;
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$strings$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["hashSigningKey"])(this.signingKeyFallback);
    }
    setSigningKey(key) {
        if (typeof key === "string" && this.signingKey === "") this.signingKey = key;
    }
    setSigningKeyFallback(key) {
        if (typeof key === "string" && !this.signingKeyFallback) this.signingKeyFallback = key;
    }
    async getTargetUrl(path) {
        if (this.apiBaseUrl) return new URL(path, this.apiBaseUrl);
        let url = new URL(path, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["defaultInngestApiBaseUrl"]);
        if (this.mode.isDev && this.mode.isInferred && !this.apiBaseUrl) {
            if (await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$devserver$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["devServerAvailable"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["defaultDevServerHost"], this.fetch)) url = new URL(path, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["defaultDevServerHost"]);
        }
        return url;
    }
    async getRunSteps(runId, version) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$net$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["fetchWithAuthFallback"])({
            authToken: this.hashedKey,
            authTokenFallback: this.hashedFallbackKey,
            fetch: this.fetch,
            url: await this.getTargetUrl(`/v0/runs/${runId}/actions`)
        }).then(async (resp)=>{
            const data = await resp.json();
            if (resp.ok) return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ok"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$api$2f$schema$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["stepsSchemas"][version].parse(data));
            else return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["err"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$api$2f$schema$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["errorSchema"].parse(data));
        }).catch((error)=>{
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["err"])({
                error: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$errors$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getErrorMessage"])(error, "Unknown error retrieving step data"),
                status: 500
            });
        });
    }
    async getRunBatch(runId) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$net$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["fetchWithAuthFallback"])({
            authToken: this.hashedKey,
            authTokenFallback: this.hashedFallbackKey,
            fetch: this.fetch,
            url: await this.getTargetUrl(`/v0/runs/${runId}/batch`)
        }).then(async (resp)=>{
            const data = await resp.json();
            if (resp.ok) return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ok"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$api$2f$schema$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["batchSchema"].parse(data));
            else return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["err"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$api$2f$schema$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["errorSchema"].parse(data));
        }).catch((error)=>{
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["err"])({
                error: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$errors$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getErrorMessage"])(error, "Unknown error retrieving event batch"),
                status: 500
            });
        });
    }
    async publish(publishOptions, data) {
        const isStream = data instanceof ReadableStream;
        const url = await this.getTargetUrl("/v1/realtime/publish");
        url.searchParams.set("channel", publishOptions.channel || "");
        if (publishOptions.runId) url.searchParams.set("run_id", publishOptions.runId);
        publishOptions.topics.forEach((topic)=>{
            url.searchParams.append("topic", topic);
        });
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$net$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["fetchWithAuthFallback"])({
            authToken: this.hashedKey,
            authTokenFallback: this.hashedFallbackKey,
            fetch: this.fetch,
            url,
            options: {
                method: "POST",
                body: isStream ? data : typeof data === "string" ? data : JSON.stringify(data),
                headers: {
                    "Content-Type": isStream ? "text/stream" : "application/json"
                },
                ...isStream ? {
                    duplex: "half"
                } : {}
            }
        }).then((res)=>{
            if (!res.ok) throw new Error(`Failed to publish event: ${res.status} ${res.statusText}`);
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ok"])(void 0);
        }).catch((error)=>{
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["err"])({
                error: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$errors$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getErrorMessage"])(error, "Unknown error publishing event"),
                status: 500
            });
        });
    }
    async sendSignal(signalOptions, options) {
        const url = await this.getTargetUrl("/v1/signals");
        const body = {
            signal: signalOptions.signal,
            data: signalOptions.data
        };
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$net$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["fetchWithAuthFallback"])({
            authToken: this.hashedKey,
            authTokenFallback: this.hashedFallbackKey,
            fetch: this.fetch,
            url,
            options: {
                method: "POST",
                body: JSON.stringify(body),
                headers: {
                    "Content-Type": "application/json",
                    ...options?.headers
                }
            }
        }).then(async (res)=>{
            if (res.status === 404) return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ok"])({
                runId: void 0
            });
            const resClone = res.clone();
            let json;
            try {
                json = await res.json();
            } catch  {
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["err"])({
                    error: `Failed to send signal: ${res.status} ${res.statusText} - ${await resClone.text()}`,
                    status: res.status
                });
            }
            if (!res.ok) try {
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["err"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$api$2f$schema$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["errorSchema"].parse(json));
            } catch  {
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["err"])({
                    error: `Failed to send signal: ${res.status} ${res.statusText} - ${await res.text()}`,
                    status: res.status
                });
            }
            const parseRes = sendSignalSuccessResponseSchema.safeParse(json);
            if (!parseRes.success) return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["err"])({
                error: `Successfully sent signal, but response parsing failed: ${res.status} ${res.statusText} - ${await resClone.text()}`,
                status: res.status
            });
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ok"])({
                runId: parseRes.data.data.run_id
            });
        }).catch((error)=>{
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["err"])({
                error: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$errors$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getErrorMessage"])(error, "Unknown error sending signal"),
                status: 500
            });
        });
    }
    async getSubscriptionToken(channel, topics) {
        const url = await this.getTargetUrl("/v1/realtime/token");
        const body = topics.map((topic)=>({
                channel,
                name: topic,
                kind: "run"
            }));
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$net$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["fetchWithAuthFallback"])({
            authToken: this.hashedKey,
            authTokenFallback: this.hashedFallbackKey,
            fetch: this.fetch,
            url,
            options: {
                method: "POST",
                body: JSON.stringify(body),
                headers: {
                    "Content-Type": "application/json"
                }
            }
        }).then(async (res)=>{
            if (!res.ok) throw new Error(`Failed to get subscription token: ${res.status} ${res.statusText} - ${await res.text()}`);
            return realtimeSubscriptionTokenSchema.parse(await res.json()).jwt;
        }).catch((error)=>{
            throw new Error((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$errors$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getErrorMessage"])(error, "Unknown error getting subscription token"));
        });
    }
};
;
 //# sourceMappingURL=api.js.map
}),
"[project]/node_modules/inngest/helpers/crypto.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

//#region src/helpers/crypto.ts
/**
* Create a cryptographically secure random value.
*
* @throws {Error} If the crypto module is not available.
*/ __turbopack_context__.s([
    "createEntropy",
    ()=>createEntropy
]);
function createEntropy(byteLength) {
    const bytes = new Uint8Array(byteLength);
    const { crypto } = globalThis;
    if (!crypto) throw new Error("missing crypto module");
    if (!crypto.getRandomValues) throw new Error("missing crypto.getRandomValues");
    crypto.getRandomValues(bytes);
    return bytes;
}
;
 //# sourceMappingURL=crypto.js.map
}),
"[project]/node_modules/inngest/middleware/logger.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

//#region src/middleware/logger.ts
__turbopack_context__.s([
    "DefaultLogger",
    ()=>DefaultLogger,
    "ProxyLogger",
    ()=>ProxyLogger
]);
var DefaultLogger = class {
    info(...args) {
        console.info(...args);
    }
    warn(...args) {
        console.warn(...args);
    }
    error(...args) {
        console.error(...args);
    }
    debug(...args) {
        console.debug(...args);
    }
};
/**
* ProxyLogger aims to provide a thin wrapper on user's provided logger.
* It's expected to be turned on and off based on the function execution
* context, so it doesn't result in duplicated logging.
*
* And also attempt to allow enough time for the logger to flush all logs.
*
* @public
*/ var ProxyLogger = class {
    logger;
    enabled = false;
    constructor(logger){
        this.logger = logger;
        return new Proxy(this, {
            get (target, prop, receiver) {
                if (prop in target) return Reflect.get(target, prop, receiver);
                return Reflect.get(target.logger, prop, receiver);
            }
        });
    }
    info(...args) {
        if (!this.enabled) return;
        this.logger.info(...args);
    }
    warn(...args) {
        if (!this.enabled) return;
        this.logger.warn(...args);
    }
    error(...args) {
        if (!this.enabled) return;
        this.logger.error(...args);
    }
    debug(...args) {
        if (!this.enabled || !(typeof this.logger.debug === "function")) return;
        this.logger.debug(...args);
    }
    enable() {
        this.enabled = true;
    }
    disable() {
        this.enabled = false;
    }
    async flush() {
        if (this.logger.constructor.name !== DefaultLogger.name) await new Promise((resolve)=>{
            setTimeout(()=>resolve(null), 1e3);
        });
    }
};
;
 //# sourceMappingURL=logger.js.map
}),
"[project]/node_modules/inngest/components/Inngest.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Inngest",
    ()=>Inngest
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/inngest/helpers/consts.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$strings$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/inngest/helpers/strings.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$env$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/inngest/helpers/env.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$devserver$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/inngest/helpers/devserver.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$errors$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/inngest/helpers/errors.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/inngest/types.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$promises$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/inngest/helpers/promises.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$components$2f$InngestMiddleware$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/inngest/components/InngestMiddleware.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$components$2f$InngestFunction$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/inngest/components/InngestFunction.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$api$2f$api$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/inngest/api/api.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$crypto$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/inngest/helpers/crypto.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$middleware$2f$logger$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/inngest/middleware/logger.js [app-route] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
;
;
//#region src/components/Inngest.ts
/**
* A client used to interact with the Inngest API by sending or reacting to
* events.
*
* To provide event typing, see {@link EventSchemas}.
*
* ```ts
* const inngest = new Inngest({ id: "my-app" });
*
* // or to provide event typing too
* const inngest = new Inngest({
*   id: "my-app",
*   schemas: new EventSchemas().fromRecord<{
*     "app/user.created": {
*       data: { userId: string };
*     };
*   }>(),
* });
* ```
*
* @public
*/ var Inngest = class Inngest {
    get [Symbol.toStringTag]() {
        return Inngest.Tag;
    }
    /**
	* The ID of this instance, most commonly a reference to the application it
	* resides in.
	*
	* The ID of your client should remain the same for its lifetime; if you'd
	* like to change the name of your client as it appears in the Inngest UI,
	* change the `name` property instead.
	*/ id;
    /**
	* Stores the options so we can remember explicit settings the user has
	* provided.
	*/ options;
    /**
	* Inngest event key, used to send events to Inngest Cloud.
	*/ eventKey = "";
    _apiBaseUrl;
    _eventBaseUrl;
    inngestApi;
    /**
	* The absolute URL of the Inngest Cloud API.
	*/ sendEventUrl = new URL(`e/${this.eventKey}`, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["defaultInngestEventBaseUrl"]);
    headers;
    fetch;
    logger;
    localFns = [];
    /**
	* A promise that resolves when the middleware stack has been initialized and
	* the client is ready to be used.
	*/ middleware;
    /**
	* Whether the client is running in a production environment. This can
	* sometimes be `undefined` if the client has expressed no preference or
	* perhaps environment variables are only available at a later stage in the
	* runtime, for example when receiving a request.
	*
	* An {@link InngestCommHandler} should prioritize this value over all other
	* settings, but should still check for the presence of an environment
	* variable if it is not set.
	*/ _mode;
    schemas;
    _appVersion;
    get apiBaseUrl() {
        return this._apiBaseUrl;
    }
    get eventBaseUrl() {
        return this._eventBaseUrl;
    }
    get env() {
        return this.headers[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["headerKeys"].Environment] ?? null;
    }
    get appVersion() {
        return this._appVersion;
    }
    /**
	* A client used to interact with the Inngest API by sending or reacting to
	* events.
	*
	* To provide event typing, see {@link EventSchemas}.
	*
	* ```ts
	* const inngest = new Inngest({ name: "My App" });
	*
	* // or to provide event typing too
	* const inngest = new Inngest({
	*   name: "My App",
	*   schemas: new EventSchemas().fromRecord<{
	*     "app/user.created": {
	*       data: { userId: string };
	*     };
	*   }>(),
	* });
	* ```
	*/ constructor(options){
        this.options = options;
        const { id, fetch, logger = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$middleware$2f$logger$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["DefaultLogger"](), middleware, isDev, schemas, appVersion } = this.options;
        if (!id) throw new Error("An `id` must be passed to create an Inngest instance.");
        this.id = id;
        this._mode = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$env$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getMode"])({
            explicitMode: typeof isDev === "boolean" ? isDev ? "dev" : "cloud" : void 0
        });
        this.fetch = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$env$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getFetch"])(fetch);
        this.inngestApi = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$api$2f$api$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["InngestApi"]({
            baseUrl: this.apiBaseUrl,
            signingKey: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$env$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["processEnv"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["envKeys"].InngestSigningKey) || "",
            signingKeyFallback: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$env$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["processEnv"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["envKeys"].InngestSigningKeyFallback),
            fetch: this.fetch,
            mode: this.mode
        });
        this.schemas = schemas;
        this.loadModeEnvVars();
        this.logger = logger;
        this.middleware = this.initializeMiddleware([
            ...builtInMiddleware,
            ...middleware || []
        ]);
        this._appVersion = appVersion;
    }
    /**
	* Returns a `Promise` that resolves when the app is ready and all middleware
	* has been initialized.
	*/ get ready() {
        return this.middleware.then(()=>{});
    }
    /**
	* Set the environment variables for this client. This is useful if you are
	* passed environment variables at runtime instead of as globals and need to
	* update the client with those values as requests come in.
	*/ setEnvVars(env = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$env$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["allProcessEnv"])()) {
        this.mode = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$env$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getMode"])({
            env,
            client: this
        });
        return this;
    }
    loadModeEnvVars() {
        this._apiBaseUrl = this.options.baseUrl || this.mode["env"][__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["envKeys"].InngestApiBaseUrl] || this.mode["env"][__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["envKeys"].InngestBaseUrl] || this.mode.getExplicitUrl(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["defaultInngestApiBaseUrl"]);
        this._eventBaseUrl = this.options.baseUrl || this.mode["env"][__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["envKeys"].InngestEventApiBaseUrl] || this.mode["env"][__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["envKeys"].InngestBaseUrl] || this.mode.getExplicitUrl(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["defaultInngestEventBaseUrl"]);
        this.setEventKey(this.options.eventKey || this.mode["env"][__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["envKeys"].InngestEventKey] || "");
        this.headers = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$env$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["inngestHeaders"])({
            inngestEnv: this.options.env,
            env: this.mode["env"]
        });
        this.inngestApi["mode"] = this.mode;
        this.inngestApi["apiBaseUrl"] = this._apiBaseUrl;
    }
    /**
	* Initialize all passed middleware, running the `register` function on each
	* in sequence and returning the requested hook registrations.
	*/ async initializeMiddleware(middleware = [], opts) {
        /**
		* Wait for the prefix stack to run first; do not trigger ours before this
		* is complete.
		*/ const prefix = await (opts?.prefixStack ?? []);
        const stack = middleware.reduce(async (acc, m)=>{
            const prev = await acc;
            const next = await m.init({
                client: this,
                ...opts?.registerInput
            });
            return [
                ...prev,
                next
            ];
        }, Promise.resolve([]));
        return [
            ...prefix,
            ...await stack
        ];
    }
    get mode() {
        return this._mode;
    }
    set mode(m) {
        this._mode = m;
        this.loadModeEnvVars();
    }
    /**
	* Given a response from Inngest, relay the error to the caller.
	*/ async getResponseError(response, rawBody, foundErr = "Unknown error") {
        let errorMessage = foundErr;
        if (errorMessage === "Unknown error") switch(response.status){
            case 401:
                errorMessage = "Event key Not Found";
                break;
            case 400:
                errorMessage = "Cannot process event payload";
                break;
            case 403:
                errorMessage = "Forbidden";
                break;
            case 404:
                errorMessage = "Event key not found";
                break;
            case 406:
                errorMessage = `${JSON.stringify(await rawBody)}`;
                break;
            case 409:
            case 412:
                errorMessage = "Event transformation failed";
                break;
            case 413:
                errorMessage = "Event payload too large";
                break;
            case 500:
                errorMessage = "Internal server error";
                break;
            default:
                try {
                    errorMessage = await response.text();
                } catch (_err) {
                    errorMessage = `${JSON.stringify(await rawBody)}`;
                }
                break;
        }
        return /* @__PURE__ */ new Error(`Inngest API Error: ${response.status} ${errorMessage}`);
    }
    /**
	* Set the event key for this instance of Inngest. This is useful if for some
	* reason the key is not available at time of instantiation or present in the
	* `INNGEST_EVENT_KEY` environment variable.
	*/ setEventKey(eventKey) {
        this.eventKey = eventKey || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["dummyEventKey"];
        this.sendEventUrl = new URL(`e/${this.eventKey}`, this.eventBaseUrl || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["defaultInngestEventBaseUrl"]);
    }
    eventKeySet() {
        return Boolean(this.eventKey) && this.eventKey !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["dummyEventKey"];
    }
    /**
	* EXPERIMENTAL: This API is not yet stable and may change in the future
	* without a major version bump.
	*
	* Send a Signal to Inngest.
	*/ async sendSignal({ signal, data, env }) {
        const headers = {
            ...env ? {
                [__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["headerKeys"].Environment]: env
            } : {}
        };
        return this._sendSignal({
            signal,
            data,
            headers
        });
    }
    async _sendSignal({ signal, data, headers }) {
        const res = await this.inngestApi.sendSignal({
            signal,
            data
        }, {
            ...this.headers,
            ...headers
        });
        if (res.ok) return res.value;
        throw new Error(`Failed to send signal: ${res.error?.error || "Unknown error"}`);
    }
    /**
	* Send one or many events to Inngest. Takes an entire payload (including
	* name) as each input.
	*
	* ```ts
	* await inngest.send({ name: "app/user.created", data: { id: 123 } });
	* ```
	*
	* Returns a promise that will resolve if the event(s) were sent successfully,
	* else throws with an error explaining what went wrong.
	*
	* If you wish to send an event with custom types (i.e. one that hasn't been
	* generated), make sure to add it when creating your Inngest instance, like
	* so:
	*
	* ```ts
	* const inngest = new Inngest({
	*   name: "My App",
	*   schemas: new EventSchemas().fromRecord<{
	*     "my/event": {
	*       name: "my/event";
	*       data: { bar: string };
	*     };
	*   }>(),
	* });
	* ```
	*/ async send(payload, options) {
        const headers = {
            ...options?.env ? {
                [__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["headerKeys"].Environment]: options.env
            } : {}
        };
        return this._send({
            payload,
            headers
        });
    }
    /**
	* Internal method for sending an event, used to allow Inngest internals to
	* further customize the request sent to an Inngest Server.
	*/ async _send({ payload, headers }) {
        const nowMillis = /* @__PURE__ */ new Date().getTime();
        let maxAttempts = 5;
        try {
            const entropy = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$crypto$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createEntropy"])(10);
            const entropyBase64 = Buffer.from(entropy).toString("base64");
            headers = {
                ...headers,
                [__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["headerKeys"].EventIdSeed]: `${nowMillis},${entropyBase64}`
            };
        } catch (err) {
            let message = "Event-sending retries disabled";
            if (err instanceof Error) message += `: ${err.message}`;
            console.debug(message);
            maxAttempts = 1;
        }
        const hooks = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$components$2f$InngestMiddleware$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getHookStack"])(this.middleware, "onSendEvent", void 0, {
            transformInput: (prev, output)=>{
                return {
                    ...prev,
                    ...output
                };
            },
            transformOutput (prev, output) {
                return {
                    result: {
                        ...prev.result,
                        ...output?.result
                    }
                };
            }
        });
        let payloads = Array.isArray(payload) ? payload : payload ? [
            payload
        ] : [];
        const inputChanges = await hooks.transformInput?.({
            payloads: [
                ...payloads
            ]
        });
        if (inputChanges?.payloads) payloads = [
            ...inputChanges.payloads
        ];
        payloads = payloads.map((p)=>{
            return {
                ...p,
                id: p.id,
                ts: p.ts || nowMillis,
                data: p.data || {}
            };
        });
        const applyHookToOutput = async (arg)=>{
            const hookOutput = await hooks.transformOutput?.(arg);
            return {
                ...arg.result,
                ...hookOutput?.result
            };
        };
        /**
		* It can be valid for a user to send an empty list of events; if this
		* happens, show a warning that this may not be intended, but don't throw.
		*/ if (!payloads.length) {
            console.warn((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$errors$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["prettyError"])({
                type: "warn",
                whatHappened: "`inngest.send()` called with no events",
                reassurance: "This is not an error, but you may not have intended to do this.",
                consequences: "The returned promise will resolve, but no events have been sent to Inngest.",
                stack: true
            }));
            return await applyHookToOutput({
                result: {
                    ids: []
                }
            });
        }
        let url = this.sendEventUrl.href;
        /**
		* If in prod mode and key is not present, fail now.
		*/ if (this.mode.isCloud && !this.eventKeySet()) throw new Error((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$errors$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["prettyError"])({
            whatHappened: "Failed to send event",
            consequences: "Your event or events were not sent to Inngest.",
            why: "We couldn't find an event key to use to send events to Inngest.",
            toFixNow: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$errors$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["fixEventKeyMissingSteps"]
        }));
        /**
		* If dev mode has been inferred, try to hit the dev server first to see if
		* it exists. If it does, use it, otherwise fall back to whatever server we
		* have configured.
		*
		* `INNGEST_BASE_URL` is used to set both dev server and prod URLs, so if a
		* user has set this it means they have already chosen a URL to hit.
		*/ if (this.mode.isDev && this.mode.isInferred && !this.eventBaseUrl) {
            if (await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$devserver$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["devServerAvailable"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["defaultDevServerHost"], this.fetch)) url = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$devserver$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["devServerUrl"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["defaultDevServerHost"], `e/${this.eventKey}`).href;
        }
        const body = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$promises$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["retryWithBackoff"])(async ()=>{
            let rawBody;
            let body$1;
            const response = await this.fetch(url, {
                method: "POST",
                body: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$strings$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["stringify"])(payloads),
                headers: {
                    ...this.headers,
                    ...headers
                }
            });
            try {
                rawBody = await response.json();
                body$1 = await __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["sendEventResponseSchema"].parseAsync(rawBody);
            } catch (_err) {
                throw await this.getResponseError(response, rawBody);
            }
            if (body$1.status !== 200 || body$1.error) throw await this.getResponseError(response, rawBody, body$1.error);
            return body$1;
        }, {
            maxAttempts,
            baseDelay: 100
        });
        return await applyHookToOutput({
            result: {
                ids: body.ids
            }
        });
    }
    createFunction = (rawOptions, rawTrigger, handler)=>{
        const fn = this._createFunction(rawOptions, rawTrigger, handler);
        this.localFns.push(fn);
        return fn;
    };
    get funcs() {
        return this.localFns;
    }
    _createFunction = (rawOptions, rawTrigger, handler)=>{
        const options = this.sanitizeOptions(rawOptions);
        const triggers = this.sanitizeTriggers(rawTrigger);
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$components$2f$InngestFunction$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["InngestFunction"](this, {
            ...options,
            triggers
        }, handler);
    };
    /**
	* Runtime-only validation.
	*/ sanitizeOptions(options) {
        if (Object.hasOwn(options, "fns")) console.warn(`${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["logPrefix"]} InngestFunction: \`fns\` option has been deprecated in v3; use \`middleware\` instead. See https://www.inngest.com/docs/sdk/migration`);
        if (typeof options === "string") {
            console.warn(`${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["logPrefix"]} InngestFunction: Creating a function with a string as the first argument has been deprecated in v3; pass an object instead. See https://www.inngest.com/docs/sdk/migration`);
            return {
                id: options
            };
        }
        return options;
    }
    /**
	* Runtime-only validation.
	*/ sanitizeTriggers(triggers) {
        if (typeof triggers === "string") {
            console.warn(`${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$helpers$2f$consts$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["logPrefix"]} InngestFunction: Creating a function with a string as the second argument has been deprecated in v3; pass an object instead. See https://www.inngest.com/docs/sdk/migration`);
            return [
                {
                    event: triggers
                }
            ];
        }
        if (!Array.isArray(triggers)) return [
            triggers
        ];
        return triggers;
    }
};
/**
* Default middleware that is included in every client, placed after the user's
* middleware on the client but before function-level middleware.
*
* It is defined here to ensure that comments are included in the generated TS
* definitions. Without this, we infer the stack of built-in middleware without
* comments, losing a lot of value.
*
* If this is moved, please ensure that using this package in another project
* can correctly access comments on mutated input and output.
*
* This return pattern mimics the output of a `satisfies` suffix; it's used as
* we support versions of TypeScript prior to the introduction of `satisfies`.
*/ const builtInMiddleware = ((m)=>m)([
    new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$components$2f$InngestMiddleware$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["InngestMiddleware"]({
        name: "Inngest: Logger",
        init ({ client }) {
            return {
                onFunctionRun (arg) {
                    const { ctx } = arg;
                    const metadata = {
                        runID: ctx.runId,
                        eventName: ctx.event.name,
                        functionName: arg.fn.name
                    };
                    let providedLogger = client["logger"];
                    try {
                        if ("child" in providedLogger) providedLogger = providedLogger.child(metadata);
                    } catch (err) {
                        console.error("failed to create \"childLogger\" with error: ", err);
                    }
                    const logger = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inngest$2f$middleware$2f$logger$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ProxyLogger"](providedLogger);
                    return {
                        transformInput () {
                            return {
                                ctx: {
                                    logger
                                }
                            };
                        },
                        beforeExecution () {
                            logger.enable();
                        },
                        transformOutput ({ result: { error } }) {
                            if (error) logger.error(error);
                        },
                        async beforeResponse () {
                            await logger.flush();
                        }
                    };
                }
            };
        }
    })
]);
(function(_Inngest) {
    _Inngest.Tag = "Inngest.App";
})(Inngest || (Inngest = {}));
;
 //# sourceMappingURL=Inngest.js.map
}),
];

//# sourceMappingURL=node_modules_inngest_311cc06a._.js.map