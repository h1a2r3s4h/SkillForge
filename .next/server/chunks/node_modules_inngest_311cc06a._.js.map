{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///Users/harshitgangwar/Desktop/SkillForge/node_modules/inngest/_virtual/rolldown_runtime.js"],"sourcesContent":["import { createRequire } from \"node:module\";\n\n//#region rolldown:runtime\nvar __defProp = Object.defineProperty;\nvar __export = (all) => {\n\tlet target = {};\n\tfor (var name in all) __defProp(target, name, {\n\t\tget: all[name],\n\t\tenumerable: true\n\t});\n\treturn target;\n};\nvar __require = /* @__PURE__ */ createRequire(import.meta.url);\n\n//#endregion\nexport { __export, __require };"],"names":[],"mappings":";;;;;;AAAA;;;;;;;AAEA,0BAA0B;AAC1B,IAAI,YAAY,OAAO,cAAc;AACrC,IAAI,WAAW,CAAC;IACf,IAAI,SAAS,CAAC;IACd,IAAK,IAAI,QAAQ,IAAK,UAAU,QAAQ,MAAM;QAC7C,KAAK,GAAG,CAAC,KAAK;QACd,YAAY;IACb;IACA,OAAO;AACR;AACA,IAAI,YAAY,aAAa,GAAG,IAAA,sIAAa,EAAC,8BAAY,GAAG","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 33, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/inngest/helpers/consts.js","sources":["file:///Users/harshitgangwar/Desktop/SkillForge/node_modules/src/helpers/consts.ts"],"sourcesContent":["import chalk from \"chalk\";\n\n/**\n * Keys for accessing query parameters included in requests from Inngest to run\n * functions.\n *\n * Used internally to create handlers using `InngestCommHandler`, but can be\n * imported to be used if creating a custom handler outside of the package.\n *\n * @public\n */\nexport enum queryKeys {\n  DeployId = \"deployId\",\n  FnId = \"fnId\",\n  Probe = \"probe\",\n  StepId = \"stepId\",\n}\n\nexport enum probe {\n  Trust = \"trust\",\n}\n\nexport enum envKeys {\n  InngestSigningKey = \"INNGEST_SIGNING_KEY\",\n  InngestSigningKeyFallback = \"INNGEST_SIGNING_KEY_FALLBACK\",\n  InngestEventKey = \"INNGEST_EVENT_KEY\",\n\n  /**\n   * @deprecated Removed in v3. Use {@link InngestBaseUrl} instead.\n   */\n  InngestDevServerUrl = \"INNGEST_DEVSERVER_URL\",\n  InngestEnvironment = \"INNGEST_ENV\",\n  InngestBaseUrl = \"INNGEST_BASE_URL\",\n  InngestEventApiBaseUrl = \"INNGEST_EVENT_API_BASE_URL\",\n  InngestApiBaseUrl = \"INNGEST_API_BASE_URL\",\n  InngestServeHost = \"INNGEST_SERVE_HOST\",\n  InngestServePath = \"INNGEST_SERVE_PATH\",\n  InngestLogLevel = \"INNGEST_LOG_LEVEL\",\n  InngestStreaming = \"INNGEST_STREAMING\",\n  InngestDevMode = \"INNGEST_DEV\",\n  InngestAllowInBandSync = \"INNGEST_ALLOW_IN_BAND_SYNC\",\n\n  /**\n   * @deprecated It's unknown what this env var was used for, but we do not\n   * provide explicit support for it. Prefer using `INNGEST_ENV` instead.\n   */\n  BranchName = \"BRANCH_NAME\",\n\n  /**\n   * The git branch of the commit the deployment was triggered by. Example:\n   * `improve-about-page`.\n   *\n   * {@link https://vercel.com/docs/concepts/projects/environment-variables/system-environment-variables#system-environment-variables}\n   */\n  VercelBranch = \"VERCEL_GIT_COMMIT_REF\",\n\n  /**\n   * Expected to be `\"1\"` if defined.\n   */\n  IsVercel = \"VERCEL\",\n\n  /**\n   * The branch name of the current deployment. May only be accessible at build\n   * time, but included here just in case.\n   *\n   * {@link https://developers.cloudflare.com/pages/platform/build-configuration/#environment-variables}\n   */\n  CloudflarePagesBranch = \"CF_PAGES_BRANCH\",\n\n  /**\n   * Expected to be `\"1\"` if defined.\n   */\n  IsCloudflarePages = \"CF_PAGES\",\n\n  /**\n   * The branch name of the deployment from Git to Netlify, if available.\n   *\n   * {@link https://docs.netlify.com/configure-builds/environment-variables/#git-metadata}\n   */\n  NetlifyBranch = \"BRANCH\",\n\n  /**\n   * Expected to be `\"true\"` if defined.\n   */\n  IsNetlify = \"NETLIFY\",\n\n  /**\n   * The Git branch for a service or deploy.\n   *\n   * {@link https://render.com/docs/environment-variables#all-services}\n   */\n  RenderBranch = \"RENDER_GIT_BRANCH\",\n\n  /**\n   * Expected to be `\"true\"` if defined.\n   */\n  IsRender = \"RENDER\",\n\n  /**\n   * The branch that triggered the deployment. Example: `main`\n   *\n   * {@link https://docs.railway.app/develop/variables#railway-provided-variables}\n   */\n  RailwayBranch = \"RAILWAY_GIT_BRANCH\",\n\n  /**\n   * The railway environment for the deployment. Example: `production`\n   *\n   * {@link https://docs.railway.app/develop/variables#railway-provided-variables}\n   */\n  RailwayEnvironment = \"RAILWAY_ENVIRONMENT\",\n\n  VercelEnvKey = \"VERCEL_ENV\",\n\n  OpenAiApiKey = \"OPENAI_API_KEY\",\n  GeminiApiKey = \"GEMINI_API_KEY\",\n  AnthropicApiKey = \"ANTHROPIC_API_KEY\",\n}\n\n/**\n * Keys for accessing headers included in requests from Inngest to run\n * functions.\n *\n * Used internally to create handlers using `InngestCommHandler`, but can be\n * imported to be used if creating a custom handler outside of the package.\n *\n * @public\n */\nexport enum headerKeys {\n  ContentLength = \"content-length\",\n  Signature = \"x-inngest-signature\",\n  SdkVersion = \"x-inngest-sdk\",\n  Environment = \"x-inngest-env\",\n  Platform = \"x-inngest-platform\",\n  Framework = \"x-inngest-framework\",\n  NoRetry = \"x-inngest-no-retry\",\n  RequestVersion = \"x-inngest-req-version\",\n  RetryAfter = \"retry-after\",\n  InngestServerKind = \"x-inngest-server-kind\",\n  InngestExpectedServerKind = \"x-inngest-expected-server-kind\",\n  InngestSyncKind = \"x-inngest-sync-kind\",\n  EventIdSeed = \"x-inngest-event-id-seed\",\n  TraceParent = \"traceparent\",\n  TraceState = \"tracestate\",\n}\n\nexport const defaultInngestApiBaseUrl = \"https://api.inngest.com/\";\nexport const defaultInngestEventBaseUrl = \"https://inn.gs/\";\nexport const defaultDevServerHost = \"http://localhost:8288/\";\n\n/**\n * Events that Inngest may send internally that can be used to trigger\n * functions.\n *\n * @public\n */\nexport enum internalEvents {\n  /**\n   * A function has failed after exhausting all available retries. This event\n   * will contain the original event and the error that caused the failure.\n   */\n  FunctionFailed = \"inngest/function.failed\",\n  FunctionInvoked = \"inngest/function.invoked\",\n  FunctionFinished = \"inngest/function.finished\",\n  FunctionCancelled = \"inngest/function.cancelled\",\n  ScheduledTimer = \"inngest/scheduled.timer\",\n}\n\nexport const logPrefix: string = chalk.magenta.bold(\"[Inngest]\");\n\nexport const debugPrefix = \"inngest\";\n\nexport const dummyEventKey = \"NO_EVENT_KEY_SET\";\n\nexport enum serverKind {\n  Dev = \"dev\",\n  Cloud = \"cloud\",\n}\n\nexport enum syncKind {\n  InBand = \"in_band\",\n  OutOfBand = \"out_of_band\",\n}\n\n/**\n * The execution models the SDK is aware of.\n *\n * This is used in a number of places to ensure all execution versions are\n * accounted for for a given operation.\n */\nexport enum ExecutionVersion {\n  /**\n   * Very legacy, initial version of the executor. Uses hashed op objects and\n   * `pos` to determine the order of execution and which ops to run.\n   *\n   * Very stubborn about determinism.\n   */\n  V0 = 0,\n\n  /**\n   * Uses a more flexible approach to execution and is more lenient about\n   * determinism, allowing non-step async actions and non-determinism.\n   *\n   * Nowhere near as stubborn about determinism and so can silently migrate\n   * between versions after bug fixes.\n   */\n  V1 = 1,\n\n  /**\n   * Identical to V1, but allows the Executor to optimize parallel calls, hugely\n   * reducing traffic going to/from the SDK.\n   */\n  V2 = 2,\n}\n"],"names":["logPrefix: string"],"mappings":"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","debugId":null}},
    {"offset": {"line": 238, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/inngest/version.js","sources":["file:///Users/harshitgangwar/Desktop/SkillForge/node_modules/src/version.ts"],"sourcesContent":["// Generated by genversion.\nexport const version = \"3.43.1\";\n"],"names":[],"mappings":";;;;;AACA,MAAa,UAAU","debugId":null}},
    {"offset": {"line": 250, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/inngest/helpers/strings.js","sources":["file:///Users/harshitgangwar/Desktop/SkillForge/node_modules/src/helpers/strings.ts"],"sourcesContent":["import hashjs from \"hash.js\";\nimport { default as safeStringify } from \"json-stringify-safe\";\nimport ms from \"ms\";\nimport type { TimeStr } from \"../types.ts\";\n\nconst { sha256 } = hashjs;\n\n/**\n * Safely `JSON.stringify()` an `input`, handling circular refernences and\n * removing `BigInt` values.\n */\n// biome-ignore lint/suspicious/noExplicitAny: <explanation>\nexport const stringify = (input: any): string => {\n  return safeStringify(input, (_key, value) => {\n    if (typeof value !== \"bigint\") {\n      return value;\n    }\n  });\n};\n\n/**\n * Returns a slugified string used to generate consistent IDs.\n *\n * This can be used to generate a consistent ID for a function when migrating\n * from v2 to v3 of the SDK.\n *\n * @public\n */\nexport const slugify = (str: string): string => {\n  const join = \"-\";\n  return str\n    .toLowerCase()\n    .replace(/[^a-z0-9-]+/g, join)\n    .replace(/-+/g, join)\n    .split(join)\n    .filter(Boolean)\n    .join(join);\n};\n\nconst millisecond = 1;\nconst second = millisecond * 1000;\nconst minute = second * 60;\nconst hour = minute * 60;\nconst day = hour * 24;\nconst week = day * 7;\n\n/**\n * A collection of periods in milliseconds and their suffixes used when creating\n * time strings.\n */\nconst periods = [\n  [\"w\", week],\n  [\"d\", day],\n  [\"h\", hour],\n  [\"m\", minute],\n  [\"s\", second],\n] as const;\n\n/**\n * Convert a given `Date`, `number`, or `ms`-compatible `string` to a\n * Inngest sleep-compatible time string (e.g. `\"1d\"` or `\"2h3010s\"`).\n *\n * Can optionally provide a `now` date to use as the base for the calculation,\n * otherwise a new date will be created on invocation.\n */\nexport const timeStr = (\n  /**\n   * The future date to use to convert to a time string.\n   */\n  input: string | number | Date,\n): string => {\n  if (input instanceof Date) {\n    return input.toISOString();\n  }\n\n  const milliseconds: number =\n    typeof input === \"string\" ? ms(input as `${number}`) : input;\n\n  const [, timeStr] = periods.reduce<[number, string]>(\n    ([num, str], [suffix, period]) => {\n      const numPeriods = Math.floor(num / period);\n\n      if (numPeriods > 0) {\n        return [num % period, `${str}${numPeriods}${suffix}`];\n      }\n\n      return [num, str];\n    },\n    [milliseconds, \"\"],\n  );\n\n  return timeStr as TimeStr;\n};\n\n/**\n * Given an unknown input, stringify it if it's a boolean, a number, or a\n * string, else return `undefined`.\n */\nexport const stringifyUnknown = (input: unknown): string | undefined => {\n  if (\n    typeof input === \"boolean\" ||\n    typeof input === \"number\" ||\n    typeof input === \"string\"\n  ) {\n    return input.toString();\n  }\n\n  return;\n};\n\nexport const hashEventKey = (eventKey: string): string => {\n  return sha256().update(eventKey).digest(\"hex\");\n};\n\nexport const hashSigningKey = (signingKey: string | undefined): string => {\n  if (!signingKey) {\n    return \"\";\n  }\n\n  const prefix = signingKey.match(/^signkey-[\\w]+-/)?.shift() || \"\";\n  const key = signingKey.replace(/^signkey-[\\w]+-/, \"\");\n\n  // Decode the key from its hex representation into a bytestream\n  return `${prefix}${sha256().update(key, \"hex\").digest(\"hex\")}`;\n};\n"],"names":["stringify","safeStringify","milliseconds: number","timeStr"],"mappings":";;;;;;;;;;;;;;;;;;;;;AAKA,MAAM,EAAE,MAAA,EAAA,GAAW,sJAAA;;;;GAOnB,MAAaA,cAAAA,CAAa,UAAuB;IAC/C,WAAOC,mKAAAA,EAAc,OAAA,CAAQ,MAAM,UAAU;QAC3C,IAAI,OAAO,UAAU,SACnB,CAAA,OAAO;MAET;;;;;;;;;GAWJ,MAAa,UAAA,CAAW,QAAwB;IAC9C,MAAM,OAAO;IACb,OAAO,IACJ,WAAA,EAAa,CACb,OAAA,CAAQ,gBAAgB,KAAK,CAC7B,OAAA,CAAQ,OAAO,KAAK,CACpB,KAAA,CAAM,KAAK,CACX,MAAA,CAAO,QAAQ,CACf,IAAA,CAAK,KAAK;;AAIf,MAAM,SADc,IACS;AAC7B,MAAM,SAAS,SAAS;AACxB,MAAM,OAAO,SAAS;AACtB,MAAM,MAAM,OAAO;;;;GAOnB,MAAM,UAAU;IACd;QAAC;QAPU,MAAM;KAON;IACX;QAAC;QAAK;KAAI;IACV;QAAC;QAAK;KAAK;IACX;QAAC;QAAK;KAAO;IACb;QAAC;QAAK;KAAO;CACd;;;;;;;GASD,MAAa,UAAA,CAIX,UACW;IACX,IAAI,iBAAiB,KACnB,CAAA,OAAO,MAAM,WAAA,EAAa;IAG5B,MAAMC,eACJ,OAAO,UAAU,eAAW,wIAAA,EAAG,MAAqB,GAAG;IAEzD,MAAM,GAAGC,UAAAA,GAAW,QAAQ,MAAA,CAAA,CACzB,CAAC,KAAK,IAAA,EAAM,CAAC,QAAQ,OAAA,KAAY;QAChC,MAAM,aAAa,KAAK,KAAA,CAAM,MAAM,OAAO;QAE3C,IAAI,aAAa,EACf,CAAA,OAAO;YAAC,MAAM;YAAQ,GAAG,MAAM,aAAa,QAAA;SAAS;QAGvD,OAAO;YAAC;YAAK;SAAI;OAEnB;QAAC;QAAc;KAAG,CACnB;IAED,OAAOA;;;;;GAOT,MAAa,mBAAA,CAAoB,UAAuC;IACtE,IACE,OAAO,UAAU,aACjB,OAAO,UAAU,YACjB,OAAO,UAAU,SAEjB,CAAA,OAAO,MAAM,QAAA,EAAU;;AAM3B,MAAa,eAAA,CAAgB,aAA6B;IACxD,OAAO,QAAQ,CAAC,MAAA,CAAO,SAAS,CAAC,MAAA,CAAO,MAAM;;AAGhD,MAAa,iBAAA,CAAkB,eAA2C;IACxE,IAAI,CAAC,WACH,CAAA,OAAO;IAGT,MAAM,SAAS,WAAW,KAAA,CAAM,kBAAkB,EAAE,OAAO,IAAI;IAC/D,MAAM,MAAM,WAAW,OAAA,CAAQ,mBAAmB,GAAG;IAGrD,OAAO,GAAG,SAAS,QAAQ,CAAC,MAAA,CAAO,KAAK,MAAM,CAAC,MAAA,CAAO,MAAM,EAAA","debugId":null}},
    {"offset": {"line": 366, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/inngest/helpers/env.js","sources":["file:///Users/harshitgangwar/Desktop/SkillForge/node_modules/src/helpers/env.ts"],"sourcesContent":["// This file exists to help normalize process.env amongst the backend\n// and frontend.  Many frontends (eg. Next, CRA) utilize webpack's DefinePlugin\n// along with prefixes, meaning we have to explicitly use the full `process.env.FOO`\n// string in order to read variables.\n\nimport type { Inngest } from \"../components/Inngest.ts\";\nimport type { SupportedFrameworkName } from \"../types.ts\";\nimport { version } from \"../version.ts\";\nimport { defaultDevServerHost, envKeys, headerKeys } from \"./consts.ts\";\nimport { stringifyUnknown } from \"./strings.ts\";\n\n/**\n * @public\n */\nexport type Env = Record<string, EnvValue>;\n\n/**\n * @public\n */\nexport type EnvValue = string | undefined;\n\n/**\n * devServerHost returns the dev server host by searching for the INNGEST_DEVSERVER_URL\n * environment variable (plus project prefixces for eg. react, such as REACT_APP_INNGEST_DEVSERVER_URL).\n *\n * If not found this returns undefined, indicating that the env var has not been set.\n *\n * @example devServerHost()\n */\nexport const devServerHost = (env: Env = allProcessEnv()): EnvValue => {\n  // devServerKeys are the env keys we search for to discover the dev server\n  // URL.  This includes the standard key first, then includes prefixed keys\n  // for use within common frameworks (eg. CRA, next).\n  //\n  // We have to fully write these using process.env as they're typically\n  // processed using webpack's DefinePlugin, which is dumb and does a straight\n  // text replacement instead of actually understanding the AST, despite webpack\n  // being fully capable of understanding the AST.\n  const prefixes = [\"REACT_APP_\", \"NEXT_PUBLIC_\"];\n  const keys = [envKeys.InngestBaseUrl, envKeys.InngestDevMode];\n\n  const values = keys.flatMap((key) => {\n    return prefixes.map((prefix) => {\n      return env[prefix + key];\n    });\n  });\n\n  return values.find((v) => {\n    if (!v) {\n      return;\n    }\n\n    try {\n      return Boolean(new URL(v));\n    } catch {\n      // no-op\n    }\n\n    return;\n  });\n};\n\nconst checkFns = (<\n  T extends Record<string, (actual: EnvValue, expected: EnvValue) => boolean>,\n>(\n  checks: T,\n): T => checks)({\n  equals: (actual, expected) => actual === expected,\n  \"starts with\": (actual, expected) =>\n    expected ? (actual?.startsWith(expected) ?? false) : false,\n  \"is truthy\": (actual) => Boolean(actual),\n  \"is truthy but not\": (actual, expected) =>\n    Boolean(actual) && actual !== expected,\n});\n\nconst prodChecks: [\n  key: string,\n  customCheck: keyof typeof checkFns,\n  value?: string,\n][] = [\n  [\"CF_PAGES\", \"equals\", \"1\"],\n  [\"CONTEXT\", \"starts with\", \"prod\"],\n  [\"ENVIRONMENT\", \"starts with\", \"prod\"],\n  [\"NODE_ENV\", \"starts with\", \"prod\"],\n  [\"VERCEL_ENV\", \"starts with\", \"prod\"],\n  [\"DENO_DEPLOYMENT_ID\", \"is truthy\"],\n  [envKeys.VercelEnvKey, \"is truthy but not\", \"development\"],\n  [envKeys.IsNetlify, \"is truthy\"],\n  [envKeys.IsRender, \"is truthy\"],\n  [envKeys.RailwayBranch, \"is truthy\"],\n  [envKeys.IsCloudflarePages, \"is truthy\"],\n];\n\ninterface IsProdOptions {\n  /**\n   * The optional environment variables to use instead of `process.env`.\n   */\n  env?: Record<string, EnvValue>;\n\n  /**\n   * The Inngest client that's being used when performing this check. This is\n   * used to check if the client has an explicit mode set, and if so, to use\n   * that mode instead of inferring it from the environment.\n   */\n  client?: Inngest.Any;\n\n  /**\n   * If specified as a `boolean`, this will be returned as the result of the\n   * function. Useful for options that may or may not be set by users.\n   */\n  explicitMode?: Mode[\"type\"];\n}\n\nexport interface ModeOptions {\n  type: \"cloud\" | \"dev\";\n\n  /**\n   * Whether the mode was explicitly set, or inferred from other sources.\n   */\n  isExplicit: boolean;\n\n  /**\n   * If the mode was explicitly set as a dev URL, this is the URL that was set.\n   */\n  explicitDevUrl?: URL;\n\n  /**\n   * Environment variables to use when determining the mode.\n   */\n  env?: Env;\n}\n\nexport class Mode {\n  public readonly type: \"cloud\" | \"dev\";\n\n  /**\n   * Whether the mode was explicitly set, or inferred from other sources.\n   */\n  public readonly isExplicit: boolean;\n\n  public readonly explicitDevUrl?: URL;\n\n  // biome-ignore lint/correctness/noUnusedPrivateClassMembers: used in the SDK\n  private readonly env: Env;\n\n  constructor({\n    type,\n    isExplicit,\n    explicitDevUrl,\n    env = allProcessEnv(),\n  }: ModeOptions) {\n    this.env = env;\n    this.type = type;\n    this.isExplicit = isExplicit || Boolean(explicitDevUrl);\n    this.explicitDevUrl = explicitDevUrl;\n  }\n\n  public get isDev(): boolean {\n    return this.type === \"dev\";\n  }\n\n  public get isCloud(): boolean {\n    return this.type === \"cloud\";\n  }\n\n  public get isInferred(): boolean {\n    return !this.isExplicit;\n  }\n\n  /**\n   * If we are explicitly in a particular mode, retrieve the URL that we are\n   * sure we should be using, not considering any environment variables or other\n   * influences.\n   */\n  public getExplicitUrl(defaultCloudUrl: string): string | undefined {\n    if (!this.isExplicit) {\n      return undefined;\n    }\n\n    if (this.explicitDevUrl) {\n      return this.explicitDevUrl.href;\n    }\n\n    if (this.isCloud) {\n      return defaultCloudUrl;\n    }\n\n    if (this.isDev) {\n      return defaultDevServerHost;\n    }\n\n    return undefined;\n  }\n}\n\n/**\n * Returns the mode of the current environment, based off of either passed\n * environment variables or `process.env`, or explicit settings.\n */\nexport const getMode = ({\n  env = allProcessEnv(),\n  client,\n  explicitMode,\n}: IsProdOptions = {}): Mode => {\n  if (explicitMode) {\n    return new Mode({ type: explicitMode, isExplicit: true, env });\n  }\n\n  if (client?.[\"mode\"].isExplicit) {\n    return client[\"mode\"];\n  }\n\n  if (envKeys.InngestDevMode in env) {\n    if (typeof env[envKeys.InngestDevMode] === \"string\") {\n      try {\n        const explicitDevUrl = new URL(env[envKeys.InngestDevMode]);\n        return new Mode({ type: \"dev\", isExplicit: true, explicitDevUrl, env });\n      } catch {\n        // no-op\n      }\n    }\n\n    const envIsDev = parseAsBoolean(env[envKeys.InngestDevMode]);\n    if (typeof envIsDev === \"boolean\") {\n      return new Mode({\n        type: envIsDev ? \"dev\" : \"cloud\",\n        isExplicit: true,\n        env,\n      });\n    }\n  }\n\n  const isProd = prodChecks.some(([key, checkKey, expected]) => {\n    return checkFns[checkKey](stringifyUnknown(env[key]), expected);\n  });\n\n  return new Mode({ type: isProd ? \"cloud\" : \"dev\", isExplicit: false, env });\n};\n\n/**\n * getEnvironmentName returns the suspected branch name for this environment by\n * searching through a set of common environment variables.\n *\n * This could be used to determine if we're on a branch deploy or not, though it\n * should be noted that we don't know if this is the default branch or not.\n */\nexport const getEnvironmentName = (env: Env = allProcessEnv()): EnvValue => {\n  /**\n   * Order is important; more than one of these env vars may be set, so ensure\n   * that we check the most specific, most reliable env vars first.\n   */\n  return (\n    env[envKeys.InngestEnvironment] ||\n    env[envKeys.BranchName] ||\n    env[envKeys.VercelBranch] ||\n    env[envKeys.NetlifyBranch] ||\n    env[envKeys.CloudflarePagesBranch] ||\n    env[envKeys.RenderBranch] ||\n    env[envKeys.RailwayBranch]\n  );\n};\n\nexport const processEnv = (key: string): EnvValue => {\n  return allProcessEnv()[key];\n};\n\n/**\n * The Deno environment, which is not always available.\n */\ndeclare const Deno: {\n  env: { toObject: () => Env };\n};\n\n/**\n * The Netlify environment, which is not always available.\n */\ndeclare const Netlify: {\n  env: { toObject: () => Env };\n};\n\n/**\n * allProcessEnv returns the current process environment variables, or an empty\n * object if they cannot be read, making sure we support environments other than\n * Node such as Deno, too.\n *\n * Using this ensures we don't dangerously access `process.env` in environments\n * where it may not be defined, such as Deno or the browser.\n */\nexport const allProcessEnv = (): Env => {\n  // Node, or Node-like environments\n  try {\n    if (process.env) {\n      return process.env;\n    }\n  } catch (_err) {\n    // noop\n  }\n\n  // Deno\n  try {\n    const env = Deno.env.toObject();\n\n    if (env) {\n      return env;\n    }\n  } catch (_err) {\n    // noop\n  }\n\n  // Netlify\n  try {\n    const env = Netlify.env.toObject();\n\n    if (env) {\n      return env;\n    }\n  } catch (_err) {\n    // noop\n  }\n\n  return {};\n};\n\n/**\n * Generate a standardised set of headers based on input and environment\n * variables.\n *\n *\n */\nexport const inngestHeaders = (opts?: {\n  /**\n   * The environment variables to use instead of `process.env` or any other\n   * default source. Useful for platforms where environment variables are passed\n   * in alongside requests.\n   */\n  env?: Env;\n\n  /**\n   * The framework name to use in the `X-Inngest-Framework` header. This is not\n   * always available, hence being optional.\n   */\n  framework?: string;\n\n  /**\n   * The environment name to use in the `X-Inngest-Env` header. This is likely\n   * to be representative of the target preview environment.\n   */\n  inngestEnv?: string;\n\n  /**\n   * The Inngest client that's making the request. The client itself will\n   * generate a set of headers; specifying it here will ensure that the client's\n   * headers are included in the returned headers.\n   */\n  client?: Inngest;\n\n  /**\n   * The Inngest server we expect to be communicating with, used to ensure that\n   * various parts of a handshake are all happening with the same type of\n   * participant.\n   */\n  expectedServerKind?: string;\n\n  /**\n   * Any additional headers to include in the returned headers.\n   */\n  extras?: Record<string, string>;\n}): Record<string, string> => {\n  const sdkVersion = `inngest-js:v${version}`;\n  const headers: Record<string, string> = {\n    \"Content-Type\": \"application/json\",\n    \"User-Agent\": sdkVersion,\n    [headerKeys.SdkVersion]: sdkVersion,\n  };\n\n  if (opts?.framework) {\n    headers[headerKeys.Framework] = opts.framework;\n  }\n\n  if (opts?.expectedServerKind) {\n    headers[headerKeys.InngestExpectedServerKind] = opts.expectedServerKind;\n  }\n\n  const env = {\n    ...allProcessEnv(),\n    ...opts?.env,\n  };\n\n  const inngestEnv = opts?.inngestEnv || getEnvironmentName(env);\n  if (inngestEnv) {\n    headers[headerKeys.Environment] = inngestEnv;\n  }\n\n  const platform = getPlatformName(env);\n  if (platform) {\n    headers[headerKeys.Platform] = platform;\n  }\n\n  return {\n    ...headers,\n    ...opts?.client?.[\"headers\"],\n    ...opts?.extras,\n  };\n};\n\n/**\n * A set of checks that, given an environment, will return `true` if the current\n * environment is running on the platform with the given name.\n */\nconst platformChecks = {\n  /**\n   * Vercel Edge Functions don't have access to environment variables unless\n   * they are explicitly referenced in the top level code, but they do have a\n   * global `EdgeRuntime` variable set that we can use to detect this.\n   */\n  vercel: (env) =>\n    env[envKeys.IsVercel] === \"1\" || typeof EdgeRuntime === \"string\",\n  netlify: (env) => env[envKeys.IsNetlify] === \"true\",\n  \"cloudflare-pages\": (env) => env[envKeys.IsCloudflarePages] === \"1\",\n  render: (env) => env[envKeys.IsRender] === \"true\",\n  railway: (env) => Boolean(env[envKeys.RailwayEnvironment]),\n} satisfies Record<string, (env: Env) => boolean>;\n\ndeclare const EdgeRuntime: string | undefined;\n\n/**\n * A set of checks that, given an environment, will return `true` if the current\n * environment and platform supports streaming responses back to Inngest.\n *\n * Streaming capability is both framework and platform-based. Frameworks are\n * supported in serve handlers, and platforms are checked here.\n *\n * As such, this record declares which platforms we explicitly support for\n * streaming and is used by {@link platformSupportsStreaming}.\n */\nconst streamingChecks: Partial<\n  Record<\n    keyof typeof platformChecks,\n    (framework: SupportedFrameworkName, env: Env) => boolean\n  >\n> = {\n  /**\n   * \"Vercel supports streaming for Serverless Functions, Edge Functions, and\n   * React Server Components in Next.js projects.\"\n   *\n   * In practice, however, there are many reports of streaming not working as\n   * expected on Serverless Functions, so we resort to only allowing streaming\n   * for Edge Functions here.\n   *\n   * See {@link https://vercel.com/docs/frameworks/nextjs#streaming}\n   */\n  vercel: (_framework, _env) => typeof EdgeRuntime === \"string\",\n  \"cloudflare-pages\": () => true,\n};\n\nexport const getPlatformName = (env: Env) => {\n  return (Object.keys(platformChecks) as (keyof typeof platformChecks)[]).find(\n    (key) => {\n      return platformChecks[key](env);\n    },\n  );\n};\n\n/**\n * Returns `true` if we believe the current environment supports streaming\n * responses back to Inngest.\n *\n * We run a check directly related to the platform we believe we're running on,\n * usually based on environment variables.\n */\nexport const platformSupportsStreaming = (\n  framework: SupportedFrameworkName,\n  env: Env = allProcessEnv(),\n): boolean => {\n  return (\n    streamingChecks[getPlatformName(env) as keyof typeof streamingChecks]?.(\n      framework,\n      env,\n    ) ?? false\n  );\n};\n\n/**\n * A unique symbol used to mark a custom fetch implementation. We wrap the\n * implementations to provide some extra control when handling errors.\n */\nconst CUSTOM_FETCH_MARKER = Symbol(\"Custom fetch implementation\");\n\n/**\n * Given a potential fetch function, return the fetch function to use based on\n * this and the environment.\n */\nexport const getFetch = (givenFetch?: typeof fetch): typeof fetch => {\n  /**\n   * If we've explicitly been given a fetch function, use that.\n   */\n  if (givenFetch) {\n    if (CUSTOM_FETCH_MARKER in givenFetch) {\n      return givenFetch;\n    }\n\n    /**\n     * We wrap the given fetch function to provide some extra control when\n     * handling errors.\n     */\n    const customFetch: typeof fetch = async (...args) => {\n      try {\n        return await givenFetch(...args);\n      } catch (err) {\n        /**\n         * Capture warnings that are not simple fetch failures and highlight\n         * them for the user.\n         *\n         * We also use this opportunity to log the causing error, as code higher\n         * up the stack will likely abstract this.\n         */\n        if (\n          !(err instanceof Error) ||\n          !err.message?.startsWith(\"fetch failed\")\n        ) {\n          console.warn(\n            \"A request failed when using a custom fetch implementation; this may be a misconfiguration. Make sure that your fetch client is correctly bound to the global scope.\",\n          );\n          console.error(err);\n        }\n\n        throw err;\n      }\n    };\n\n    /**\n     * Mark the custom fetch implementation so that we can identify it later, in\n     * addition to adding some runtime properties to it to make it seem as much\n     * like the original fetch as possible.\n     */\n    Object.defineProperties(customFetch, {\n      [CUSTOM_FETCH_MARKER]: {},\n      name: { value: givenFetch.name },\n      length: { value: givenFetch.length },\n    });\n\n    return customFetch;\n  }\n\n  /**\n   * Browser or Node 18+\n   */\n  try {\n    if (typeof globalThis !== \"undefined\" && \"fetch\" in globalThis) {\n      return fetch.bind(globalThis);\n    }\n  } catch (_err) {\n    // no-op\n  }\n\n  /**\n   * Existing polyfilled fetch\n   */\n  if (typeof fetch !== \"undefined\") {\n    return fetch;\n  }\n\n  /**\n   * Environments where fetch cannot be found and must be polyfilled\n   */\n  return require(\"cross-fetch\") as typeof fetch;\n};\n\n/**\n * If `Response` isn't included in this environment, it's probably an earlier\n * Node env that isn't already polyfilling. This function returns either the\n * native `Response` or a polyfilled one.\n */\nexport const getResponse = (): typeof Response => {\n  if (typeof Response !== \"undefined\") {\n    return Response;\n  }\n\n  return require(\"cross-fetch\").Response;\n};\n\n/**\n * Given an unknown value, try to parse it as a `boolean`. Useful for parsing\n * environment variables that could be a selection of different values such as\n * `\"true\"`, `\"1\"`.\n *\n * If the value could not be confidently parsed as a `boolean` or was seen to be\n * `undefined`, this function returns `undefined`.\n */\nexport const parseAsBoolean = (value: unknown): boolean | undefined => {\n  if (typeof value === \"boolean\") {\n    return value;\n  }\n\n  if (typeof value === \"number\") {\n    return Boolean(value);\n  }\n\n  if (typeof value === \"string\") {\n    const trimmed = value.trim().toLowerCase();\n\n    if (trimmed === \"undefined\") {\n      return undefined;\n    }\n\n    if ([\"true\", \"1\"].includes(trimmed)) {\n      return true;\n    }\n\n    return false;\n  }\n\n  return undefined;\n};\n"],"names":["prodChecks: [\n  key: string,\n  customCheck: keyof typeof checkFns,\n  value?: string,\n][]","headers: Record<string, string>","streamingChecks: Partial<\n  Record<\n    keyof typeof platformChecks,\n    (framework: SupportedFrameworkName, env: Env) => boolean\n  >\n>","customFetch: typeof fetch"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GA6BA,MAAa,gBAAA,CAAiB,MAAW,eAAe,KAAe;IASrE,MAAM,WAAW;QAAC;QAAc;KAAe;IAS/C,OARa;QAAC,yJAAA,CAAQ,cAAA;QAAgB,yJAAA,CAAQ,cAAA;KAAe,CAEzC,OAAA,CAAA,CAAS,QAAQ;QACnC,OAAO,SAAS,GAAA,CAAA,CAAK,WAAW;YAC9B,OAAO,GAAA,CAAI,SAAS,IAAA;UACpB;MACF,CAEY,IAAA,CAAA,CAAM,MAAM;QACxB,IAAI,CAAC,EACH,CAAA;QAGF,IAAI;YACF,OAAO,QAAQ,IAAI,IAAI,EAAE,CAAC;iBACpB,CAAA;MAKR;;AAGJ,MAAM,WAAA,CAAA,CAGJ,SACM,MAAA,EAAQ;IACd,QAAA,CAAS,QAAQ,WAAa,WAAW;IACzC,eAAA,CAAgB,QAAQ,WACtB,WAAY,QAAQ,WAAW,SAAS,IAAI,QAAS;IACvD,aAAA,CAAc,SAAW,QAAQ,OAAO;IACxC,qBAAA,CAAsB,QAAQ,WAC5B,QAAQ,OAAO,IAAI,WAAW;CACjC,CAAC;AAEF,MAAMA,aAIA;IACJ;QAAC;QAAY;QAAU;KAAI;IAC3B;QAAC;QAAW;QAAe;KAAO;IAClC;QAAC;QAAe;QAAe;KAAO;IACtC;QAAC;QAAY;QAAe;KAAO;IACnC;QAAC;QAAc;QAAe;KAAO;IACrC;QAAC;QAAsB;KAAY;IACnC;QAAC,yJAAA,CAAQ,YAAA;QAAc;QAAqB;KAAc;IAC1D;QAAC,yJAAA,CAAQ,SAAA;QAAW;KAAY;IAChC;QAAC,yJAAA,CAAQ,QAAA;QAAU;KAAY;IAC/B;QAAC,yJAAA,CAAQ,aAAA;QAAe;KAAY;IACpC;QAAC,yJAAA,CAAQ,iBAAA;QAAmB;KAAY;CACzC;AAyCD,IAAa,OAAb,MAAkB;IACA,KAAA;;;IAKA,WAAA;IAEA,eAAA;IAGC,IAAA;IAEjB,YAAY,EACV,IAAA,EACA,UAAA,EACA,cAAA,EACA,MAAM,eAAe,EAAA,CACP;QACd,IAAA,CAAK,GAAA,GAAM;QACX,IAAA,CAAK,IAAA,GAAO;QACZ,IAAA,CAAK,UAAA,GAAa,cAAc,QAAQ,eAAe;QACvD,IAAA,CAAK,cAAA,GAAiB;;IAGxB,IAAW,QAAiB;QAC1B,OAAO,IAAA,CAAK,IAAA,KAAS;;IAGvB,IAAW,UAAmB;QAC5B,OAAO,IAAA,CAAK,IAAA,KAAS;;IAGvB,IAAW,aAAsB;QAC/B,OAAO,CAAC,IAAA,CAAK,UAAA;;;;;;IAQR,eAAe,eAAA,EAA6C;QACjE,IAAI,CAAC,IAAA,CAAK,UAAA,CACR,CAAA;QAGF,IAAI,IAAA,CAAK,cAAA,CACP,CAAA,OAAO,IAAA,CAAK,cAAA,CAAe,IAAA;QAG7B,IAAI,IAAA,CAAK,OAAA,CACP,CAAA,OAAO;QAGT,IAAI,IAAA,CAAK,KAAA,CACP,CAAA,OAAO,sKAAA;;;;;;GAWb,MAAa,UAAA,CAAW,EACtB,MAAM,eAAe,EACrB,MAAA,EACA,YAAA,EAAA,GACiB,CAAA,CAAE,KAAW;IAC9B,IAAI,aACF,CAAA,OAAO,IAAI,KAAK;QAAE,MAAM;QAAc,YAAY;QAAM;KAAK,CAAC;IAGhE,IAAI,QAAA,CAAS,OAAA,CAAQ,WACnB,CAAA,OAAO,MAAA,CAAO,OAAA;IAGhB,IAAI,yJAAA,CAAQ,cAAA,IAAkB,KAAK;QACjC,IAAI,OAAO,GAAA,CAAI,yJAAA,CAAQ,cAAA,CAAA,KAAoB,SACzC,CAAA,IAAI;YACF,MAAM,iBAAiB,IAAI,IAAI,GAAA,CAAI,yJAAA,CAAQ,cAAA,CAAA,CAAgB;YAC3D,OAAO,IAAI,KAAK;gBAAE,MAAM;gBAAO,YAAY;gBAAM;gBAAgB;aAAK,CAAC;iBACjE,CAAA;QAKV,MAAM,WAAW,eAAe,GAAA,CAAI,yJAAA,CAAQ,cAAA,CAAA,CAAgB;QAC5D,IAAI,OAAO,aAAa,UACtB,CAAA,OAAO,IAAI,KAAK;YACd,MAAM,WAAW,QAAQ;YACzB,YAAY;YACZ;SACD,CAAC;;IAIN,MAAM,SAAS,WAAW,IAAA,CAAA,CAAM,CAAC,KAAK,UAAU,SAAA,KAAc;QAC5D,OAAO,QAAA,CAAS,SAAA,KAAU,mKAAA,EAAiB,GAAA,CAAI,IAAA,CAAK,EAAE,SAAS;MAC/D;IAEF,OAAO,IAAI,KAAK;QAAE,MAAM,SAAS,UAAU;QAAO,YAAY;QAAO;KAAK,CAAC;;;;;;;;GAU7E,MAAa,qBAAA,CAAsB,MAAW,eAAe,KAAe;;;;IAK1E,OACE,GAAA,CAAI,yJAAA,CAAQ,kBAAA,CAAA,IACZ,GAAA,CAAI,yJAAA,CAAQ,UAAA,CAAA,IACZ,GAAA,CAAI,yJAAA,CAAQ,YAAA,CAAA,IACZ,GAAA,CAAI,yJAAA,CAAQ,aAAA,CAAA,IACZ,GAAA,CAAI,yJAAA,CAAQ,qBAAA,CAAA,IACZ,GAAA,CAAI,yJAAA,CAAQ,YAAA,CAAA,IACZ,GAAA,CAAI,yJAAA,CAAQ,aAAA,CAAA;;AAIhB,MAAa,aAAA,CAAc,QAA0B;IACnD,OAAO,eAAe,CAAC,IAAA;;;;;;;;;GAyBzB,MAAa,gBAAA,MAA2B;IAEtC,IAAI;QACF,IAAI,QAAQ,IACV,wBAAA,OAAO,QAAQ,GAAA;aAEV,MAAM,CAAA;IAKf,IAAI;QACF,MAAM,MAAM,KAAK,GAAA,CAAI,QAAA,EAAU;QAE/B,IAAI,IACF,CAAA,OAAO;aAEF,MAAM,CAAA;IAKf,IAAI;QACF,MAAM,MAAM,QAAQ,GAAA,CAAI,QAAA,EAAU;QAElC,IAAI,IACF,CAAA,OAAO;aAEF,MAAM,CAAA;IAIf,OAAO,CAAA,CAAE;;;;;;;GASX,MAAa,iBAAA,CAAkB,SAsCD;IAC5B,MAAM,aAAa,CAAA,YAAA,EAAe,+IAAA,EAAA;IAClC,MAAMC,UAAkC;QACtC,gBAAgB;QAChB,cAAc;SACb,4JAAA,CAAW,UAAA,CAAA,EAAa;KAC1B;IAED,IAAI,MAAM,UACR,CAAA,OAAA,CAAQ,4JAAA,CAAW,SAAA,CAAA,GAAa,KAAK,SAAA;IAGvC,IAAI,MAAM,mBACR,CAAA,OAAA,CAAQ,4JAAA,CAAW,yBAAA,CAAA,GAA6B,KAAK,kBAAA;IAGvD,MAAM,MAAM;QACV,GAAG,eAAe;QAClB,GAAG,MAAM,GAAA;KACV;IAED,MAAM,aAAa,MAAM,cAAc,mBAAmB,IAAI;IAC9D,IAAI,WACF,CAAA,OAAA,CAAQ,4JAAA,CAAW,WAAA,CAAA,GAAe;IAGpC,MAAM,WAAW,gBAAgB,IAAI;IACrC,IAAI,SACF,CAAA,OAAA,CAAQ,4JAAA,CAAW,QAAA,CAAA,GAAY;IAGjC,OAAO;QACL,GAAG,OAAA;QACH,GAAG,MAAM,QAAA,CAAS,UAAA;QAClB,GAAG,MAAM,MAAA;KACV;;;;;GAOH,MAAM,iBAAiB;IAMrB,QAAA,CAAS,MACP,GAAA,CAAI,yJAAA,CAAQ,QAAA,CAAA,KAAc,OAAO,OAAO,gBAAgB;IAC1D,SAAA,CAAU,MAAQ,GAAA,CAAI,yJAAA,CAAQ,SAAA,CAAA,KAAe;IAC7C,oBAAA,CAAqB,MAAQ,GAAA,CAAI,yJAAA,CAAQ,iBAAA,CAAA,KAAuB;IAChE,QAAA,CAAS,MAAQ,GAAA,CAAI,yJAAA,CAAQ,QAAA,CAAA,KAAc;IAC3C,SAAA,CAAU,MAAQ,QAAQ,GAAA,CAAI,yJAAA,CAAQ,kBAAA,CAAA,CAAoB;CAC3D;;;;;;;;;;GAcD,MAAMC,kBAKF;IAWF,QAAA,CAAS,YAAY,OAAS,OAAO,gBAAgB;IACrD,oBAAA,IAA0B;CAC3B;AAED,MAAa,kBAAA,CAAmB,QAAa;IAC3C,OAAQ,OAAO,IAAA,CAAK,eAAe,CAAqC,IAAA,CAAA,CACrE,QAAQ;QACP,OAAO,cAAA,CAAe,IAAA,CAAK,IAAI;MAElC;;;;;;;;GAUH,MAAa,4BAAA,CACX,WACA,MAAW,eAAe,KACd;IACZ,OACE,eAAA,CAAgB,gBAAgB,IAAI,CAAA,GAClC,WACA,IACD,IAAI;;;;;GAQT,MAAM,sBAAsB,OAAO,8BAA8B;;;;GAMjE,MAAa,WAAA,CAAY,eAA4C;;;IAInE,IAAI,YAAY;QACd,IAAI,uBAAuB,WACzB,CAAA,OAAO;;;;KAOT,MAAMC,cAA4B,OAAO,GAAG,SAAS;YACnD,IAAI;gBACF,OAAO,MAAM,WAAW,GAAG,KAAK;qBACzB,KAAK;;;;;;;OAQZ,IACE,CAAA,CAAE,eAAe,KAAA,KACjB,CAAC,IAAI,OAAA,EAAS,WAAW,eAAe,EACxC;oBACA,QAAQ,IAAA,CACN,sKACD;oBACD,QAAQ,KAAA,CAAM,IAAI;;gBAGpB,MAAM;;;;;;;KASV,OAAO,gBAAA,CAAiB,aAAa;aAClC,oBAAA,EAAsB,CAAA,CAAE;YACzB,MAAM;gBAAE,OAAO,WAAW,IAAA;YAAA,CAAM;YAChC,QAAQ;gBAAE,OAAO,WAAW,MAAA;YAAA,CAAQ;SACrC,CAAC;QAEF,OAAO;;;;IAMT,IAAI;QACF,IAAI,OAAO,eAAe,eAAe,WAAW,WAClD,CAAA,OAAO,MAAM,IAAA,CAAK,WAAW;aAExB,MAAM,CAAA;;;IAOf,IAAI,OAAO,UAAU,YACnB,CAAA,OAAO;;;IAMT,OAAA,IAAA,sKAAA,EAAe,cAAc;;;;;;GAQ/B,MAAa,cAAA,MAAqC;IAChD,IAAI,OAAO,aAAa,YACtB,CAAA,OAAO;IAGT,OAAA,IAAA,sKAAA,EAAe,cAAc,CAAC,QAAA;;;;;;;;;GAWhC,MAAa,iBAAA,CAAkB,UAAwC;IACrE,IAAI,OAAO,UAAU,UACnB,CAAA,OAAO;IAGT,IAAI,OAAO,UAAU,SACnB,CAAA,OAAO,QAAQ,MAAM;IAGvB,IAAI,OAAO,UAAU,UAAU;QAC7B,MAAM,UAAU,MAAM,IAAA,EAAM,CAAC,WAAA,EAAa;QAE1C,IAAI,YAAY,YACd,CAAA;QAGF,IAAI;YAAC;YAAQ;SAAI,CAAC,QAAA,CAAS,QAAQ,CACjC,CAAA,OAAO;QAGT,OAAO","debugId":null}},
    {"offset": {"line": 748, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/inngest/helpers/devserver.js","sources":["file:///Users/harshitgangwar/Desktop/SkillForge/node_modules/src/helpers/devserver.ts"],"sourcesContent":["import { defaultDevServerHost } from \"./consts.ts\";\nimport { devServerHost as envDevServerHost } from \"./env.ts\";\n\n// re-export from devserver.ts\n\n/**\n * A simple type map that we can transparently use `fetch` later without having\n * to fall in to the self-referencing `const fetch: typeof fetch = ...` which\n * fails.\n */\ntype FetchT = typeof fetch;\n\n/**\n * Attempts to contact the dev server, returning a boolean indicating whether or\n * not it was successful.\n *\n * @example devServerUrl(process.env[envKeys.DevServerUrl], \"/your-path\")\n */\nexport const devServerAvailable = async (\n  /**\n   * The host of the dev server. You should pass in an environment variable as\n   * this parameter.\n   */\n  host: string = defaultDevServerHost,\n\n  /**\n   * The fetch implementation to use to communicate with the dev server.\n   */\n  fetch: FetchT,\n): Promise<boolean> => {\n  try {\n    const url = devServerUrl(host, \"/dev\");\n    const result = await fetch(url.toString());\n    await result.json();\n    return true;\n  } catch (_e) {\n    return false;\n  }\n};\n\n/**\n * devServerUrl returns a full URL for the given path name.\n *\n * Because Cloudflare/V8 platforms don't allow process.env, you are expected\n * to pass in the host from the dev server env key:\n *\n * @example devServerUrl(processEnv(envKeys.DevServerUrl), \"/your-path\")\n * @example devServerUrl(\"http://localhost:8288/\", \"/your-path\")\n */\nexport const devServerUrl = (\n  host: string = devServerHost(),\n  pathname = \"\",\n): URL => {\n  return new URL(pathname, host.includes(\"://\") ? host : `http://${host}`);\n};\n\n/**\n * devServerHost exports the development server's domain by inspecting env\n * variables, or returns the default development server URL.\n *\n * This guarantees a specific URL as a string, as opposed to the env export\n * which only returns a value of the env var is set.\n */\nexport const devServerHost = (): string =>\n  envDevServerHost() || defaultDevServerHost;\n"],"names":["devServerHost","envDevServerHost"],"mappings":";;;;;;;;;;;;;;;;GAkBA,MAAa,qBAAqB,OAKhC,OAAe,sKAAA,EAKf,UACqB;IACrB,IAAI;QACF,MAAM,MAAM,aAAa,MAAM,OAAO;QAEtC,MAAA,CADe,MAAM,MAAM,IAAI,QAAA,EAAU,CAAC,EAC7B,IAAA,EAAM;QACnB,OAAO;aACA,IAAI;QACX,OAAO;;;;;;;;;;;GAaX,MAAa,eAAA,CACX,OAAeA,iBAAe,EAC9B,WAAW,EAAA,KACH;IACR,OAAO,IAAI,IAAI,UAAU,KAAK,QAAA,CAAS,MAAM,GAAG,OAAO,CAAA,OAAA,EAAU,MAAA,CAAO;;;;;;;;GAU1E,MAAaA,kBAAAA,QACXC,4JAAAA,EAAkB,KAAI,sKAAA","debugId":null}},
    {"offset": {"line": 797, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/inngest/helpers/enum.js","sources":["file:///Users/harshitgangwar/Desktop/SkillForge/node_modules/src/helpers/enum.ts"],"sourcesContent":["/**\n * Returns the value of an enum from a string value.\n *\n * If the value given is not a value from the enum, `undefined` is returned.\n */\nexport const enumFromValue = <T extends Record<string, unknown>>(\n  enumType: T,\n  value: unknown,\n): T[keyof T] | undefined => {\n  if (Object.values(enumType).includes(value)) {\n    return value as T[keyof T];\n  }\n\n  return;\n};\n"],"names":[],"mappings":";;;;;;;;;AAKA,MAAa,gBAAA,CACX,UACA,UAC2B;IAC3B,IAAI,OAAO,MAAA,CAAO,SAAS,CAAC,QAAA,CAAS,MAAM,CACzC,CAAA,OAAO","debugId":null}},
    {"offset": {"line": 815, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/inngest/components/NonRetriableError.js","sources":["file:///Users/harshitgangwar/Desktop/SkillForge/node_modules/src/components/NonRetriableError.ts"],"sourcesContent":["/**\n * An error that, when thrown, indicates to Inngest that the function should\n * cease all execution and not retry.\n *\n * A `message` must be provided, and an optional `cause` can be provided to\n * provide more context to the error.\n *\n * @public\n */\nexport class NonRetriableError extends Error {\n  /**\n   * The underlying cause of the error, if any.\n   *\n   * This will be serialized and sent to Inngest.\n   */\n  public override readonly cause?: unknown;\n\n  constructor(\n    message: string,\n    options?: {\n      /**\n       * The underlying cause of the error, if any.\n       *\n       * This will be serialized and sent to Inngest.\n       */\n      cause?: unknown;\n    },\n  ) {\n    super(message);\n\n    this.cause = options?.cause;\n\n    this.name = \"NonRetriableError\";\n  }\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;AASA,IAAa,oBAAb,cAAuC,MAAM;;;;;IAMlB,MAAA;IAEzB,YACE,OAAA,EACA,OAAA,CAQA;QACA,KAAA,CAAM,QAAQ;QAEd,IAAA,CAAK,KAAA,GAAQ,SAAS;QAEtB,IAAA,CAAK,IAAA,GAAO","debugId":null}},
    {"offset": {"line": 846, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/inngest/helpers/errors.js","sources":["file:///Users/harshitgangwar/Desktop/SkillForge/node_modules/src/helpers/errors.ts"],"sourcesContent":["import chalk from \"chalk\";\nimport stringify from \"json-stringify-safe\";\nimport {\n  type SerializedError as CjsSerializedError,\n  deserializeError as cjsDeserializeError,\n  serializeError as cjsSerializeError,\n  errorConstructors,\n} from \"serialize-error-cjs\";\nimport stripAnsi from \"strip-ansi\";\nimport { z } from \"zod/v3\";\nimport type { Inngest } from \"../components/Inngest.ts\";\nimport { NonRetriableError } from \"../components/NonRetriableError.ts\";\nimport type { ClientOptions, OutgoingOp } from \"../types.ts\";\n\nconst SERIALIZED_KEY = \"__serialized\";\nconst SERIALIZED_VALUE = true;\n\n/**\n * Add first-class support for certain errors that we control, in addition to\n * built-in errors such as `TypeError`.\n *\n * Adding these allows these non-standard errors to be correctly serialized,\n * sent to Inngest, then deserialized back into the correct error type for users\n * to react to correctly.\n *\n * Note that these errors only support `message?: string | undefined` as the\n * input; more custom errors are not supported with this current strategy.\n */\nerrorConstructors.set(\n  \"NonRetriableError\",\n  NonRetriableError as ErrorConstructor,\n);\n\nexport interface SerializedError extends Readonly<CjsSerializedError> {\n  readonly [SERIALIZED_KEY]: typeof SERIALIZED_VALUE;\n}\n\n/**\n * Serialise an error to a serialized JSON string.\n *\n * Errors do not serialise nicely to JSON, so we use this function to convert\n * them to a serialized JSON string. Doing this is also non-trivial for some\n * errors, so we use the `serialize-error` package to do it for us.\n *\n * See {@link https://www.npmjs.com/package/serialize-error}\n *\n * This function is a small wrapper around that package to also add a `type`\n * property to the serialised error, so that we can distinguish between\n * serialised errors and other objects.\n *\n * Will not reserialise existing serialised errors.\n */\nexport const serializeError = <\n  TAllowUnknown extends boolean = false,\n  TOutput extends TAllowUnknown extends true\n    ? unknown\n    : SerializedError = TAllowUnknown extends true ? unknown : SerializedError,\n>(\n  /**\n   * The suspected error to serialize.\n   */\n  subject: unknown,\n\n  /**\n   * If `true` and the error is not serializable, will return the original value\n   * as `unknown` instead of coercing it to a serialized error.\n   */\n  allowUnknown: TAllowUnknown = false as TAllowUnknown,\n): TOutput => {\n  try {\n    // Try to understand if this is already done.\n    // Will handle stringified errors.\n    const existingSerializedError = isSerializedError(subject);\n\n    if (existingSerializedError) {\n      return existingSerializedError as TOutput;\n    }\n\n    if (typeof subject === \"object\" && subject !== null) {\n      // Is an object, so let's try and serialize it.\n      const serializedErr = cjsSerializeError(subject as Error);\n\n      // Not a proper error was caught, so give us a chance to return `unknown`.\n      if (!serializedErr.name && allowUnknown) {\n        return subject as TOutput;\n      }\n\n      // Serialization can succeed but assign no name or message, so we'll\n      // map over the result here to ensure we have everything.\n      // We'll just stringify the entire subject for the message, as this at\n      // least provides some context for the user.\n      const ret = {\n        // Ensure we spread to also capture additional properties such as\n        // `cause`.\n        ...serializedErr,\n\n        name: serializedErr.name || \"Error\",\n        message:\n          serializedErr.message ||\n          stringify(subject) ||\n          \"Unknown error; error serialization could not find a message.\",\n        stack: serializedErr.stack || \"\",\n        [SERIALIZED_KEY]: SERIALIZED_VALUE,\n      } as const;\n\n      // If we have a cause, make sure we recursively serialize them too. We are\n      // lighter with causes though; attempt to recursively serialize them, but\n      // stop if we find something that doesn't work and just return `unknown`.\n      let target: unknown = ret;\n      const maxDepth = 5;\n      for (let i = 0; i < maxDepth; i++) {\n        if (\n          typeof target === \"object\" &&\n          target !== null &&\n          \"cause\" in target &&\n          target.cause\n        ) {\n          target = target.cause = serializeError(target.cause, true);\n          continue;\n        }\n\n        break;\n      }\n\n      return ret as TOutput;\n    }\n\n    // If it's not an object, it's hard to parse this as an Error. In this case,\n    // we'll throw an error to start attempting backup strategies.\n    throw new Error(\"Error is not an object; strange throw value.\");\n  } catch {\n    if (allowUnknown) {\n      // If we are allowed to return unknown, we'll just return the original\n      // value.\n      return subject as TOutput;\n    }\n\n    try {\n      // If serialization fails, fall back to a regular Error and use the\n      // original object as the message for an Error. We don't know what this\n      // object looks like, so we can't do anything else with it.\n      return {\n        ...serializeError(\n          new Error(typeof subject === \"string\" ? subject : stringify(subject)),\n          false,\n        ),\n        // Remove the stack; it's not relevant here\n        stack: \"\",\n        [SERIALIZED_KEY]: SERIALIZED_VALUE,\n      } as TOutput;\n    } catch {\n      // If this failed, then stringifying the object also failed, so we'll just\n      // return a completely generic error.\n      // Failing to stringify the object is very unlikely.\n      return {\n        name: \"Could not serialize source error\",\n        message: \"Serializing the source error failed.\",\n        stack: \"\",\n        [SERIALIZED_KEY]: SERIALIZED_VALUE,\n      } as TOutput;\n    }\n  }\n};\n\n/**\n * Check if an object or a string is a serialised error created by\n * {@link serializeError}.\n */\nexport const isSerializedError = (\n  value: unknown,\n): SerializedError | undefined => {\n  try {\n    if (typeof value === \"string\") {\n      const parsed = z\n        .object({\n          [SERIALIZED_KEY]: z.literal(SERIALIZED_VALUE),\n          name: z.enum([...Array.from(errorConstructors.keys())] as [\n            string,\n            ...string[],\n          ]),\n          message: z.string(),\n          stack: z.string(),\n        })\n        .passthrough()\n        .safeParse(JSON.parse(value));\n\n      if (parsed.success) {\n        return parsed.data as SerializedError;\n      }\n    }\n\n    if (typeof value === \"object\" && value !== null) {\n      const objIsSerializedErr =\n        Object.hasOwn(value, SERIALIZED_KEY) &&\n        (value as { [SERIALIZED_KEY]: unknown })[SERIALIZED_KEY] ===\n          SERIALIZED_VALUE;\n\n      if (objIsSerializedErr) {\n        return value as SerializedError;\n      }\n    }\n  } catch {\n    // no-op; we'll return undefined if parsing failed, as it isn't a serialized\n    // error\n  }\n\n  return;\n};\n\n/**\n * Deserialise an error created by {@link serializeError}.\n *\n * Ensures we only deserialise errors that meet a minimum level of\n * applicability, inclusive of error handling to ensure that badly serialized\n * errors are still handled.\n */\nexport const deserializeError = <\n  TAllowUnknown extends boolean = false,\n  TOutput extends TAllowUnknown extends true\n    ? unknown\n    : Error = TAllowUnknown extends true ? unknown : Error,\n>(\n  subject: Partial<SerializedError>,\n  allowUnknown: TAllowUnknown = false as TAllowUnknown,\n): TOutput => {\n  const requiredFields: (keyof SerializedError)[] = [\"name\", \"message\"];\n\n  try {\n    const hasRequiredFields = requiredFields.every((field) => {\n      return Object.hasOwn(subject, field);\n    });\n\n    if (!hasRequiredFields) {\n      throw new Error();\n    }\n\n    const deserializedErr = cjsDeserializeError(subject as SerializedError);\n\n    if (\"cause\" in deserializedErr) {\n      deserializedErr.cause = deserializeError(\n        deserializedErr.cause as Partial<SerializedError>,\n        true,\n      );\n    }\n\n    return deserializedErr as TOutput;\n  } catch {\n    if (allowUnknown) {\n      // If we are allowed to return unknown, we'll just return the original\n      // value.\n      return subject as TOutput;\n    }\n\n    const err = new Error(\"Unknown error; could not reserialize\");\n\n    /**\n     * Remove the stack so that it's not misleadingly shown as the Inngest\n     * internals.\n     */\n    err.stack = undefined;\n\n    return err as TOutput;\n  }\n};\n\nexport enum ErrCode {\n  NESTING_STEPS = \"NESTING_STEPS\",\n\n  /**\n   * Legacy v0 execution error code for when a function has changed and no\n   * longer matches its in-progress state.\n   *\n   * @deprecated Not for use in latest execution method.\n   */\n  NON_DETERMINISTIC_FUNCTION = \"NON_DETERMINISTIC_FUNCTION\",\n\n  /**\n   * Legacy v0 execution error code for when a function is found to be using\n   * async actions after memoziation has occurred, which v0 doesn't support.\n   *\n   * @deprecated Not for use in latest execution method.\n   */\n  ASYNC_DETECTED_AFTER_MEMOIZATION = \"ASYNC_DETECTED_AFTER_MEMOIZATION\",\n\n  /**\n   * Legacy v0 execution error code for when a function is found to be using\n   * steps after a non-step async action has occurred.\n   *\n   * @deprecated Not for use in latest execution method.\n   */\n  STEP_USED_AFTER_ASYNC = \"STEP_USED_AFTER_ASYNC\",\n\n  AUTOMATIC_PARALLEL_INDEXING = \"AUTOMATIC_PARALLEL_INDEXING\",\n}\n\nexport interface PrettyError {\n  /**\n   * The type of message, used to decide on icon and color use.\n   */\n  type?: \"error\" | \"warn\";\n\n  /**\n   * A short, succinct description of what happened. Will be used as the error's\n   * header, so should be short and to the point with no trailing punctuation.\n   */\n  whatHappened: string;\n\n  /**\n   * If applicable, provide a full sentence to reassure the user about certain\n   * details, for example if an error occurred whilst uploading a file, but we\n   * can assure the user that uploading succeeded and something internal failed.\n   */\n  reassurance?: string;\n\n  /**\n   * Tell the user why the error happened if we can. This should be a full\n   * sentence or paragraph that explains the error in more detail, for example\n   * to explain that a file failed to upload because it was too large and that\n   * the maximum size is 10MB.\n   */\n  why?: string;\n\n  /**\n   * If applicable, tell the user what the consequences of the error are, for\n   * example to tell them that their file was not uploaded and that they will\n   * need to try again.\n   */\n  consequences?: string;\n\n  /**\n   * If we can, tell the user what they can do to fix the error now. This should\n   * be a full sentence or paragraph that explains what the user can do to fix\n   * the error, for example to tell them to try uploading a smaller file or\n   * upgrade to a paid plan.\n   */\n  toFixNow?: string | string[];\n\n  /**\n   * If applicable, tell the user what to do if the error persists, they want\n   * more information, or the fix we've given them doesn't work.\n   *\n   * This should be a full sentence or paragraph, and will likely refer users\n   * to contact us for support, join our Discord, or read documentation.\n   */\n  otherwise?: string;\n\n  /**\n   * Add a stack trace to the message so that the user knows what line of code\n   * the error is in relation to.\n   */\n  stack?: true;\n\n  /**\n   * If applicable, provide a code that the user can use to reference the error\n   * when contacting support.\n   */\n  code?: ErrCode;\n}\n\nexport const prettyErrorSplitter =\n  \"=================================================\";\n\n/**\n * Given an unknown `err`, mutate it to minify any pretty errors that it\n * contains.\n */\nexport const minifyPrettyError = <T>(err: T): T => {\n  try {\n    if (!isError(err)) {\n      return err;\n    }\n\n    const isPrettyError = err.message.includes(prettyErrorSplitter);\n    if (!isPrettyError) {\n      return err;\n    }\n\n    const sanitizedMessage = stripAnsi(err.message);\n\n    const message =\n      sanitizedMessage.split(\"  \")[1]?.split(\"\\n\")[0]?.trim() || err.message;\n    const code =\n      sanitizedMessage.split(\"\\n\\nCode: \")[1]?.split(\"\\n\\n\")[0]?.trim() ||\n      undefined;\n\n    err.message = [code, message].filter(Boolean).join(\" - \");\n\n    if (err.stack) {\n      const sanitizedStack = stripAnsi(err.stack);\n      const stackRest = sanitizedStack\n        .split(`${prettyErrorSplitter}\\n`)\n        .slice(2)\n        .join(\"\\n\");\n\n      err.stack = `${err.name}: ${err.message}\\n${stackRest}`;\n    }\n\n    return err;\n  } catch (_noopErr) {\n    return err;\n  }\n};\n\n/**\n * Given an `err`, return a boolean representing whether it is in the shape of\n * an `Error` or not.\n */\nconst isError = (err: unknown): err is Error => {\n  try {\n    if (err instanceof Error) {\n      return true;\n    }\n\n    if (typeof err !== \"object\" || err === null) {\n      return false;\n    }\n\n    const hasName = Object.hasOwn(err, \"name\");\n    const hasMessage = Object.hasOwn(err, \"message\");\n\n    return hasName && hasMessage;\n  } catch (_noopErr) {\n    return false;\n  }\n};\n\n/**\n * Given an `unknown` object, retrieve the `message` property from it, or fall\n * back to the `fallback` string if it doesn't exist or is empty.\n */\nexport const getErrorMessage = (err: unknown, fallback: string): string => {\n  const { message } = z\n    .object({ message: z.string().min(1) })\n    .catch({ message: fallback })\n    .parse(err);\n\n  return message;\n};\n\n/**\n * Given a {@link PrettyError}, return a nicely-formatted string ready to log\n * or throw.\n *\n * Useful for ensuring that errors are logged in a consistent, helpful format\n * across the SDK by prompting for key pieces of information.\n */\nexport const prettyError = ({\n  type = \"error\",\n  whatHappened,\n  otherwise,\n  reassurance,\n  toFixNow,\n  why,\n  consequences,\n  stack,\n  code,\n}: PrettyError): string => {\n  const { icon, colorFn } = (\n    {\n      error: { icon: \"❌\", colorFn: chalk.red },\n      warn: { icon: \"⚠️\", colorFn: chalk.yellow },\n    } satisfies Record<\n      NonNullable<PrettyError[\"type\"]>,\n      { icon: string; colorFn: (s: string) => string }\n    >\n  )[type];\n\n  let header = `${icon}  ${chalk.bold.underline(whatHappened.trim())}`;\n  if (stack) {\n    header +=\n      \"\\n\" +\n      [...(new Error().stack?.split(\"\\n\").slice(1).filter(Boolean) || [])].join(\n        \"\\n\",\n      );\n  }\n\n  let toFixNowStr =\n    (Array.isArray(toFixNow)\n      ? toFixNow\n          .map((s) => s.trim())\n          .filter(Boolean)\n          .map((s, i) => `\\t${i + 1}. ${s}`)\n          .join(\"\\n\")\n      : toFixNow?.trim()) ?? \"\";\n\n  if (Array.isArray(toFixNow) && toFixNowStr) {\n    toFixNowStr = `To fix this, you can take one of the following courses of action:\\n\\n${toFixNowStr}`;\n  }\n\n  let body = [reassurance?.trim(), why?.trim(), consequences?.trim()]\n    .filter(Boolean)\n    .join(\" \");\n  body += body ? `\\n\\n${toFixNowStr}` : toFixNowStr;\n\n  const trailer = [otherwise?.trim()].filter(Boolean).join(\" \");\n\n  const message = [\n    prettyErrorSplitter,\n    header,\n    body,\n    trailer,\n    code ? `Code: ${code}` : \"\",\n    prettyErrorSplitter,\n  ]\n    .filter(Boolean)\n    .join(\"\\n\\n\");\n\n  return colorFn(message);\n};\n\nexport const fixEventKeyMissingSteps = [\n  \"Set the `INNGEST_EVENT_KEY` environment variable\",\n  `Pass a key to the \\`new Inngest()\\` constructor using the \\`${\n    \"eventKey\" satisfies keyof ClientOptions\n  }\\` option`,\n  `Use \\`inngest.${\"setEventKey\" satisfies keyof Inngest.Any}()\\` at runtime`,\n];\n\n/**\n * An error that, when thrown, indicates internally that an outgoing operation\n * contains an error.\n *\n * We use this because serialized `data` sent back to Inngest may differ from\n * the error instance itself due to middleware.\n *\n * @internal\n */\nexport class OutgoingResultError extends Error {\n  public readonly result: Pick<OutgoingOp, \"data\" | \"error\">;\n\n  constructor(result: Pick<OutgoingOp, \"data\" | \"error\">) {\n    super(\"OutgoingOpError\");\n    this.result = result;\n  }\n}\n\n/**\n * Create a function that will rethrow an error with a prefix added to the\n * message.\n *\n * Useful for adding context to errors that are rethrown.\n *\n * @example\n * ```ts\n * await doSomeAction().catch(rethrowError(\"Failed to do some action\"));\n * ```\n */\n// biome-ignore lint/suspicious/noExplicitAny: <explanation>\nexport const rethrowError = (prefix: string): ((err: any) => never) => {\n  return (err) => {\n    try {\n      err.message &&= `${prefix}; ${err.message}`;\n    } catch (_noopErr) {\n      // no-op\n    } finally {\n      // biome-ignore lint/correctness/noUnsafeFinally: <explanation>\n      throw err;\n    }\n  };\n};\n\n/**\n * Legacy v0 execution error for functions that don't support mixing steps and\n * regular async actions.\n */\nexport const functionStoppedRunningErr = (code: ErrCode) => {\n  return prettyError({\n    whatHappened: \"Your function was stopped from running\",\n    why: \"We detected a mix of asynchronous logic, some using step tooling and some not.\",\n    consequences:\n      \"This can cause unexpected behaviour when a function is paused and resumed and is therefore strongly discouraged; we stopped your function to ensure nothing unexpected happened!\",\n    stack: true,\n    toFixNow:\n      \"Ensure that your function is either entirely step-based or entirely non-step-based, by either wrapping all asynchronous logic in `step.run()` calls or by removing all `step.*()` calls.\",\n    otherwise:\n      \"For more information on why step functions work in this manner, see https://www.inngest.com/docs/functions/multi-step#gotchas\",\n    code,\n  });\n};\n"],"names":["serializeError","cjsSerializeError","target: unknown","deserializeError","requiredFields: (keyof SerializedError)[]","cjsDeserializeError"],"mappings":"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","debugId":null}},
    {"offset": {"line": 1188, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/inngest/types.js","sources":["file:///Users/harshitgangwar/Desktop/SkillForge/node_modules/src/types.ts"],"sourcesContent":["/**\n * Internal types and schemas used throughout the Inngest SDK.\n *\n * Note that types intended to be imported and utilized in userland code will be\n * exported from the main entrypoint of the SDK, `inngest`; importing types\n * directly from this file may result in breaking changes in non-major bumps as\n * only those exported from `inngest` are considered stable.\n *\n * @module\n */\n\nimport { z } from \"zod/v3\";\nimport type { EventSchemas } from \"./components/EventSchemas.ts\";\nimport type {\n  builtInMiddleware,\n  GetEvents,\n  Inngest,\n} from \"./components/Inngest.ts\";\nimport type { InngestFunction } from \"./components/InngestFunction.ts\";\nimport type { InngestFunctionReference } from \"./components/InngestFunctionReference.ts\";\nimport type {\n  ExtendSendEventWithMiddleware,\n  InngestMiddleware,\n} from \"./components/InngestMiddleware.ts\";\nimport type { createStepTools } from \"./components/InngestStepTools.ts\";\nimport type { internalEvents } from \"./helpers/consts.ts\";\nimport type {\n  AsTuple,\n  IsEqual,\n  IsNever,\n  Public,\n  Simplify,\n  WithoutInternal,\n} from \"./helpers/types.ts\";\nimport type { Logger } from \"./middleware/logger.ts\";\n\nconst baseJsonErrorSchema = z.object({\n  name: z.string().trim().optional(),\n  error: z.string().trim().optional(),\n  message: z.string().trim().optional(),\n  stack: z.string().trim().optional(),\n});\n\nconst maybeJsonErrorSchema: z.ZodType<{\n  name: string;\n  message: string;\n  stack?: string;\n  cause?: unknown;\n}> = z.lazy(() =>\n  z.object({\n    name: z.string().trim(),\n    message: z.string().trim(),\n    stack: z.string().trim().optional(),\n    cause: z.union([maybeJsonErrorSchema, z.unknown()]).optional(),\n  }),\n);\n\nexport type JsonError = z.infer<typeof baseJsonErrorSchema> & {\n  name: string;\n  message: string;\n  cause?: unknown;\n};\n\nexport const jsonErrorSchema = baseJsonErrorSchema\n  .extend({\n    cause: z.union([maybeJsonErrorSchema, z.unknown()]).optional(),\n  })\n  .passthrough()\n  .catch({})\n  .transform((val) => {\n    return {\n      ...val,\n      name: val.name || \"Error\",\n      message: val.message || val.error || \"Unknown error\",\n      stack: val.stack,\n    };\n  }) as z.ZodType<JsonError>;\n\n/**\n * The payload for an internal Inngest event that is sent when a function fails.\n *\n * @public\n */\nexport type FailureEventPayload<P extends EventPayload = EventPayload> = {\n  name: `${internalEvents.FunctionFailed}`;\n  data: {\n    function_id: string;\n    run_id: string;\n    error: z.output<typeof jsonErrorSchema>;\n    event: P;\n  };\n};\n\n/**\n * Context arguments specific to a failure event.\n *\n * @public\n */\nexport type FailureEventArgs<P extends EventPayload = EventPayload> = {\n  /**\n   * The event data present in the payload.\n   */\n  event: FailureEventPayload<P>;\n\n  /**\n   * The final error that caused this function to exhaust all retries.\n   */\n  error: Error;\n};\n\n/**\n * The payload for an internal Inngest event that is sent when a function\n * finishes, either by completing successfully or failing.\n *\n * @public\n */\nexport type FinishedEventPayload = {\n  name: `${internalEvents.FunctionFinished}`;\n  data: {\n    function_id: string;\n    run_id: string;\n    correlation_id?: string;\n  } & (\n    | {\n        error: z.output<typeof jsonErrorSchema>;\n      }\n    | {\n        result: unknown;\n      }\n  );\n};\n\n/**\n * The payload for an internal Inngest event that is sent when a function is\n * cancelled.\n */\nexport type CancelledEventPayload = {\n  name: `${internalEvents.FunctionCancelled}`;\n  data: {\n    function_id: string;\n    run_id: string;\n    correlation_id?: string;\n  };\n};\n\n/**\n * The payload for any generic function invocation event. In practice, the event\n * data will be more specific to the function being invoked.\n *\n * @public\n */\nexport type InvokedEventPayload = Simplify<\n  Omit<EventPayload, \"name\"> & {\n    name: `${internalEvents.FunctionInvoked}`;\n  }\n>;\n\n/**\n * The payload for the event sent to a function when it is triggered by a cron.\n *\n * @public\n */\nexport type ScheduledTimerEventPayload = Simplify<\n  Omit<EventPayload, \"name\" | \"data\" | \"id\"> & {\n    name: `${internalEvents.ScheduledTimer}`;\n    data: {\n      cron: string;\n    };\n    id: string;\n  }\n>;\n\n/**\n * Unique codes for the different types of operation that can be sent to Inngest\n * from SDK step functions.\n */\nexport enum StepOpCode {\n  WaitForSignal = \"WaitForSignal\",\n\n  WaitForEvent = \"WaitForEvent\",\n\n  /**\n   * Legacy equivalent to `\"StepRun\"`. Has mixed data wrapping (e.g. `data` or\n   * `data.data` depending on SDK version), so this is phased out in favour of\n   * `\"StepRun\"`, which never wraps.\n   *\n   * Note that it is still used for v0 executions for backwards compatibility.\n   *\n   * @deprecated Only used for v0 executions; use `\"StepRun\"` instead.\n   */\n  Step = \"Step\",\n  StepRun = \"StepRun\",\n  StepError = \"StepError\",\n  StepPlanned = \"StepPlanned\",\n  Sleep = \"Sleep\",\n\n  /**\n   * Used to signify that the executor has requested that a step run, but we\n   * could not find that step.\n   *\n   * This is likely indicative that a step was renamed or removed from the\n   * function.\n   */\n  StepNotFound = \"StepNotFound\",\n\n  InvokeFunction = \"InvokeFunction\",\n  AiGateway = \"AIGateway\",\n  Gateway = \"Gateway\",\n}\n\n/**\n * The shape of a single operation in a step function. Used to communicate\n * desired and received operations to Inngest.\n */\nexport type Op = {\n  /**\n   * The unique code for this operation.\n   */\n  op: StepOpCode;\n\n  /**\n   * The unhashed step name for this operation. This is a legacy field that is\n   * sometimes used for critical data, like the sleep duration for\n   * `step.sleep()`.\n   *\n   * @deprecated For display name, use `displayName` instead.\n   */\n  name?: string;\n\n  /**\n   * An optional name for this step that can be used to display in the Inngest\n   * UI.\n   */\n  displayName?: string;\n\n  /**\n   * Any additional data required for this operation to send to Inngest. This\n   * is not compared when confirming that the operation was completed; use `id`\n   * for this.\n   */\n  opts?: Record<string, unknown>;\n\n  /**\n   * Any data present for this operation. If data is present, this operation is\n   * treated as completed.\n   */\n  data?: unknown;\n\n  /**\n   * An error present for this operation. If an error is present, this operation\n   * is treated as completed, but failed. When this is read from the op stack,\n   * the SDK will throw the error via a promise rejection when it is read.\n   *\n   * This allows users to handle step failures using common tools such as\n   * try/catch or `.catch()`.\n   */\n  error?: unknown;\n};\n\nexport const incomingOpSchema = z.object({\n  id: z.string().min(1),\n  data: z.any().optional(),\n  error: z.any().optional(),\n  input: z.any().optional(),\n});\n\nexport type IncomingOp = z.output<typeof incomingOpSchema>;\n\n/**\n * The shape of a step operation that is sent to an Inngest Server from an SDK.\n *\n * @public\n */\nexport type OutgoingOp = Pick<\n  HashedOp,\n  \"id\" | \"op\" | \"name\" | \"opts\" | \"data\" | \"error\" | \"displayName\"\n>;\n\n/**\n * The shape of a hashed operation in a step function. Used to communicate\n * desired and received operations to Inngest.\n */\nexport type HashedOp = Op & {\n  /**\n   * The hashed identifier for this operation, used to confirm that the\n   * operation was completed when it is received from Inngest.\n   */\n  id: string;\n};\n\n/**\n * A helper type to represent a stack of operations that will accumulate\n * throughout a step function's run.  This stack contains an object of\n * op hashes to data.\n */\nexport type OpStack = IncomingOp[];\n\n/**\n * A function that can be used to submit an operation to Inngest internally.\n */\nexport type SubmitOpFn = (op: Op) => void;\n\n/**\n * A sleep-compatible time string such as `\"1h30m15s\"` that can be sent to\n * Inngest to sleep for a given amount of time.\n *\n * This type includes an empty string too, so make sure to exclude that via\n * `Exclude<TimeStr, \"\">` if you don't want to allow empty strings.\n *\n * @public\n */\nexport type TimeStr = `${`${number}w` | \"\"}${`${number}d` | \"\"}${\n  | `${number}h`\n  | \"\"}${`${number}m` | \"\"}${`${number}s` | \"\"}`;\n\nexport type TimeStrBatch = `${`${number}s`}`;\n\n/**\n * Mutates an {@link EventPayload} `T` to include invocation events.\n */\nexport type WithInvocation<T extends EventPayload> = Simplify<\n  { name: T[\"name\"] | `${internalEvents.FunctionInvoked}` } & Omit<T, \"name\">\n>;\n\n/**\n * Makes sure that all event names are stringified and not enums or other\n * values.\n */\ntype StringifyAllEvents<T> = {\n  [K in keyof T as `${K & string}`]: Simplify<\n    Omit<T[K], \"name\"> & { name: `${K & string}` }\n  >;\n};\n\n/**\n * Given a client and a set of triggers, returns a record of all the events that\n * can be used to trigger a function. This will also include invocation events,\n * which currently could represent any of the triggers.\n */\ntype GetSelectedEvents<\n  TClient extends Inngest.Any,\n  TTriggers extends TriggersFromClient<TClient>,\n> = Pick<GetEvents<TClient, true>, TTriggers> &\n  StringifyAllEvents<{\n    // Invocation events could (currently) represent any of the payloads that\n    // could be used to trigger the function. We use a distributive `Pick` over allto\n    // ensure this is represented correctly in typing.\n    [internalEvents.FunctionInvoked]: Simplify<{\n      name: `${internalEvents.FunctionInvoked}`;\n    }> &\n      Pick<\n        Pick<GetEvents<TClient, true>, TTriggers>[keyof Pick<\n          GetEvents<TClient, true>,\n          TTriggers\n        >],\n        AssertKeysAreFrom<EventPayload, \"id\" | \"data\" | \"user\" | \"v\" | \"ts\">\n      >;\n  }>;\n\n/**\n * Returns a union of all the events that can be used to trigger a function\n * based on the given `TClient` and `TTriggers`.\n *\n * Can optionally include or exclude internal events with `TExcludeInternal`.\n */\ntype GetContextEvents<\n  TClient extends Inngest.Any,\n  TTriggers extends TriggersFromClient<TClient>,\n  TExcludeInternal extends boolean = false,\n  // TInvokeSchema extends ValidSchemaInput = never,\n> = Simplify<\n  TExcludeInternal extends true\n    ? WithoutInternal<\n        GetSelectedEvents<TClient, TTriggers>\n      >[keyof WithoutInternal<GetSelectedEvents<TClient, TTriggers>>]\n    : GetSelectedEvents<TClient, TTriggers>[keyof GetSelectedEvents<\n        TClient,\n        TTriggers\n      >]\n>;\n\n/**\n * Base context object, omitting any extras that may be added by middleware or\n * function configuration.\n *\n * @public\n */\nexport type BaseContext<\n  TClient extends Inngest.Any,\n  TTriggers extends TriggersFromClient<TClient> = TriggersFromClient<TClient>,\n> = {\n  /**\n   * The event data present in the payload.\n   */\n  event: GetContextEvents<TClient, TTriggers>;\n  events: AsTuple<GetContextEvents<TClient, TTriggers, true>>;\n\n  /**\n   * The run ID for the current function execution\n   */\n  runId: string;\n\n  step: ReturnType<typeof createStepTools<TClient>>;\n\n  /**\n   * The current zero-indexed attempt number for this function execution. The\n   * first attempt will be `0`, the second `1`, and so on. The attempt number\n   * is incremented every time the function throws an error and is retried.\n   */\n  attempt: number;\n};\n\n/**\n * Builds a context object for an Inngest handler, optionally overriding some\n * keys.\n *\n * @internal\n */\nexport type Context<\n  TClient extends Inngest.Any = Inngest.Any,\n  TTriggers extends TriggersFromClient<TClient> = TriggersFromClient<TClient>,\n  TOverrides extends Record<string, unknown> = Record<never, never>,\n> = Omit<BaseContext<TClient, TTriggers>, keyof TOverrides> & TOverrides;\n\n/**\n * Builds a context object for an Inngest handler, optionally overriding some\n * keys.\n *\n * @internal\n */\nexport namespace Context {\n  /**\n   * Represents any `Context` object, regardless of generics and inference.\n   */\n  export type Any = Context;\n}\n\n/**\n * The shape of a Inngest function, taking in event, step, ctx, and step\n * tooling.\n *\n * @public\n */\nexport type Handler<\n  TClient extends Inngest.Any,\n  TTriggers extends TriggersFromClient<TClient> = TriggersFromClient<TClient>,\n  TOverrides extends Record<string, unknown> = Record<never, never>,\n> = (\n  /**\n   * The context argument provides access to all data and tooling available to\n   * the function.\n   */\n  ctx: Context<TClient, TTriggers, TOverrides>,\n) => unknown;\n\nexport type TriggersFromClient<TClient extends Inngest.Any = Inngest.Any> =\n  keyof GetEvents<TClient, true> & string;\n\n/**\n * The shape of a Inngest function, taking in event, step, ctx, and step\n * tooling.\n *\n * @public\n */\nexport namespace Handler {\n  /**\n   * Represents any `Handler`, regardless of generics and inference.\n   */\n  // biome-ignore lint/suspicious/noExplicitAny: <explanation>\n  export type Any = Handler<Inngest.Any, any, any>;\n}\n\n/**\n * Asserts that the given keys `U` are all present in the given object `T`.\n *\n * Used as an internal type guard to ensure that changes to keys are accounted\n * for\n */\ntype AssertKeysAreFrom<T, K extends keyof T> = K;\n\n/**\n * The shape of a single event's payload without any fields used to identify the\n * actual event being sent.\n *\n * This is used to represent an event payload when invoking a function, as the\n * event name is not known or needed.\n */\n// biome-ignore lint/suspicious/noExplicitAny: <explanation>\nexport interface MinimalEventPayload<TData = any> {\n  /**\n   * A unique id used to idempotently process a given event payload.\n   *\n   * Set this when sending events to ensure that the event is only processed\n   * once; if an event with the same ID is sent again, it will not invoke\n   * functions.\n   */\n  id?: string;\n\n  /**\n   * Any data pertinent to the event\n   */\n  data?: TData;\n\n  /**\n   * Any user data associated with the event\n   * All fields ending in \"_id\" will be used to attribute the event to a particular user\n   */\n  // biome-ignore lint/suspicious/noExplicitAny: <explanation>\n  user?: any;\n\n  /**\n   * A specific event schema version\n   * (optional)\n   */\n  v?: string;\n}\n\n/**\n * The shape of a single event's payload. It should be extended to enforce\n * adherence to given events and not used as a method of creating them (i.e. as\n * a generic).\n *\n * @public\n */\n// biome-ignore lint/suspicious/noExplicitAny: <explanation>\nexport interface EventPayload<TData = any> extends MinimalEventPayload<TData> {\n  /**\n   * A unique identifier for the type of event. We recommend using lowercase dot\n   * notation for names, prepending `prefixes/` with a slash for organization.\n   *\n   * e.g. `cloudwatch/alarms/triggered`, `cart/session.created`\n   */\n  name: string;\n\n  /**\n   * An integer representing the milliseconds since the unix epoch at which this\n   * event occurred.\n   *\n   * Defaults to the current time.\n   * (optional)\n   */\n  ts?: number;\n}\n\nexport const sendEventResponseSchema = z.object({\n  /**\n   * Event IDs\n   */\n  ids: z.array(z.string()).default([]),\n\n  /**\n   * HTTP Status Code. Will be undefined if no request was sent.\n   */\n  status: z.number().default(0),\n\n  /**\n   * Error message. Will be undefined if no error occurred.\n   */\n  error: z.string().optional(),\n});\n\n/**\n * The response from the Inngest Event API\n */\nexport type SendEventResponse = z.output<typeof sendEventResponseSchema>;\n\n/**\n * The response in code from sending an event to Inngest.\n *\n * @public\n */\nexport type SendEventBaseOutput = {\n  ids: SendEventResponse[\"ids\"];\n};\n\nexport type SendEventOutput<TOpts extends ClientOptions> = Omit<\n  SendEventBaseOutput,\n  keyof SendEventOutputWithMiddleware<TOpts>\n> &\n  SendEventOutputWithMiddleware<TOpts>;\n\nexport type SendEventOutputWithMiddleware<TOpts extends ClientOptions> =\n  ExtendSendEventWithMiddleware<\n    [typeof builtInMiddleware, NonNullable<TOpts[\"middleware\"]>],\n    SendEventBaseOutput\n  >;\n\n/**\n * An HTTP-like, standardised response format that allows Inngest to help\n * orchestrate steps and retries.\n *\n * @internal\n */\nexport interface Response {\n  /**\n   * A step response must contain an HTTP status code.\n   *\n   * A `2xx` response indicates success; this is not a failure and no retry is\n   * necessary.\n   *\n   * A `4xx` response indicates a bad request; this step will not be retried as\n   * it is deemed irrecoverable. Examples of this might be an event with\n   * insufficient data or concerning a user that no longer exists.\n   *\n   * A `5xx` status indicates a temporary internal error; this will be retried\n   * according to the step and function's retry policy (3 times, by default).\n   *\n   * {@link https://www.inngest.com/docs/functions/function-input-and-output#response-format}\n   * {@link https://www.inngest.com/docs/functions/retries}\n   */\n  status: number;\n\n  /**\n   * The output of the function - the `body` - can be any arbitrary\n   * JSON-compatible data. It is then usable by any future steps.\n   *\n   * {@link https://www.inngest.com/docs/functions/function-input-and-output#response-format}\n   */\n  body?: unknown;\n}\n\n/**\n * A single step within a function.\n *\n * @internal\n */\nexport type Step<TContext = unknown> = (\n  /**\n   * The context for this step, including the triggering event and any previous\n   * step output.\n   */\n  context: TContext,\n) => Promise<Response> | Response;\n\n/**\n * A set of options for configuring the Inngest client.\n *\n * @public\n */\nexport interface ClientOptions {\n  /**\n   * The ID of this instance, most commonly a reference to the application it\n   * resides in.\n   *\n   * The ID of your client should remain the same for its lifetime; if you'd\n   * like to change the name of your client as it appears in the Inngest UI,\n   * change the `name` property instead.\n   */\n  id: string;\n\n  /**\n   * Inngest event key, used to send events to Inngest Cloud. If not provided,\n   * will search for the `INNGEST_EVENT_KEY` environment variable. If neither\n   * can be found, however, a warning will be shown and any attempts to send\n   * events will throw an error.\n   */\n  eventKey?: string;\n\n  /**\n   * The base URL to use when contacting Inngest.\n   *\n   * Defaults to https://inn.gs/ for sending events and https://api.inngest.com\n   * for all other communication with Inngest.\n   */\n  baseUrl?: string;\n\n  /**\n   * If provided, will override the used `fetch` implementation. Useful for\n   * giving the library a particular implementation if accessing it is not done\n   * via globals.\n   *\n   * By default the library will try to use the native Web API fetch, falling\n   * back to a Node implementation if no global fetch can be found.\n   *\n   * If you wish to specify your own fetch, make sure that you preserve its\n   * binding, either by using `.bind` or by wrapping it in an anonymous\n   * function.\n   */\n  fetch?: typeof fetch;\n\n  /**\n   * Provide an `EventSchemas` class to type events, providing type safety when\n   * sending events and running functions via Inngest.\n   *\n   * You can provide generated Inngest types, custom types, types using Zod, or\n   * a combination of the above. See {@link EventSchemas} for more information.\n   *\n   * @example\n   *\n   * ```ts\n   * export const inngest = new Inngest({\n   *   id: \"my-app\",\n   *   schemas: new EventSchemas().fromZod({\n   *     \"app/user.created\": {\n   *       data: z.object({\n   *         id: z.string(),\n   *         name: z.string(),\n   *       }),\n   *     },\n   *   }),\n   * });\n   * ```\n   */\n  schemas?: EventSchemas<Record<string, EventPayload>>;\n\n  /**\n   * The Inngest environment to send events to. Defaults to whichever\n   * environment this client's event key is associated with.\n   *\n   * It's likely you never need to change this unless you're trying to sync\n   * multiple systems together using branch names.\n   */\n  env?: string;\n\n  /**\n   * The logger provided by the user.\n   * The user can passed in their winston, pino, and other loggers for\n   * handling log delivery to external services.\n   *\n   * The provider logger is expected to implement the following API interfaces\n   * - .info()\n   * - .warn()\n   * - .debug()\n   * - .error()\n   * which most loggers already do.\n   *\n   * Defaults to a dummy logger that just log things to the console if nothing is provided.\n   */\n  logger?: Logger;\n  middleware?: InngestMiddleware.Stack;\n\n  /**\n   * Can be used to explicitly set the client to Development Mode, which will\n   * turn off signature verification and default to using a local URL to access\n   * a local Dev Server.\n   *\n   * This is useful for forcing the client to use a local Dev Server while also\n   * running in a production-like environment.\n   */\n  isDev?: boolean;\n\n  /**\n   * The application-specific version identifier. This can be an arbitrary value\n   * such as a version string, a Git commit SHA, or any other unique identifier.\n   */\n  appVersion?: string;\n\n  /**\n   * If `true`, parallel steps within functions are optimized to reduce traffic\n   * during `Promise` resolution, which can hugely reduce the time taken and\n   * number of requests for each run.\n   *\n   * Note that this will be the default behaviour in v4 and in its current form\n   * will cause `Promise.*()` to wait for all promises to settle before\n   * resolving.\n   *\n   * @default false\n   */\n  optimizeParallelism?: boolean;\n}\n\n/**\n * A set of log levels that can be used to control the amount of logging output\n * from various parts of the Inngest library.\n *\n * @public\n */\nexport const logLevels = [\n  \"fatal\",\n  \"error\",\n  \"warn\",\n  \"info\",\n  \"debug\",\n  \"silent\",\n] as const;\n\n/**\n * A set of log levels that can be used to control the amount of logging output\n * from various parts of the Inngest library.\n *\n * @public\n */\nexport type LogLevel = (typeof logLevels)[number];\n\n/**\n * A set of options for configuring the registration of Inngest functions.\n *\n * @public\n */\nexport interface RegisterOptions {\n  /**\n   * A key used to sign requests to and from Inngest in order to prove that the\n   * source is legitimate.\n   *\n   * You must provide a signing key to communicate securely with Inngest. If\n   * your key is not provided here, we'll try to retrieve it from the\n   * `INNGEST_SIGNING_KEY` environment variable.\n   *\n   * You can retrieve your signing key from the Inngest UI inside the \"Secrets\"\n   * section at {@link https://app.inngest.com/secrets}. We highly recommend\n   * that you add this to your platform's available environment variables as\n   * `INNGEST_SIGNING_KEY`.\n   *\n   * If no key can be found, you will not be able to register your functions or\n   * receive events from Inngest.\n   */\n  signingKey?: string;\n\n  /**\n   * The same as signingKey, except used as a fallback when auth fails using the\n   * primary signing key.\n   */\n  signingKeyFallback?: string;\n\n  /**\n   * The URL used to register functions with Inngest.\n   * Defaults to https://api.inngest.com/fn/register\n   */\n  baseUrl?: string;\n\n  /**\n   * If provided, will override the used `fetch` implementation. Useful for\n   * giving the library a particular implementation if accessing it is not done\n   * via globals.\n   *\n   * By default the library will try to use the native Web API fetch, falling\n   * back to a Node implementation if no global fetch can be found.\n   */\n  fetch?: typeof fetch;\n\n  /**\n   * The path to the Inngest serve endpoint. e.g.:\n   *\n   *     \"/some/long/path/to/inngest/endpoint\"\n   *\n   * By default, the library will try to infer this using request details such\n   * as the \"Host\" header and request path, but sometimes this isn't possible\n   * (e.g. when running in a more controlled environments such as AWS Lambda or\n   * when dealing with proxies/rediects).\n   *\n   * Provide the custom path (excluding the hostname) here to ensure that the\n   * path is reported correctly when registering functions with Inngest.\n   *\n   * To also provide a custom hostname, use `serveHost`.\n   */\n  servePath?: string;\n\n  /**\n   * The host used to access the Inngest serve endpoint, e.g.:\n   *\n   *     \"https://myapp.com\"\n   *\n   * By default, the library will try to infer this using request details such\n   * as the \"Host\" header and request path, but sometimes this isn't possible\n   * (e.g. when running in a more controlled environments such as AWS Lambda or\n   * when dealing with proxies/redirects).\n   *\n   * Provide the custom hostname here to ensure that the path is reported\n   * correctly when registering functions with Inngest.\n   *\n   * To also provide a custom path, use `servePath`.\n   */\n  serveHost?: string;\n\n  /**\n   * The minimum level to log from the Inngest serve endpoint.\n   *\n   * Default level: \"info\"\n   */\n  logLevel?: LogLevel;\n\n  /**\n   * Some serverless providers (especially those with edge compute) may support\n   * streaming responses back to Inngest. This can be used to circumvent\n   * restrictive request timeouts and other limitations. It is only available if\n   * the serve handler being used supports streaming.\n   *\n   * If this is `\"allow\"`, the SDK will attempt to stream responses back to\n   * Inngest if it can confidently detect support for it by verifyng that the\n   * platform and the serve handler supports streaming.\n   *\n   * If this is `\"force\"`, the SDK will always attempt to stream responses back\n   * to Inngest regardless of whether we can detect support for it or not. This\n   * will override `allowStreaming`, but will still not attempt to stream if\n   * the serve handler does not support it.\n   *\n   * If this is `false`, streaming will never be used.\n   *\n   * Defaults to `false`.\n   */\n  streaming?: \"allow\" | \"force\" | false;\n\n  /**\n   * The ID of this app. This is used to group functions together in the Inngest\n   * UI. The ID of the passed client is used by default.\n   * @deprecated Will be removed in v4.\n   */\n  id?: string;\n}\n\n/**\n * This schema is used internally to share the shape of a concurrency option\n * when validating config. We cannot add comments to Zod fields, so we just use\n * an extra type check to ensure it matches our exported expectations.\n */\nconst concurrencyOptionSchema = z.strictObject({\n  limit: z.number(),\n  key: z.string().optional(),\n  scope: z.enum([\"fn\", \"env\", \"account\"]).optional(),\n});\n\nconst _checkConcurrencySchemaAligns: IsEqual<\n  ConcurrencyOption,\n  z.output<typeof concurrencyOptionSchema>\n> = true;\n\nexport interface ConcurrencyOption {\n  /**\n   * The concurrency limit for this option, adding a limit on how many concurrent\n   * steps can execute at once.\n   */\n  limit: number;\n\n  /**\n   * An optional concurrency key, as an expression using the common expression language\n   * (CEL).  The result of this expression is used to create new concurrency groups, or\n   * sub-queues, for each function run.\n   *\n   * The event is passed into this expression as \"event\".\n   *\n   * Examples:\n   * - `event.data.user_id`:  this evaluates to the user_id in the event.data object.\n   * - `event.data.user_id + \"-\" + event.data.account_id`: creates a new group per user/account\n   * - `\"ai\"`:  references a custom string\n   */\n  key?: string;\n\n  /**\n   * An optional scope for the concurrency group.  By default, concurrency limits are\n   * scoped to functions - one function's concurrency limits do not impact other functions.\n   *\n   * Changing this \"scope\" allows concurrency limits to work across environments (eg. production\n   * vs branch environments) or across your account (global).\n   */\n  scope?: \"fn\" | \"env\" | \"account\";\n}\n\n/**\n * Configuration for cancelling a function run based on an incoming event.\n *\n * @public\n */\nexport type Cancellation<Events extends Record<string, EventPayload>> = {\n  [K in keyof Events & string]: {\n    /**\n     * The name of the event that should cancel the function run.\n     */\n    event: K;\n\n    /**\n     * The expression that must evaluate to true in order to cancel the function run. There\n     * are two variables available in this expression:\n     * - event, referencing the original function's event trigger\n     * - async, referencing the new cancel event.\n     *\n     * @example\n     *\n     * Ensures the cancel event's data.user_id field matches the triggering event's data.user_id\n     * field:\n     *\n     * ```ts\n     * \"async.data.user_id == event.data.user_id\"\n     * ```\n     */\n    if?: string;\n\n    /**\n     * If provided, the step function will wait for the incoming event to match\n     * particular criteria. If the event does not match, it will be ignored and\n     * the step function will wait for another event.\n     *\n     * It must be a string of a dot-notation field name within both events to\n     * compare, e.g. `\"data.id\"` or `\"user.email\"`.\n     *\n     * ```\n     * // Wait for an event where the `user.email` field matches\n     * match: \"user.email\"\n     * ```\n     *\n     * All of these are helpers for the `if` option, which allows you to specify\n     * a custom condition to check. This can be useful if you need to compare\n     * multiple fields or use a more complex condition.\n     *\n     * See the Inngest expressions docs for more information.\n     *\n     * {@link https://www.inngest.com/docs/functions/expressions}\n     *\n     * @deprecated Use `if` instead.\n     */\n    match?: string;\n\n    /**\n     * An optional timeout that the cancel is valid for.  If this isn't\n     * specified, cancellation triggers are valid for up to a year or until the\n     * function ends.\n     *\n     * The time to wait can be specified using a `number` of milliseconds, an\n     * `ms`-compatible time string like `\"1 hour\"`, `\"30 mins\"`, or `\"2.5d\"`, or\n     * a `Date` object.\n     *\n     * {@link https://npm.im/ms}\n     */\n    timeout?: number | string | Date;\n  };\n}[keyof Events & string];\n\n/**\n * The response to send to Inngest when pushing function config either directly\n * or when pinged by Inngest Cloud.\n *\n * @internal\n */\nexport interface RegisterRequest {\n  /**\n   * The API handler's URL to invoke SDK based functions.\n   */\n  url: string;\n\n  /**\n   * Response version, allowing Inngest to change any top-level field.\n   */\n  v: `${number}.${number}`;\n\n  /**\n   * SDK version from `package.json` for our internal metrics and to warn users\n   * they need to upgrade.\n   */\n  sdk: `js:v${number}.${number}.${number}${\"\" | `-${string}.${number}`}`;\n\n  /**\n   * The method used to deploy these functions.\n   */\n  deployType: \"ping\";\n\n  /**\n   * The name of the framework being used for this instance, e.g. \"nextjs\",\n   * \"vercel\", \"netlify\", \"lambda\", etc. Uses the `framework` specified when\n   * creating a new `InngestCommHandler`.\n   */\n  framework: string;\n\n  /**\n   * The name of this particular app, used for grouping and easier viewing in\n   * the UI.\n   */\n  appName: string;\n\n  /**\n   * AppVersion represents an optional application version identifier. This should change\n   * whenever code within one of your Inngest function or any dependency thereof changes.\n   */\n  appVersion?: string;\n\n  /**\n   * The functions available at this particular handler.\n   */\n  functions: FunctionConfig[];\n\n  /**\n   * The deploy ID used to identify this particular deployment.\n   */\n  deployId?: string;\n\n  /**\n   * Capabilities of the SDK.\n   */\n  capabilities: Capabilities;\n}\n\nexport interface Capabilities {\n  trust_probe: \"v1\";\n  connect: \"v1\";\n}\n\nexport interface InBandRegisterRequest\n  extends Pick<\n      RegisterRequest,\n      \"capabilities\" | \"framework\" | \"functions\" | \"sdk\" | \"url\" | \"appVersion\"\n    >,\n    Pick<AuthenticatedIntrospection, \"sdk_language\" | \"sdk_version\" | \"env\"> {\n  /**\n   * The ID of the app that this handler is associated with.\n   */\n  app_id: string;\n\n  /**\n   * The result of the introspection request.\n   */\n  inspection: AuthenticatedIntrospection | UnauthenticatedIntrospection;\n\n  /**\n   * ?\n   */\n  platform?: string;\n\n  /**\n   * The person or organization that authored this SDK. Ideally this is\n   * synonymous with a GitHub username or organization name.\n   */\n  sdk_author: \"inngest\";\n}\n\n/**\n * The response to send to the local SDK UI when an introspection request is\n * made.\n *\n * @internal\n */\nexport interface UnauthenticatedIntrospection {\n  authentication_succeeded: false | null;\n  extra: {\n    is_mode_explicit: boolean;\n  };\n  function_count: number;\n  has_event_key: boolean;\n  has_signing_key: boolean;\n  mode: \"cloud\" | \"dev\";\n  schema_version: \"2024-05-24\";\n}\n\nexport interface AuthenticatedIntrospection\n  extends Omit<UnauthenticatedIntrospection, \"authentication_succeeded\"> {\n  api_origin: string;\n  app_id: string;\n  authentication_succeeded: true;\n  capabilities: Capabilities;\n  env: string | null;\n  event_api_origin: string;\n  event_key_hash: string | null;\n  extra: UnauthenticatedIntrospection[\"extra\"] & {\n    is_streaming: boolean;\n  };\n  framework: string;\n  sdk_language: string;\n  sdk_version: string;\n  serve_origin: string | null;\n  serve_path: string | null;\n  signing_key_fallback_hash: string | null;\n  signing_key_hash: string | null;\n}\n\n/**\n * The schema used to represent an individual function being synced with\n * Inngest.\n *\n * Note that this should only be used to validate the shape of a config object\n * and not used for feature compatibility, such as feature X being exclusive\n * with feature Y; these should be handled on the Inngest side.\n */\nexport const functionConfigSchema = z.strictObject({\n  name: z.string().optional(),\n  id: z.string(),\n  triggers: z.array(\n    z.union([\n      z.strictObject({\n        event: z.string(),\n        expression: z.string().optional(),\n      }),\n      z.strictObject({\n        cron: z.string(),\n      }),\n    ]),\n  ),\n  steps: z.record(\n    z.strictObject({\n      id: z.string(),\n      name: z.string(),\n      runtime: z.strictObject({\n        type: z.union([z.literal(\"http\"), z.literal(\"ws\")]),\n        url: z.string(),\n      }),\n      retries: z\n        .strictObject({\n          attempts: z.number().optional(),\n        })\n        .optional(),\n    }),\n  ),\n  idempotency: z.string().optional(),\n  batchEvents: z\n    .strictObject({\n      maxSize: z.number(),\n      timeout: z.string(),\n      key: z.string().optional(),\n      if: z.string().optional(),\n    })\n    .optional(),\n  rateLimit: z\n    .strictObject({\n      key: z.string().optional(),\n      limit: z.number(),\n      period: z.string().transform((x) => x as TimeStr),\n    })\n    .optional(),\n  throttle: z\n    .strictObject({\n      key: z.string().optional(),\n      limit: z.number(),\n      period: z.string().transform((x) => x as TimeStr),\n      burst: z.number().optional(),\n    })\n    .optional(),\n  singleton: z\n    .strictObject({\n      key: z.string().optional(),\n      mode: z.enum([\"skip\", \"cancel\"]),\n    })\n    .optional(),\n  cancel: z\n    .array(\n      z.strictObject({\n        event: z.string(),\n        if: z.string().optional(),\n        timeout: z.string().optional(),\n      }),\n    )\n    .optional(),\n  debounce: z\n    .strictObject({\n      key: z.string().optional(),\n      period: z.string().transform((x) => x as TimeStr),\n      timeout: z\n        .string()\n        .transform((x) => x as TimeStr)\n        .optional(),\n    })\n    .optional(),\n  timeouts: z\n    .strictObject({\n      start: z\n        .string()\n        .transform((x) => x as TimeStr)\n        .optional(),\n      finish: z\n        .string()\n        .transform((x) => x as TimeStr)\n        .optional(),\n    })\n    .optional(),\n  priority: z\n    .strictObject({\n      run: z.string().optional(),\n    })\n    .optional(),\n  concurrency: z\n    .union([\n      z.number(),\n      concurrencyOptionSchema.transform((x) => x as ConcurrencyOption),\n      z\n        .array(concurrencyOptionSchema.transform((x) => x as ConcurrencyOption))\n        .min(1)\n        .max(2),\n    ])\n    .optional(),\n});\n\n/**\n * The shape of an individual function being synced with Inngest.\n *\n * @internal\n */\nexport type FunctionConfig = z.output<typeof functionConfigSchema>;\n\nexport interface DevServerInfo {\n  /**\n   * The version of the dev server.\n   */\n  version: string;\n  authed: boolean;\n  startOpts: {\n    dir?: string;\n    autodiscover: boolean;\n    urls: string[];\n  };\n  functions: FunctionConfig[];\n  handlers: RegisterRequest[];\n}\n\n/**\n * Given a set of events and a user-friendly trigger paramter, returns the name\n * of the event that the user intends to listen to.\n *\n * @public\n */\nexport type EventNameFromTrigger<\n  Events extends Record<string, EventPayload>,\n  T extends InngestFunction.Trigger<keyof Events & string>,\n> = IsNever<T> extends true // `never` indicates there are no triggers, so the payload could be anything\n  ? `${internalEvents.FunctionInvoked}`\n  : T extends string // `string` indicates a migration from v2 to v3\n    ? T\n    : T extends { event: infer IEvent } // an event trigger\n      ? IEvent\n      : T extends { cron: string } // a cron trigger\n        ? `${internalEvents.ScheduledTimer}`\n        : never;\n\n/**\n * A union to represent known names of supported frameworks that we can use\n * internally to assess functionality based on a mix of framework and platform.\n */\nexport type SupportedFrameworkName =\n  | \"astro\"\n  | \"bun\"\n  | \"cloudflare-pages\"\n  | \"digitalocean\"\n  | \"edge\"\n  | \"express\"\n  | \"aws-lambda\"\n  | \"nextjs\"\n  | \"nodejs\"\n  | \"nuxt\"\n  | \"h3\"\n  | \"redwoodjs\"\n  | \"remix\"\n  | \"deno/fresh\"\n  | \"sveltekit\"\n  | \"fastify\"\n  | \"koa\"\n  | \"hono\"\n  | \"nitro\";\n\n/**\n * A set of options that can be passed to any step to configure it.\n *\n * @public\n */\nexport interface StepOptions {\n  /**\n   * The ID to use to memoize the result of this step, ensuring it is run only\n   * once. Changing this ID in an existing function will cause the step to be\n   * run again for in-progress runs; it is recommended to use a stable ID.\n   */\n  id: string;\n\n  /**\n   * The display name to use for this step in the Inngest UI. This can be\n   * changed at any time without affecting the step's behaviour.\n   */\n  name?: string;\n}\n\n/**\n * Either a step ID or a set of step options.\n *\n * @public\n */\nexport type StepOptionsOrId = StepOptions[\"id\"] | StepOptions;\n\nexport type EventsFromFunction<T extends InngestFunction.Any> =\n  // biome-ignore lint/suspicious/noExplicitAny: <explanation>\n  T extends InngestFunction<any, any, any, infer IClient, any, any>\n    ? GetEvents<IClient, true>\n    : never;\n\n/**\n * A function that can be invoked by Inngest.\n *\n * @public\n */\nexport type InvokeTargetFunctionDefinition =\n  | Public<InngestFunctionReference.Any>\n  | Public<InngestFunction.Any>\n  | string;\n\n/**\n * Given an invocation target, extract the payload that will be used to trigger\n * it.\n *\n * If we could not find a payload, will return `never`.\n */\nexport type TriggerEventFromFunction<\n  TFunction extends InvokeTargetFunctionDefinition,\n> = TFunction extends InngestFunction.Any\n  ? PayloadForAnyInngestFunction<TFunction>\n  : TFunction extends InngestFunctionReference<\n        infer IInput extends MinimalEventPayload,\n        // biome-ignore lint/suspicious/noExplicitAny: <explanation>\n        any\n      >\n    ? IInput\n    : MinimalEventPayload;\n\n/**\n * Given an {@link InngestFunction} instance, extract the {@link MinimalPayload}\n * that will be used to trigger it.\n *\n * This is intended to see what **input** a developer is expected to give to\n * invoke a function; it should not be used for evaluating the payload received\n * inside an invoked function.\n *\n * If we could not find a payload or the function does not require a payload\n * (e.g. a cron), then will return `{}`, as this is intended to be used to\n * spread into other arguments.\n *\n * @internal\n */\nexport type PayloadForAnyInngestFunction<\n  TFunction extends InngestFunction.Any,\n  TEvents extends Record<\n    string,\n    EventPayload\n  > = TFunction extends InngestFunction.Any\n    ? EventsFromFunction<TFunction>\n    : never,\n> = TFunction extends InngestFunction<\n  // biome-ignore lint/suspicious/noExplicitAny: <explanation>\n  any,\n  // biome-ignore lint/suspicious/noExplicitAny: <explanation>\n  any,\n  // biome-ignore lint/suspicious/noExplicitAny: <explanation>\n  any,\n  // biome-ignore lint/suspicious/noExplicitAny: <explanation>\n  any,\n  // biome-ignore lint/suspicious/noExplicitAny: <explanation>\n  any,\n  infer ITriggers extends InngestFunction.Trigger<keyof TEvents & string>[]\n>\n  ? IsEqual<\n      TEvents[EventNameFromTrigger<TEvents, ITriggers[number]>][\"name\"],\n      `${internalEvents.ScheduledTimer}`\n    > extends true\n    ? object // If this is ONLY a cron trigger, then we don't need to provide a payload\n    : Simplify<\n        Omit<\n          TEvents[EventNameFromTrigger<TEvents, ITriggers[number]>],\n          \"name\" | \"ts\"\n        >\n      >\n  : never;\n\nexport type InvocationResult<TReturn> = Promise<TReturn>;\n// TODO Types ready for when we expand this.\n// & {\n//   result: InvocationResult<TReturn>;\n//   cancel: (reason: string) => Promise<void>; // TODO Need to be a Promise? 🤔\n//   queued: Promise<{ runId: string }>;\n// };\n\n/**\n * Simplified version of Rust style `Result`\n *\n * Make it easier to wrap functions with some kind of result.\n * e.g. API calls\n */\nexport type Result<T, E = undefined> =\n  | { ok: true; value: T }\n  | { ok: false; error: E | undefined };\n\nexport const ok = <T>(data: T): Result<T, never> => {\n  return { ok: true, value: data };\n};\n\nexport const err = <E>(error?: E): Result<never, E> => {\n  return { ok: false, error };\n};\n\nexport const inBandSyncRequestBodySchema = z.strictObject({\n  url: z.string(),\n});\n"],"names":["maybeJsonErrorSchema: z.ZodType<{\n  name: string;\n  message: string;\n  stack?: string;\n  cause?: unknown;\n}>"],"mappings":"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","debugId":null}},
    {"offset": {"line": 1425, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/inngest/components/execution/InngestExecution.js","sources":["file:///Users/harshitgangwar/Desktop/SkillForge/node_modules/src/components/execution/InngestExecution.ts"],"sourcesContent":["import Debug, { type Debugger } from \"debug\";\nimport { debugPrefix, ExecutionVersion } from \"../../helpers/consts.ts\";\nimport type { ServerTiming } from \"../../helpers/ServerTiming.ts\";\nimport type { MaybePromise, Simplify } from \"../../helpers/types.ts\";\nimport type { Context, IncomingOp, OutgoingOp } from \"../../types.ts\";\nimport type { Inngest } from \"../Inngest.ts\";\nimport type { ActionResponse } from \"../InngestCommHandler.ts\";\nimport type { InngestFunction } from \"../InngestFunction.ts\";\n\n// Re-export ExecutionVersion so it's correctly recognized as an enum and not\n// just a type. This can be lost when bundling if we don't re-export it here.\n// See `pnpm run test:dist`.\nexport { ExecutionVersion };\n\n/**\n * The possible results of an execution.\n */\nexport interface ExecutionResults {\n  \"function-resolved\": { data: unknown };\n  \"step-ran\": { step: OutgoingOp; retriable?: boolean | string };\n  \"function-rejected\": { error: unknown; retriable: boolean | string };\n  \"steps-found\": { steps: [OutgoingOp, ...OutgoingOp[]] };\n  \"step-not-found\": { step: OutgoingOp };\n}\n\nexport type ExecutionResult = {\n  [K in keyof ExecutionResults]: Simplify<\n    {\n      type: K;\n      ctx: Context.Any;\n      ops: Record<string, MemoizedOp>;\n    } & ExecutionResults[K]\n  >;\n}[keyof ExecutionResults];\n\nexport type ExecutionResultHandler<T = ActionResponse> = (\n  result: ExecutionResult,\n) => MaybePromise<T>;\n\nexport type ExecutionResultHandlers<T = ActionResponse> = {\n  [E in ExecutionResult as E[\"type\"]]: (result: E) => MaybePromise<T>;\n};\n\nexport interface MemoizedOp extends IncomingOp {\n  /**\n   * If the step has been hit during this run, these will be the arguments\n   * passed to it.\n   */\n  rawArgs?: unknown[];\n  fulfilled?: boolean;\n\n  /**\n   * The promise that has been returned to userland code.\n   */\n  promise?: Promise<unknown>;\n  seen?: boolean;\n}\n\n/**\n * The preferred execution version that will be used by the SDK when handling\n * brand new runs where the Executor is allowing us to choose.\n *\n * Changing this should not ever be a breaking change, as this will only change\n * new runs, not existing ones.\n */\nexport const PREFERRED_EXECUTION_VERSION =\n  ExecutionVersion.V1 satisfies ExecutionVersion;\n\n/**\n * Options for creating a new {@link InngestExecution} instance.\n */\nexport interface InngestExecutionOptions {\n  client: Inngest.Any;\n  fn: InngestFunction.Any;\n  reqArgs: unknown[];\n  runId: string;\n  data: Omit<Context.Any, \"step\">;\n  stepState: Record<string, MemoizedOp>;\n  stepCompletionOrder: string[];\n\n  /**\n   * Headers to be sent with any request to Inngest during this execution.\n   */\n  headers: Record<string, string>;\n  requestedRunStep?: string;\n  timer?: ServerTiming;\n  isFailureHandler?: boolean;\n  disableImmediateExecution?: boolean;\n\n  /**\n   * Provide the ability to transform the context passed to the function before\n   * the execution starts.\n   */\n  transformCtx?: (ctx: Readonly<Context.Any>) => Context.Any;\n}\n\nexport type InngestExecutionFactory = (\n  options: InngestExecutionOptions,\n) => IInngestExecution;\n\nexport class InngestExecution {\n  protected debug: Debugger;\n\n  constructor(protected options: InngestExecutionOptions) {\n    this.debug = Debug(`${debugPrefix}:${this.options.runId}`);\n  }\n}\n\nexport interface IInngestExecution {\n  start(): Promise<ExecutionResult>;\n}\n"],"names":["options: InngestExecutionOptions"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;GAiEA,MAAa,8BACX,kKAAA,CAAiB,EAAA;AAkCnB,IAAa,mBAAb,MAA8B;IAClB,MAAA;IAEV,YAAsBA,OAAAA,CAAkC;QAAlC,IAAA,CAAA,OAAA,GAAA;QACpB,IAAA,CAAK,KAAA,OAAQ,kJAAA,EAAM,GAAG,6JAAA,CAAY,CAAA,EAAG,IAAA,CAAK,OAAA,CAAQ,KAAA,EAAA,CAAQ","debugId":null}},
    {"offset": {"line": 1465, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/inngest/api/schema.js","sources":["file:///Users/harshitgangwar/Desktop/SkillForge/node_modules/src/api/schema.ts"],"sourcesContent":["import { z } from \"zod/v3\";\nimport { ExecutionVersion } from \"../helpers/consts.ts\";\nimport { type EventPayload, jsonErrorSchema } from \"../types.ts\";\n\nexport const errorSchema = z.object({\n  error: z.string(),\n  status: z.number(),\n});\nexport type ErrorResponse = z.infer<typeof errorSchema>;\n\nconst v0StepSchema = z\n  .record(\n    z.any().refine((v) => typeof v !== \"undefined\", {\n      message: \"Values in steps must be defined\",\n    }),\n  )\n  .optional()\n  .nullable();\n\nconst v1StepSchema = z\n  .record(\n    z\n      .object({\n        type: z.literal(\"data\").optional().default(\"data\"),\n        data: z.any().refine((v) => typeof v !== \"undefined\", {\n          message: \"Data in steps must be defined\",\n        }),\n      })\n      .strict()\n      .or(\n        z\n          .object({\n            type: z.literal(\"error\").optional().default(\"error\"),\n            error: jsonErrorSchema,\n          })\n          .strict(),\n      )\n      .or(\n        z\n          .object({\n            type: z.literal(\"input\").optional().default(\"input\"),\n            input: z.any().refine((v) => typeof v !== \"undefined\", {\n              message: \"If input is present it must not be `undefined`\",\n            }),\n          })\n          .strict(),\n      )\n\n      /**\n       * If the result isn't a distcint `data` or `error` object, then it's\n       * likely that the executor has set this directly to a value, for example\n       * in the case of `sleep` or `waitForEvent`.\n       *\n       * In this case, pull the entire value through as data.\n       */\n\n      .or(z.any().transform((v) => ({ type: \"data\" as const, data: v }))),\n  )\n  .default({});\n\nconst v2StepSchema = v1StepSchema;\n\nexport const stepsSchemas = {\n  [ExecutionVersion.V0]: v0StepSchema,\n  [ExecutionVersion.V1]: v1StepSchema,\n  [ExecutionVersion.V2]: v2StepSchema,\n} satisfies Record<ExecutionVersion, z.ZodSchema>;\n\nexport type StepsResponse = {\n  [V in ExecutionVersion]: z.infer<(typeof stepsSchemas)[V]>;\n}[ExecutionVersion];\n\nexport const batchSchema = z.array(\n  z.record(z.any()).transform((v) => v as EventPayload),\n);\nexport type BatchResponse = z.infer<typeof batchSchema>;\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;AAIA,MAAa,cAAc,yKAAA,CAAE,MAAA,CAAO;IAClC,OAAO,yKAAA,CAAE,MAAA,EAAQ;IACjB,QAAQ,yKAAA,CAAE,MAAA,EAAQ;CACnB,CAAC;AAGF,MAAM,eAAe,yKAAA,CAClB,MAAA,CACC,yKAAA,CAAE,GAAA,EAAK,CAAC,MAAA,CAAA,CAAQ,IAAM,OAAO,MAAM,aAAa;IAC9C,SAAS;AAAA,CACV,CAAC,CACH,CACA,QAAA,EAAU,CACV,QAAA,EAAU;AAEb,MAAM,eAAe,yKAAA,CAClB,MAAA,CACC,yKAAA,CACG,MAAA,CAAO;IACN,MAAM,yKAAA,CAAE,OAAA,CAAQ,OAAO,CAAC,QAAA,EAAU,CAAC,OAAA,CAAQ,OAAO;IAClD,MAAM,yKAAA,CAAE,GAAA,EAAK,CAAC,MAAA,CAAA,CAAQ,IAAM,OAAO,MAAM,aAAa;QACpD,SAAS;IAAA,CACV,CAAC;CACH,CAAC,CACD,MAAA,EAAQ,CACR,EAAA,CACC,yKAAA,CACG,MAAA,CAAO;IACN,MAAM,yKAAA,CAAE,OAAA,CAAQ,QAAQ,CAAC,QAAA,EAAU,CAAC,OAAA,CAAQ,QAAQ;IACpD,OAAO,qJAAA;CACR,CAAC,CACD,MAAA,EAAQ,CACZ,CACA,EAAA,CACC,yKAAA,CACG,MAAA,CAAO;IACN,MAAM,yKAAA,CAAE,OAAA,CAAQ,QAAQ,CAAC,QAAA,EAAU,CAAC,OAAA,CAAQ,QAAQ;IACpD,OAAO,yKAAA,CAAE,GAAA,EAAK,CAAC,MAAA,CAAA,CAAQ,IAAM,OAAO,MAAM,aAAa;QACrD,SAAS;IAAA,CACV,CAAC;CACH,CAAC,CACD,MAAA,EAAQ,CACZ,CAUA,EAAA,CAAG,yKAAA,CAAE,GAAA,EAAK,CAAC,SAAA,CAAA,CAAW,IAAA,CAAO;QAAE,MAAM;QAAiB,MAAM;KAAG,EAAE,CAAC,CACtE,CACA,OAAA,CAAQ,CAAA,CAAE,CAAC;AAEd,MAAM,eAAe;AAErB,MAAa,eAAe;KACzB,kKAAA,CAAiB,EAAA,CAAA,EAAK;KACtB,kKAAA,CAAiB,EAAA,CAAA,EAAK;KACtB,kKAAA,CAAiB,EAAA,CAAA,EAAK;CACxB;AAMD,MAAa,cAAc,yKAAA,CAAE,KAAA,CAC3B,yKAAA,CAAE,MAAA,CAAO,yKAAA,CAAE,GAAA,EAAK,CAAC,CAAC,SAAA,CAAA,CAAW,IAAM,EAAkB,CACtD","debugId":null}},
    {"offset": {"line": 1518, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/inngest/helpers/functions.js","sources":["file:///Users/harshitgangwar/Desktop/SkillForge/node_modules/src/helpers/functions.ts"],"sourcesContent":["import { ZodError, z } from \"zod/v3\";\nimport type { InngestApi } from \"../api/api.ts\";\nimport { stepsSchemas } from \"../api/schema.ts\";\nimport { PREFERRED_EXECUTION_VERSION } from \"../components/execution/InngestExecution.ts\";\nimport { err, ok, type Result } from \"../types.ts\";\nimport { ExecutionVersion } from \"./consts.ts\";\nimport { prettyError } from \"./errors.ts\";\nimport type { Await } from \"./types.ts\";\n\n/**\n * Wraps a function with a cache. When the returned function is run, it will\n * cache the result and return it on subsequent calls.\n */\n// biome-ignore lint/suspicious/noExplicitAny: <explanation>\nexport const cacheFn = <T extends (...args: any[]) => any>(fn: T): T => {\n  const key = \"value\";\n  const cache = new Map<typeof key, unknown>();\n\n  return ((...args) => {\n    if (!cache.has(key)) {\n      cache.set(key, fn(...args));\n    }\n\n    return cache.get(key);\n  }) as T;\n};\n\n/**\n * Given an array of functions, return a new function that will run each\n * function in series and return the result of the final function. Regardless of\n * if the functions are synchronous or asynchronous, they'll be made into an\n * async promise chain.\n *\n * If an error is thrown, the waterfall will stop and return the error.\n *\n * Because this needs to support both sync and async functions, it only allows\n * functions that accept a single argument.\n */\n// biome-ignore lint/suspicious/noExplicitAny: <explanation>\nexport const waterfall = <TFns extends ((arg?: any) => any)[]>(\n  fns: TFns,\n\n  /**\n   * A function that transforms the result of each function in the waterfall,\n   * ready for the next function.\n   *\n   * Will not be called on the final function.\n   */\n  // biome-ignore lint/suspicious/noExplicitAny: <explanation>\n  transform?: (prev: any, output: any) => any,\n): ((...args: Parameters<TFns[number]>) => Promise<Await<TFns[number]>>) => {\n  return (...args) => {\n    const chain = fns.reduce(async (acc, fn) => {\n      const prev = await acc;\n      const output = (await fn(prev)) as Promise<Await<TFns[number]>>;\n\n      if (transform) {\n        return await transform(prev, output);\n      }\n\n      if (typeof output === \"undefined\") {\n        return prev;\n      }\n\n      return output;\n    }, Promise.resolve(args[0]));\n\n    return chain;\n  };\n};\n\n/**\n * Given a value `v`, return `v` if it's not undefined, otherwise return `null`.\n */\nexport const undefinedToNull = (v: unknown) => {\n  const isUndefined = typeof v === \"undefined\";\n  return isUndefined ? null : v;\n};\n\nconst fnDataVersionSchema = z.object({\n  version: z\n    .literal(-1)\n    .or(z.literal(0))\n    .or(z.literal(1))\n    .or(z.literal(2))\n    .optional()\n    .transform<ExecutionVersion>((v) => {\n      if (typeof v === \"undefined\") {\n        console.debug(\n          `No request version specified by executor; defaulting to v${PREFERRED_EXECUTION_VERSION}`,\n        );\n\n        return PREFERRED_EXECUTION_VERSION;\n      }\n\n      return v === -1 ? PREFERRED_EXECUTION_VERSION : v;\n    }),\n});\n\nexport const parseFnData = (data: unknown) => {\n  let version: ExecutionVersion;\n\n  try {\n    ({ version } = fnDataVersionSchema.parse(data));\n\n    const versionHandlers = {\n      [ExecutionVersion.V0]: () =>\n        ({\n          version: ExecutionVersion.V0,\n          ...z\n            .object({\n              event: z.record(z.any()),\n              events: z.array(z.record(z.any())).default([]),\n              steps: stepsSchemas[ExecutionVersion.V0],\n              ctx: z\n                .object({\n                  run_id: z.string(),\n                  attempt: z.number().default(0),\n                  stack: z\n                    .object({\n                      stack: z\n                        .array(z.string())\n                        .nullable()\n                        .transform((v) => (Array.isArray(v) ? v : [])),\n                      current: z.number(),\n                    })\n                    .passthrough()\n                    .optional()\n                    .nullable(),\n                })\n                .optional()\n                .nullable(),\n              use_api: z.boolean().default(false),\n            })\n            .parse(data),\n        }) as const,\n\n      [ExecutionVersion.V1]: () =>\n        ({\n          version: ExecutionVersion.V1,\n          ...z\n            .object({\n              event: z.record(z.any()),\n              events: z.array(z.record(z.any())).default([]),\n              steps: stepsSchemas[ExecutionVersion.V1],\n              ctx: z\n                .object({\n                  run_id: z.string(),\n                  attempt: z.number().default(0),\n                  disable_immediate_execution: z.boolean().default(false),\n                  use_api: z.boolean().default(false),\n                  stack: z\n                    .object({\n                      stack: z\n                        .array(z.string())\n                        .nullable()\n                        .transform((v) => (Array.isArray(v) ? v : [])),\n                      current: z.number(),\n                    })\n                    .passthrough()\n                    .optional()\n                    .nullable(),\n                })\n                .optional()\n                .nullable(),\n            })\n            .parse(data),\n        }) as const,\n\n      [ExecutionVersion.V2]: () =>\n        ({\n          version: ExecutionVersion.V2,\n          ...z\n            .object({\n              event: z.record(z.any()),\n              events: z.array(z.record(z.any())).default([]),\n              steps: stepsSchemas[ExecutionVersion.V2],\n              ctx: z\n                .object({\n                  run_id: z.string(),\n                  attempt: z.number().default(0),\n                  disable_immediate_execution: z.boolean().default(false),\n                  use_api: z.boolean().default(false),\n                  stack: z\n                    .object({\n                      stack: z\n                        .array(z.string())\n                        .nullable()\n                        .transform((v) => (Array.isArray(v) ? v : [])),\n                      current: z.number(),\n                    })\n                    .passthrough()\n                    .optional()\n                    .nullable(),\n                })\n                .optional()\n                .nullable(),\n            })\n            .parse(data),\n        }) as const,\n    } satisfies Record<ExecutionVersion, () => unknown>;\n\n    return versionHandlers[version]();\n  } catch (err) {\n    throw new Error(parseFailureErr(err));\n  }\n};\nexport type FnData = ReturnType<typeof parseFnData>;\n\ntype ParseErr = string;\nexport const fetchAllFnData = async ({\n  data,\n  api,\n  version,\n}: {\n  data: FnData;\n  api: InngestApi;\n  version: ExecutionVersion;\n}): Promise<Result<FnData, ParseErr>> => {\n  const result = { ...data };\n\n  try {\n    if (\n      (result.version === ExecutionVersion.V0 && result.use_api) ||\n      (result.version === ExecutionVersion.V1 && result.ctx?.use_api)\n    ) {\n      if (!result.ctx?.run_id) {\n        return err(\n          prettyError({\n            whatHappened: \"failed to attempt retrieving data from API\",\n            consequences: \"function execution can't continue\",\n            why: \"run_id is missing from context\",\n            stack: true,\n          }),\n        );\n      }\n\n      const [evtResp, stepResp] = await Promise.all([\n        api.getRunBatch(result.ctx.run_id),\n        api.getRunSteps(result.ctx.run_id, version),\n      ]);\n\n      if (evtResp.ok) {\n        result.events = evtResp.value;\n      } else {\n        return err(\n          prettyError({\n            whatHappened: \"failed to retrieve list of events\",\n            consequences: \"function execution can't continue\",\n            why: evtResp.error?.error,\n            stack: true,\n          }),\n        );\n      }\n\n      if (stepResp.ok) {\n        result.steps = stepResp.value;\n      } else {\n        return err(\n          prettyError({\n            whatHappened: \"failed to retrieve steps for function run\",\n            consequences: \"function execution can't continue\",\n            why: stepResp.error?.error,\n            stack: true,\n          }),\n        );\n      }\n    }\n\n    return ok(result);\n  } catch (error) {\n    // print it out for now.\n    // move to something like protobuf so we don't have to deal with this\n    console.error(error);\n\n    return err(parseFailureErr(error));\n  }\n};\n\nconst parseFailureErr = (err: unknown) => {\n  let why: string | undefined;\n  if (err instanceof ZodError) {\n    why = err.toString();\n  }\n\n  return prettyError({\n    whatHappened: \"Failed to parse data from executor.\",\n    consequences: \"Function execution can't continue.\",\n    toFixNow:\n      \"Make sure that your API is set up to parse incoming request bodies as JSON, like body-parser for Express (https://expressjs.com/en/resources/middleware/body-parser.html).\",\n    stack: true,\n    why,\n  });\n};\n"],"names":["version: ExecutionVersion","err","why: string | undefined"],"mappings":"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","debugId":null}},
    {"offset": {"line": 1708, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/inngest/helpers/net.js","sources":["file:///Users/harshitgangwar/Desktop/SkillForge/node_modules/src/helpers/net.ts"],"sourcesContent":["import canonicalize from \"canonicalize\";\nimport hashjs from \"hash.js\";\n\nconst { hmac, sha256 } = hashjs;\n\n/**\n * Send an HTTP request with the given signing key. If the response is a 401 or\n * 403, then try again with the fallback signing key\n */\nexport async function fetchWithAuthFallback<TFetch extends typeof fetch>({\n  authToken,\n  authTokenFallback,\n  fetch,\n  options,\n  url,\n}: {\n  authToken?: string;\n  authTokenFallback?: string;\n  fetch: TFetch;\n  options?: Parameters<TFetch>[1];\n  url: URL | string;\n}): Promise<Response> {\n  let res = await fetch(url, {\n    ...options,\n    headers: {\n      ...options?.headers,\n      Authorization: `Bearer ${authToken}`,\n    },\n  });\n\n  if ([401, 403].includes(res.status) && authTokenFallback) {\n    res = await fetch(url, {\n      ...options,\n      headers: {\n        ...options?.headers,\n        Authorization: `Bearer ${authTokenFallback}`,\n      },\n    });\n  }\n\n  return res;\n}\n\nexport function signDataWithKey(\n  data: unknown,\n  signingKey: string,\n  ts: string,\n): string {\n  // Calculate the HMAC of the request body ourselves.\n  // We make the assumption here that a stringified body is the same as the\n  // raw bytes; it may be pertinent in the future to always parse, then\n  // canonicalize the body to ensure it's consistent.\n  const encoded = typeof data === \"string\" ? data : canonicalize(data);\n  // Remove the `/signkey-[test|prod]-/` prefix from our signing key to calculate the HMAC.\n  const key = signingKey.replace(/signkey-\\w+-/, \"\");\n  // biome-ignore lint/suspicious/noExplicitAny: <explanation>\n  const mac = hmac(sha256 as any, key)\n    .update(encoded)\n    .update(ts)\n    .digest(\"hex\");\n\n  return mac;\n}\n"],"names":[],"mappings":";;;;;;;;;;;AAGA,MAAM,EAAE,IAAA,EAAM,MAAA,EAAA,GAAW,sJAAA;;;;GAMzB,eAAsB,sBAAmD,EACvE,SAAA,EACA,iBAAA,EACA,KAAA,EACA,OAAA,EACA,GAAA,EAAA,EAOoB;IACpB,IAAI,MAAM,MAAM,MAAM,KAAK;QACzB,GAAG,OAAA;QACH,SAAS;YACP,GAAG,SAAS,OAAA;YACZ,eAAe,CAAA,OAAA,EAAU,WAAA;SAC1B;KACF,CAAC;IAEF,IAAI;QAAC;QAAK;KAAI,CAAC,QAAA,CAAS,IAAI,MAAA,CAAO,IAAI,kBACrC,CAAA,MAAM,MAAM,MAAM,KAAK;QACrB,GAAG,OAAA;QACH,SAAS;YACP,GAAG,SAAS,OAAA;YACZ,eAAe,CAAA,OAAA,EAAU,mBAAA;SAC1B;KACF,CAAC;IAGJ,OAAO;;AAGT,SAAgB,gBACd,IAAA,EACA,UAAA,EACA,EAAA,EACQ;IAKR,MAAM,UAAU,OAAO,SAAS,WAAW,WAAO,gKAAA,EAAa,KAAK;IAEpE,MAAM,MAAM,WAAW,OAAA,CAAQ,gBAAgB,GAAG;IAOlD,OALY,KAAK,QAAe,IAAI,CACjC,MAAA,CAAO,QAAQ,CACf,MAAA,CAAO,GAAG,CACV,MAAA,CAAO,MAAM","debugId":null}},
    {"offset": {"line": 1754, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/inngest/helpers/promises.js","sources":["file:///Users/harshitgangwar/Desktop/SkillForge/node_modules/src/helpers/promises.ts"],"sourcesContent":["import type { MaybePromise } from \"./types.ts\";\n\n/**\n * Some environments don't allow access to the global queueMicrotask(). While we\n * had assumed this was only true for those powered by earlier versions of Node\n * (<14) that we don't officially support, Vercel's Edge Functions also obscure\n * the function in dev, even though the platform it's based on (Cloudflare\n * Workers) appropriately exposes it. Even worse, production Vercel Edge\n * Functions can see the function, but it immediately blows up the function when\n * used.\n *\n * Therefore, we can fall back to a reasonable alternative of\n * `Promise.resolve().then(fn)` instead. This _may_ be slightly slower in modern\n * environments, but at least we can still work in these environments.\n */\nconst shimQueueMicrotask = (callback: () => void): void => {\n  void Promise.resolve().then(callback);\n};\n\n/**\n * A helper function to create a `Promise` that will never settle.\n *\n * It purposefully creates no references to `resolve` or `reject` so that the\n * returned `Promise` will remain unsettled until it falls out of scope and is\n * garbage collected.\n *\n * This should be used within transient closures to fake asynchronous action, so\n * long as it's guaranteed that they will fall out of scope.\n */\nexport const createFrozenPromise = (): Promise<unknown> => {\n  return new Promise(() => undefined);\n};\n\n/**\n * Returns a Promise that resolves after the current event loop's microtasks\n * have finished, but before the next event loop tick.\n */\nexport const resolveAfterPending = (count = 100): Promise<void> => {\n  /**\n   * This uses a brute force implementation that will continue to enqueue\n   * microtasks 10 times before resolving. This is to ensure that the microtask\n   * queue is drained, even if the microtask queue is being manipulated by other\n   * code.\n   *\n   * While this still doesn't guarantee that the microtask queue is drained,\n   * it's our best bet for giving other non-controlled promises a chance to\n   * resolve before we continue without resorting to falling in to the next\n   * tick.\n   */\n  return new Promise((resolve) => {\n    let i = 0;\n\n    const iterate = () => {\n      shimQueueMicrotask(() => {\n        if (i++ > count) {\n          return resolve();\n        }\n\n        iterate();\n      });\n    };\n\n    iterate();\n  });\n};\n\ntype DeferredPromiseReturn<T> = {\n  promise: Promise<T>;\n  resolve: (value: T) => DeferredPromiseReturn<T>;\n  // biome-ignore lint/suspicious/noExplicitAny: <explanation>\n  reject: (reason: any) => DeferredPromiseReturn<T>;\n};\n\n/**\n * Creates and returns Promise that can be resolved or rejected with the\n * returned `resolve` and `reject` functions.\n *\n * Resolving or rejecting the function will return a new set of Promise control\n * functions. These can be ignored if the original Promise is all that's needed.\n */\nexport const createDeferredPromise = <T>(): DeferredPromiseReturn<T> => {\n  let resolve: DeferredPromiseReturn<T>[\"resolve\"];\n  let reject: DeferredPromiseReturn<T>[\"reject\"];\n\n  const promise = new Promise<T>((_resolve, _reject) => {\n    resolve = (value: T) => {\n      _resolve(value);\n      return createDeferredPromise<T>();\n    };\n\n    reject = (reason) => {\n      _reject(reason);\n      return createDeferredPromise<T>();\n    };\n  });\n\n  return { promise, resolve: resolve!, reject: reject! };\n};\n\n/**\n * Creates and returns a deferred Promise that can be resolved or rejected with\n * the returned `resolve` and `reject` functions.\n *\n * For each Promise resolved or rejected this way, this will also keep a stack\n * of all unhandled Promises, resolved or rejected.\n *\n * Once a Promise is read, it is removed from the stack.\n */\nexport const createDeferredPromiseWithStack = <T>(): {\n  deferred: DeferredPromiseReturn<T>;\n  results: AsyncGenerator<Awaited<T>, void, void>;\n} => {\n  const settledPromises: Promise<T>[] = [];\n  // biome-ignore lint/suspicious/noConfusingVoidType: <explanation>\n  let rotateQueue: (value: void) => void = () => {};\n\n  const results = (async function* () {\n    while (true) {\n      const next = settledPromises.shift();\n\n      if (next) {\n        yield next;\n      } else {\n        await new Promise<void>((resolve) => {\n          rotateQueue = resolve;\n        });\n      }\n    }\n  })();\n\n  const shimDeferredPromise = (deferred: DeferredPromiseReturn<T>) => {\n    const originalResolve = deferred.resolve;\n    const originalReject = deferred.reject;\n\n    deferred.resolve = (value: T) => {\n      settledPromises.push(deferred.promise);\n      rotateQueue();\n      return shimDeferredPromise(originalResolve(value));\n    };\n\n    deferred.reject = (reason) => {\n      settledPromises.push(deferred.promise);\n      rotateQueue();\n      return shimDeferredPromise(originalReject(reason));\n    };\n\n    return deferred;\n  };\n\n  const deferred = shimDeferredPromise(createDeferredPromise<T>());\n\n  return { deferred, results };\n};\n\ninterface TimeoutPromise extends Promise<void> {\n  /**\n   * Starts the timeout. If the timer is already started, this does nothing.\n   *\n   * @returns The promise that will resolve when the timeout expires.\n   */\n  start: () => TimeoutPromise;\n\n  /**\n   * Clears the timeout.\n   */\n  clear: () => void;\n\n  /**\n   * Clears the timeout and starts it again.\n   *\n   * @returns The promise that will resolve when the timeout expires.\n   */\n  reset: () => TimeoutPromise;\n}\n\n/**\n * Creates a Promise that will resolve after the given duration, along with\n * methods to start, clear, and reset the timeout.\n */\nexport const createTimeoutPromise = (duration: number): TimeoutPromise => {\n  const { promise, resolve } = createDeferredPromise<void>();\n\n  let timeout: ReturnType<typeof setTimeout> | undefined;\n  // biome-ignore lint/style/useConst: <explanation>\n  let ret: TimeoutPromise;\n\n  const start = () => {\n    if (timeout) return ret;\n\n    timeout = setTimeout(() => {\n      resolve();\n    }, duration);\n\n    return ret;\n  };\n\n  const clear = () => {\n    clearTimeout(timeout);\n    timeout = undefined;\n  };\n\n  const reset = () => {\n    clear();\n    return start();\n  };\n\n  ret = Object.assign(promise, { start, clear, reset });\n\n  return ret;\n};\n\n/**\n * Take any function and safely promisify such that both synchronous and\n * asynchronous errors are caught and returned as a rejected Promise.\n *\n * The passed `fn` can be undefined to support functions that may conditionally\n * be defined.\n */\n// biome-ignore lint/suspicious/noExplicitAny: <explanation>\nexport const runAsPromise = <T extends (() => any) | undefined>(\n  fn: T,\n  // biome-ignore lint/suspicious/noExplicitAny: <explanation>\n): Promise<T extends () => any ? Awaited<ReturnType<T>> : T> => {\n  return Promise.resolve().then(fn);\n};\n\n/**\n * Returns a Promise that resolve after the current event loop tick.\n */\nexport const resolveNextTick = (): Promise<void> => {\n  return new Promise((resolve) => setTimeout(resolve));\n};\n\nexport const retryWithBackoff = async <T>(\n  fn: () => MaybePromise<T>,\n  opts?: {\n    maxAttempts?: number;\n    baseDelay?: number;\n  },\n): Promise<T> => {\n  const maxAttempts = opts?.maxAttempts || 5;\n  const baseDelay = opts?.baseDelay ?? 100;\n\n  for (let attempt = 1; attempt <= maxAttempts; attempt++) {\n    try {\n      return await fn();\n    } catch (err) {\n      if (attempt >= maxAttempts) {\n        throw err;\n      }\n\n      const jitter = Math.random() * baseDelay;\n      const delay = baseDelay * Math.pow(2, attempt - 1) + jitter;\n      await new Promise((resolve) => setTimeout(resolve, delay));\n    }\n  }\n\n  throw new Error(\"Max retries reached; this should be unreachable.\");\n};\n"],"names":["resolve: DeferredPromiseReturn<T>[\"resolve\"]","reject: DeferredPromiseReturn<T>[\"reject\"]","settledPromises: Promise<T>[]","rotateQueue: (value: void) => void","timeout: ReturnType<typeof setTimeout> | undefined","ret: TimeoutPromise"],"mappings":"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","debugId":null}},
    {"offset": {"line": 1937, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/inngest/helpers/ServerTiming.js","sources":["file:///Users/harshitgangwar/Desktop/SkillForge/node_modules/src/helpers/ServerTiming.ts"],"sourcesContent":["import { runAsPromise } from \"./promises.ts\";\n\ninterface Timing {\n  description: string;\n  timers: {\n    start?: number;\n    end?: number;\n  }[];\n}\n\n/**\n * A class to manage timing functions and arbitrary periods of time before\n * generating a `Server-Timing` header for use in HTTP responses.\n *\n * This is a very simple implementation that does not support nested timings or\n * fractions of a millisecond.\n */\nexport class ServerTiming {\n  private timings: Record<string, Timing> = {};\n\n  /**\n   * Start a timing. Returns a function that, when called, will stop the timing\n   * and add it to the header.\n   */\n  public start(name: string, description?: string): () => void {\n    if (!this.timings[name]) {\n      this.timings[name] = {\n        description: description ?? \"\",\n        timers: [],\n      };\n    }\n\n    const index = this.timings[name].timers.push({ start: Date.now() }) - 1;\n\n    return (): void => {\n      const target = this.timings[name];\n      if (!target) {\n        return console.warn(`Timing \"${name}\" does not exist`);\n      }\n\n      const timer = target.timers[index];\n      if (!timer) {\n        return console.warn(\n          `Timer ${index} for timing \"${name}\" does not exist`,\n        );\n      }\n\n      timer.end = Date.now();\n    };\n  }\n\n  /**\n   * Add a piece of arbitrary, untimed information to the header. Common use\n   * cases would be cache misses.\n   *\n   * @example\n   * ```\n   * timer.append(\"cache\", \"miss\");\n   * ```\n   */\n  public append(key: string, value: string): void {\n    this.timings[key] = {\n      description: value,\n      timers: [],\n    };\n  }\n\n  /**\n   * Wrap a function in a timing. The timing will be stopped and added to the\n   * header when the function resolves or rejects.\n   *\n   * The return value of the function will be returned from this function.\n   */\n  public async wrap<T extends (...args: unknown[]) => unknown>(\n    name: string,\n    fn: T,\n    description?: string,\n  ): Promise<Awaited<ReturnType<T>>> {\n    const stop = this.start(name, description);\n\n    try {\n      return (await runAsPromise(fn)) as Awaited<ReturnType<T>>;\n    } finally {\n      stop();\n    }\n  }\n\n  /**\n   * Generate the `Server-Timing` header.\n   */\n  public getHeader(): string {\n    const entries = Object.entries(this.timings).reduce<string[]>(\n      (acc, [name, { description, timers }]) => {\n        /**\n         * Ignore timers that had no end.\n         */\n        const hasTimersWithEnd = timers.some((timer) => timer.end);\n        if (!hasTimersWithEnd) {\n          return acc;\n        }\n\n        const dur = timers.reduce((acc, { start, end }) => {\n          if (!start || !end) return acc;\n          return acc + (end - start);\n        }, 0);\n\n        const entry = [\n          name,\n          description ? `desc=\"${description}\"` : \"\",\n          dur ? `dur=${dur}` : \"\",\n        ]\n          .filter(Boolean)\n          .join(\";\");\n\n        return [...acc, entry];\n      },\n      [],\n    );\n\n    return entries.join(\", \");\n  }\n}\n"],"names":["acc"],"mappings":";;;;;;;;;;;;;;;;;;;;GAiBA,IAAa,eAAb,MAA0B;IAChB,UAAkC,CAAA,CAAE,CAAA;;;;IAMrC,MAAM,IAAA,EAAc,WAAA,EAAkC;QAC3D,IAAI,CAAC,IAAA,CAAK,OAAA,CAAQ,KAAA,CAChB,CAAA,IAAA,CAAK,OAAA,CAAQ,KAAA,GAAQ;YACnB,aAAa,eAAe;YAC5B,QAAQ,EAAE;SACX;QAGH,MAAM,QAAQ,IAAA,CAAK,OAAA,CAAQ,KAAA,CAAM,MAAA,CAAO,IAAA,CAAK;YAAE,OAAO,KAAK,GAAA,EAAK;QAAA,CAAE,CAAC,GAAG;QAEtE,OAAA,MAAmB;YACjB,MAAM,SAAS,IAAA,CAAK,OAAA,CAAQ,KAAA;YAC5B,IAAI,CAAC,OACH,CAAA,OAAO,QAAQ,IAAA,CAAK,CAAA,QAAA,EAAW,KAAK,gBAAA,CAAA,CAAkB;YAGxD,MAAM,QAAQ,OAAO,MAAA,CAAO,MAAA;YAC5B,IAAI,CAAC,MACH,CAAA,OAAO,QAAQ,IAAA,CACb,CAAA,MAAA,EAAS,MAAM,aAAA,EAAe,KAAK,gBAAA,CAAA,CACpC;YAGH,MAAM,GAAA,GAAM,KAAK,GAAA,EAAK;;;;;;;;;;;IAanB,OAAO,GAAA,EAAa,KAAA,EAAqB;QAC9C,IAAA,CAAK,OAAA,CAAQ,IAAA,GAAO;YAClB,aAAa;YACb,QAAQ,EAAE;SACX;;;;;;;IASH,MAAa,KACX,IAAA,EACA,EAAA,EACA,WAAA,EACiC;QACjC,MAAM,OAAO,IAAA,CAAK,KAAA,CAAM,MAAM,YAAY;QAE1C,IAAI;YACF,OAAQ,UAAM,gKAAA,EAAa,GAAG;iBACtB;YACR,MAAM;;;;;IAOH,YAAoB;QA6BzB,OA5BgB,OAAO,OAAA,CAAQ,IAAA,CAAK,OAAA,CAAQ,CAAC,MAAA,CAAA,CAC1C,KAAK,CAAC,MAAM,EAAE,WAAA,EAAa,MAAA,EAAA,CAAA,KAAc;YAKxC,IAAI,CADqB,OAAO,IAAA,CAAA,CAAM,QAAU,MAAM,GAAA,CAAI,CAExD,CAAA,OAAO;YAGT,MAAM,MAAM,OAAO,MAAA,CAAA,CAAQ,OAAK,EAAE,KAAA,EAAO,GAAA,EAAA,KAAU;gBACjD,IAAI,CAAC,SAAS,CAAC,IAAK,CAAA,OAAOA;gBAC3B,OAAOA,QAAAA,CAAO,MAAM,KAAA;eACnB,EAAE;YAEL,MAAM,QAAQ;gBACZ;gBACA,cAAc,CAAA,MAAA,EAAS,YAAY,CAAA,CAAA,GAAK;gBACxC,MAAM,CAAA,IAAA,EAAO,KAAA,GAAQ;aACtB,CACE,MAAA,CAAO,QAAQ,CACf,IAAA,CAAK,IAAI;YAEZ,OAAO,CAAC;mBAAG;gBAAK;aAAM;WAExB,EAAE,CACH,CAEc,IAAA,CAAK,KAAK","debugId":null}},
    {"offset": {"line": 2032, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/inngest/helpers/stream.js","sources":["file:///Users/harshitgangwar/Desktop/SkillForge/node_modules/src/helpers/stream.ts"],"sourcesContent":["import { stringify } from \"./strings.ts\";\n\n/**\n * Creates a {@link ReadableStream} that sends a `value` every `interval`\n * milliseconds as a heartbeat, intended to keep a stream open.\n *\n * Returns the `stream` itself and a `finalize` function that can be used to\n * close the stream and send a final value.\n */\nexport const createStream = (opts?: {\n  /**\n   * The interval in milliseconds to send a heartbeat.\n   *\n   * Defaults to `3000`.\n   */\n  interval?: number;\n\n  /**\n   * The value to send as a heartbeat.\n   *\n   * Defaults to `\" \"`.\n   */\n  value?: string;\n}): Promise<{ finalize: (data: unknown) => void; stream: ReadableStream }> => {\n  /**\n   * We need to resolve this promise with both the stream and the `finalize`\n   * function, but having them both instantiated synchronously is difficult, as\n   * we need access to the stream's internals too.\n   *\n   * We create this cheeky deferred promise to grab the internal `finalize`\n   * value. Be warned that simpler solutions may appear to compile, but fail at\n   * runtime due to variables not being assigned; make sure to test your code!\n   */\n  let passFinalize: (value: (data: unknown) => void) => void;\n\n  const finalizeP = new Promise<(data: unknown) => void>((resolve) => {\n    passFinalize = resolve;\n  });\n\n  const interval = opts?.interval ?? 3000;\n  const value = opts?.value ?? \" \";\n\n  return new Promise(async (resolve, reject) => {\n    try {\n      const stream = new ReadableStream({\n        start(controller) {\n          const encoder = new TextEncoder();\n\n          const heartbeat = setInterval(() => {\n            controller.enqueue(encoder.encode(value));\n          }, interval);\n\n          const finalize = (data: unknown) => {\n            clearInterval(heartbeat);\n\n            // `data` may be a `Promise`. If it is, we need to wait for it to\n            // resolve before sending it. To support this elegantly we'll always\n            // assume it's a promise and handle that case.\n            void Promise.resolve(data).then((resolvedData) => {\n              controller.enqueue(encoder.encode(stringify(resolvedData)));\n              controller.close();\n            });\n          };\n\n          passFinalize(finalize);\n        },\n      });\n\n      resolve({ stream, finalize: await finalizeP });\n    } catch (err) {\n      reject(err);\n    }\n  });\n};\n"],"names":["passFinalize: (value: (data: unknown) => void) => void"],"mappings":";;;;;;;;;;;;;GASA,MAAa,eAAA,CAAgB,SAciD;;;;;;;;;IAU5E,IAAIA;IAEJ,MAAM,YAAY,IAAI,QAAA,CAAkC,YAAY;QAClE,eAAe;MACf;IAEF,MAAM,WAAW,MAAM,YAAY;IACnC,MAAM,QAAQ,MAAM,SAAS;IAE7B,OAAO,IAAI,QAAQ,OAAO,SAAS,WAAW;QAC5C,IAAI;YACF,MAAM,SAAS,IAAI,eAAe;gBAChC,OAAM,UAAA,EAAY;oBAChB,MAAM,UAAU,IAAI,aAAa;oBAEjC,MAAM,YAAY,YAAA,MAAkB;wBAClC,WAAW,OAAA,CAAQ,QAAQ,MAAA,CAAO,MAAM,CAAC;uBACxC,SAAS;oBAEZ,MAAM,WAAA,CAAY,SAAkB;wBAClC,cAAc,UAAU;wBAKnB,QAAQ,OAAA,CAAQ,KAAK,CAAC,IAAA,CAAA,CAAM,iBAAiB;4BAChD,WAAW,OAAA,CAAQ,QAAQ,MAAA,KAAO,4JAAA,EAAU,aAAa,CAAC,CAAC;4BAC3D,WAAW,KAAA,EAAO;0BAClB;;oBAGJ,aAAa,SAAS;;aAEzB,CAAC;YAEF,QAAQ;gBAAE;gBAAQ,UAAU,MAAM;aAAW,CAAC;iBACvC,KAAK;YACZ,OAAO,IAAI;;MAEb","debugId":null}},
    {"offset": {"line": 2093, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/inngest/components/InngestCommHandler.js","sources":["file:///Users/harshitgangwar/Desktop/SkillForge/node_modules/src/components/InngestCommHandler.ts"],"sourcesContent":["import debug from \"debug\";\nimport { z } from \"zod/v3\";\nimport {\n  debugPrefix,\n  defaultInngestApiBaseUrl,\n  defaultInngestEventBaseUrl,\n  dummyEventKey,\n  ExecutionVersion,\n  envKeys,\n  headerKeys,\n  logPrefix,\n  probe as probeEnum,\n  queryKeys,\n  syncKind,\n} from \"../helpers/consts.ts\";\nimport { devServerAvailable, devServerUrl } from \"../helpers/devserver.ts\";\nimport { enumFromValue } from \"../helpers/enum.ts\";\nimport {\n  allProcessEnv,\n  devServerHost,\n  type Env,\n  getFetch,\n  getMode,\n  getPlatformName,\n  inngestHeaders,\n  Mode,\n  parseAsBoolean,\n  platformSupportsStreaming,\n} from \"../helpers/env.ts\";\nimport { rethrowError, serializeError } from \"../helpers/errors.ts\";\nimport {\n  type FnData,\n  fetchAllFnData,\n  parseFnData,\n  undefinedToNull,\n} from \"../helpers/functions.ts\";\nimport { fetchWithAuthFallback, signDataWithKey } from \"../helpers/net.ts\";\nimport { runAsPromise } from \"../helpers/promises.ts\";\nimport { ServerTiming } from \"../helpers/ServerTiming.ts\";\nimport { createStream } from \"../helpers/stream.ts\";\nimport { hashEventKey, hashSigningKey, stringify } from \"../helpers/strings.ts\";\nimport type { MaybePromise } from \"../helpers/types.ts\";\nimport {\n  type AuthenticatedIntrospection,\n  type EventPayload,\n  type FunctionConfig,\n  functionConfigSchema,\n  type InBandRegisterRequest,\n  inBandSyncRequestBodySchema,\n  type LogLevel,\n  logLevels,\n  type OutgoingOp,\n  type RegisterOptions,\n  type RegisterRequest,\n  type SupportedFrameworkName,\n  type UnauthenticatedIntrospection,\n} from \"../types.ts\";\nimport { version } from \"../version.ts\";\nimport {\n  type ExecutionResult,\n  type ExecutionResultHandler,\n  type ExecutionResultHandlers,\n  type InngestExecutionOptions,\n  PREFERRED_EXECUTION_VERSION,\n} from \"./execution/InngestExecution.ts\";\nimport type { Inngest } from \"./Inngest.ts\";\nimport type {\n  CreateExecutionOptions,\n  InngestFunction,\n} from \"./InngestFunction.ts\";\n\n/**\n * A set of options that can be passed to a serve handler, intended to be used\n * by internal and custom serve handlers to provide a consistent interface.\n *\n * @public\n */\nexport interface ServeHandlerOptions extends RegisterOptions {\n  /**\n   * The `Inngest` instance used to declare all functions.\n   */\n  client: Inngest.Like;\n\n  /**\n   * An array of the functions to serve and register with Inngest.\n   */\n  functions: readonly InngestFunction.Like[];\n}\n\nexport interface InternalServeHandlerOptions extends ServeHandlerOptions {\n  /**\n   * Can be used to override the framework name given to a particular serve\n   * handler.\n   */\n  frameworkName?: string;\n}\n\ninterface InngestCommHandlerOptions<\n  // biome-ignore lint/suspicious/noExplicitAny: <explanation>\n  Input extends any[] = any[],\n  // biome-ignore lint/suspicious/noExplicitAny: <explanation>\n  Output = any,\n  // biome-ignore lint/suspicious/noExplicitAny: <explanation>\n  StreamOutput = any,\n> extends RegisterOptions {\n  /**\n   * The name of the framework this handler is designed for. Should be\n   * lowercase, alphanumeric characters inclusive of `-` and `/`.\n   *\n   * This should never be defined by the user; a {@link ServeHandler} should\n   * abstract this.\n   */\n  frameworkName: string;\n\n  /**\n   * The name of this serve handler, e.g. `\"My App\"`. It's recommended that this\n   * value represents the overarching app/service that this set of functions is\n   * being served from.\n   *\n   * This can also be an `Inngest` client, in which case the name given when\n   * instantiating the client is used. This is useful if you're sending and\n   * receiving events from the same service, as you can reuse a single\n   * definition of Inngest.\n   */\n  client: Inngest.Like;\n\n  /**\n   * An array of the functions to serve and register with Inngest.\n   */\n  functions: readonly InngestFunction.Like[];\n\n  /**\n   * The `handler` is the function that will be called with your framework's\n   * request arguments and returns a set of functions that the SDK will use to\n   * access various parts of the request, such as the body, headers, and query\n   * string parameters.\n   *\n   * It also defines how to transform a response from the SDK into a response\n   * that your framework can understand, ensuring headers, status codes, and\n   * body are all set correctly.\n   *\n   * @example\n   * ```ts\n   * function handler (req: Request, res: Response) {\n   *   return {\n   *     method: () => req.method,\n   *     body: () => req.json(),\n   *     headers: (key) => req.headers.get(key),\n   *     url: () => req.url,\n   *     transformResponse: ({ body, headers, status }) => {\n   *       return new Response(body, { status, headers });\n   *     },\n   *   };\n   * };\n   * ```\n   *\n   * See any existing handler for a full example.\n   */\n  handler: Handler<Input, Output, StreamOutput>;\n\n  skipSignatureValidation?: boolean;\n}\n\n/**\n * Capturing the global type of fetch so that we can reliably access it below.\n */\ntype FetchT = typeof fetch;\n\n/**\n * A schema for the response from Inngest when registering.\n */\nconst registerResSchema = z.object({\n  status: z.number().default(200),\n  skipped: z.boolean().optional().default(false),\n  modified: z.boolean().optional().default(false),\n  error: z.string().default(\"Successfully registered\"),\n});\n\n/**\n * `InngestCommHandler` is a class for handling incoming requests from Inngest (or\n * Inngest's tooling such as the dev server or CLI) and taking appropriate\n * action for any served functions.\n *\n * All handlers (Next.js, RedwoodJS, Remix, Deno Fresh, etc.) are created using\n * this class; the exposed `serve` function will - most commonly - create an\n * instance of `InngestCommHandler` and then return `instance.createHandler()`.\n *\n * See individual parameter details for more information, or see the\n * source code for an existing handler, e.g.\n * {@link https://github.com/inngest/inngest-js/blob/main/src/next.ts}\n *\n * @example\n * ```\n * // my-custom-handler.ts\n * import {\n *   InngestCommHandler,\n *   type ServeHandlerOptions,\n * } from \"./components/InngestCommHandler\";\n *\n * export const serve = (options: ServeHandlerOptions) => {\n *   const handler = new InngestCommHandler({\n *     frameworkName: \"my-custom-handler\",\n *     ...options,\n *     handler: (req: Request) => {\n *       return {\n *         body: () => req.json(),\n *         headers: (key) => req.headers.get(key),\n *         method: () => req.method,\n *         url: () => new URL(req.url, `https://${req.headers.get(\"host\") || \"\"}`),\n *         transformResponse: ({ body, status, headers }) => {\n *           return new Response(body, { status, headers });\n *         },\n *       };\n *     },\n *   });\n *\n *   return handler.createHandler();\n * };\n * ```\n *\n * @public\n */\nexport class InngestCommHandler<\n  // biome-ignore lint/suspicious/noExplicitAny: <explanation>\n  Input extends any[] = any[],\n  // biome-ignore lint/suspicious/noExplicitAny: <explanation>\n  Output = any,\n  // biome-ignore lint/suspicious/noExplicitAny: <explanation>\n  StreamOutput = any,\n> {\n  /**\n   * The ID of this serve handler, e.g. `\"my-app\"`. It's recommended that this\n   * value represents the overarching app/service that this set of functions is\n   * being served from.\n   */\n  public readonly id: string;\n\n  /**\n   * The handler specified during instantiation of the class.\n   */\n  public readonly handler: Handler;\n\n  /**\n   * The URL of the Inngest function registration endpoint.\n   */\n  private readonly inngestRegisterUrl: URL;\n\n  /**\n   * The name of the framework this handler is designed for. Should be\n   * lowercase, alphanumeric characters inclusive of `-` and `/`.\n   */\n  protected readonly frameworkName: string;\n\n  /**\n   * The signing key used to validate requests from Inngest. This is\n   * intentionally mutable so that we can pick up the signing key from the\n   * environment during execution if needed.\n   */\n  protected signingKey: string | undefined;\n\n  /**\n   * The same as signingKey, except used as a fallback when auth fails using the\n   * primary signing key.\n   */\n  protected signingKeyFallback: string | undefined;\n\n  /**\n   * A property that can be set to indicate whether we believe we are in\n   * production mode.\n   *\n   * Should be set every time a request is received.\n   */\n  protected _mode: Mode | undefined;\n\n  /**\n   * The localized `fetch` implementation used by this handler.\n   */\n  private readonly fetch: FetchT;\n\n  /**\n   * The host used to access the Inngest serve endpoint, e.g.:\n   *\n   *     \"https://myapp.com\"\n   *\n   * By default, the library will try to infer this using request details such\n   * as the \"Host\" header and request path, but sometimes this isn't possible\n   * (e.g. when running in a more controlled environments such as AWS Lambda or\n   * when dealing with proxies/redirects).\n   *\n   * Provide the custom hostname here to ensure that the path is reported\n   * correctly when registering functions with Inngest.\n   *\n   * To also provide a custom path, use `servePath`.\n   */\n  private readonly _serveHost: string | undefined;\n\n  /**\n   * The path to the Inngest serve endpoint. e.g.:\n   *\n   *     \"/some/long/path/to/inngest/endpoint\"\n   *\n   * By default, the library will try to infer this using request details such\n   * as the \"Host\" header and request path, but sometimes this isn't possible\n   * (e.g. when running in a more controlled environments such as AWS Lambda or\n   * when dealing with proxies/redirects).\n   *\n   * Provide the custom path (excluding the hostname) here to ensure that the\n   * path is reported correctly when registering functions with Inngest.\n   *\n   * To also provide a custom hostname, use `serveHost`.\n   */\n  private readonly _servePath: string | undefined;\n\n  /**\n   * The minimum level to log from the Inngest serve handler.\n   */\n  protected readonly logLevel: LogLevel;\n\n  protected readonly streaming: RegisterOptions[\"streaming\"];\n\n  /**\n   * A private collection of just Inngest functions, as they have been passed\n   * when instantiating the class.\n   */\n  private readonly rawFns: InngestFunction.Any[];\n\n  private readonly client: Inngest.Any;\n\n  /**\n   * A private collection of functions that are being served. This map is used\n   * to find and register functions when interacting with Inngest Cloud.\n   */\n  private readonly fns: Record<\n    string,\n    { fn: InngestFunction.Any; onFailure: boolean }\n  > = {};\n\n  private env: Env = allProcessEnv();\n\n  private allowExpiredSignatures: boolean;\n\n  private readonly _options: InngestCommHandlerOptions<\n    Input,\n    Output,\n    StreamOutput\n  >;\n\n  private readonly skipSignatureValidation: boolean;\n\n  constructor(options: InngestCommHandlerOptions<Input, Output, StreamOutput>) {\n    // Set input options directly so we can reference them later\n    this._options = options;\n\n    /**\n     * v2 -> v3 migration error.\n     *\n     * If a serve handler is passed a client as the first argument, it'll be\n     * spread in to these options. We should be able to detect this by picking\n     * up a unique property on the object.\n     */\n    if (Object.hasOwn(options, \"eventKey\")) {\n      throw new Error(\n        `${logPrefix} You've passed an Inngest client as the first argument to your serve handler. This is no longer supported in v3; please pass the Inngest client as the \\`client\\` property of an options object instead. See https://www.inngest.com/docs/sdk/migration`,\n      );\n    }\n\n    this.frameworkName = options.frameworkName;\n    this.client = options.client as Inngest.Any;\n\n    if (options.id) {\n      console.warn(\n        `${logPrefix} The \\`id\\` serve option is deprecated and will be removed in v4`,\n      );\n    }\n    this.id = options.id || this.client.id;\n\n    this.handler = options.handler as Handler;\n\n    /**\n     * Provide a hidden option to allow expired signatures to be accepted during\n     * testing.\n     */\n    this.allowExpiredSignatures = Boolean(\n      // biome-ignore lint/complexity/noArguments: <explanation>\n      arguments[\"0\"]?.__testingAllowExpiredSignatures,\n    );\n\n    // Ensure we filter any undefined functions in case of missing imports.\n    this.rawFns = options.functions.filter(Boolean) as InngestFunction.Any[];\n\n    if (this.rawFns.length !== options.functions.length) {\n      // TODO PrettyError\n      console.warn(\n        `Some functions passed to serve() are undefined and misconfigured.  Please check your imports.`,\n      );\n    }\n\n    this.fns = this.rawFns.reduce<\n      Record<string, { fn: InngestFunction.Any; onFailure: boolean }>\n    >((acc, fn) => {\n      const configs = fn[\"getConfig\"]({\n        baseUrl: new URL(\"https://example.com\"),\n        appPrefix: this.id,\n      });\n\n      const fns = configs.reduce((acc, { id }, index) => {\n        return { ...acc, [id]: { fn, onFailure: Boolean(index) } };\n      }, {});\n\n      // biome-ignore lint/complexity/noForEach: <explanation>\n      configs.forEach(({ id }) => {\n        if (acc[id]) {\n          // TODO PrettyError\n          throw new Error(\n            `Duplicate function ID \"${id}\"; please change a function's name or provide an explicit ID to avoid conflicts.`,\n          );\n        }\n      });\n\n      return {\n        ...acc,\n        ...fns,\n      };\n    }, {});\n\n    this.inngestRegisterUrl = new URL(\"/fn/register\", this.apiBaseUrl);\n\n    this.signingKey = options.signingKey;\n    this.signingKeyFallback = options.signingKeyFallback;\n    this._serveHost = options.serveHost || this.env[envKeys.InngestServeHost];\n    this._servePath = options.servePath || this.env[envKeys.InngestServePath];\n\n    this.skipSignatureValidation = options.skipSignatureValidation || false;\n\n    const defaultLogLevel: typeof this.logLevel = \"info\";\n    this.logLevel = z\n      .enum(logLevels)\n      .default(defaultLogLevel)\n      .catch((ctx) => {\n        this.log(\n          \"warn\",\n          `Unknown log level passed: ${String(\n            ctx.input,\n          )}; defaulting to ${defaultLogLevel}`,\n        );\n\n        return defaultLogLevel;\n      })\n      .parse(options.logLevel || this.env[envKeys.InngestLogLevel]);\n\n    if (this.logLevel === \"debug\") {\n      /**\n       * `debug` is an old library; sometimes its runtime detection doesn't work\n       * for newer pairings of framework/runtime.\n       *\n       * One silly symptom of this is that `Debug()` returns an anonymous\n       * function with no extra properties instead of a `Debugger` instance if\n       * the wrong code is consumed following a bad detection. This results in\n       * the following `.enable()` call failing, so we just try carefully to\n       * enable it here.\n       */\n      if (debug.enable && typeof debug.enable === \"function\") {\n        debug.enable(`${debugPrefix}:*`);\n      }\n    }\n\n    const defaultStreamingOption: typeof this.streaming = false;\n    this.streaming = z\n      .union([z.enum([\"allow\", \"force\"]), z.literal(false)])\n      .default(defaultStreamingOption)\n      .catch((ctx) => {\n        this.log(\n          \"warn\",\n          `Unknown streaming option passed: ${String(\n            ctx.input,\n          )}; defaulting to ${String(defaultStreamingOption)}`,\n        );\n\n        return defaultStreamingOption;\n      })\n      .parse(options.streaming || this.env[envKeys.InngestStreaming]);\n\n    this.fetch = options.fetch ? getFetch(options.fetch) : this.client[\"fetch\"];\n  }\n\n  /**\n   * Get the API base URL for the Inngest API.\n   *\n   * This is a getter to encourage checking the environment for the API base URL\n   * each time it's accessed, as it may change during execution.\n   */\n  protected get apiBaseUrl(): string {\n    return (\n      this._options.baseUrl ||\n      this.env[envKeys.InngestApiBaseUrl] ||\n      this.env[envKeys.InngestBaseUrl] ||\n      this.client.apiBaseUrl ||\n      defaultInngestApiBaseUrl\n    );\n  }\n\n  /**\n   * Get the event API base URL for the Inngest API.\n   *\n   * This is a getter to encourage checking the environment for the event API\n   * base URL each time it's accessed, as it may change during execution.\n   */\n  protected get eventApiBaseUrl(): string {\n    return (\n      this._options.baseUrl ||\n      this.env[envKeys.InngestEventApiBaseUrl] ||\n      this.env[envKeys.InngestBaseUrl] ||\n      this.client.eventBaseUrl ||\n      defaultInngestEventBaseUrl\n    );\n  }\n\n  /**\n   * The host used to access the Inngest serve endpoint, e.g.:\n   *\n   *     \"https://myapp.com\"\n   *\n   * By default, the library will try to infer this using request details such\n   * as the \"Host\" header and request path, but sometimes this isn't possible\n   * (e.g. when running in a more controlled environments such as AWS Lambda or\n   * when dealing with proxies/redirects).\n   *\n   * Provide the custom hostname here to ensure that the path is reported\n   * correctly when registering functions with Inngest.\n   *\n   * To also provide a custom path, use `servePath`.\n   */\n  protected get serveHost(): string | undefined {\n    return this._serveHost || this.env[envKeys.InngestServeHost];\n  }\n\n  /**\n   * The path to the Inngest serve endpoint. e.g.:\n   *\n   *     \"/some/long/path/to/inngest/endpoint\"\n   *\n   * By default, the library will try to infer this using request details such\n   * as the \"Host\" header and request path, but sometimes this isn't possible\n   * (e.g. when running in a more controlled environments such as AWS Lambda or\n   * when dealing with proxies/redirects).\n   *\n   * Provide the custom path (excluding the hostname) here to ensure that the\n   * path is reported correctly when registering functions with Inngest.\n   *\n   * To also provide a custom hostname, use `serveHost`.\n   *\n   * This is a getter to encourage checking the environment for the serve path\n   * each time it's accessed, as it may change during execution.\n   */\n  protected get servePath(): string | undefined {\n    return this._servePath || this.env[envKeys.InngestServePath];\n  }\n\n  private get hashedEventKey(): string | undefined {\n    if (!this.client[\"eventKey\"] || this.client[\"eventKey\"] === dummyEventKey) {\n      return undefined;\n    }\n    return hashEventKey(this.client[\"eventKey\"]);\n  }\n\n  // hashedSigningKey creates a sha256 checksum of the signing key with the\n  // same signing key prefix.\n  private get hashedSigningKey(): string | undefined {\n    if (!this.signingKey) {\n      return undefined;\n    }\n    return hashSigningKey(this.signingKey);\n  }\n\n  private get hashedSigningKeyFallback(): string | undefined {\n    if (!this.signingKeyFallback) {\n      return undefined;\n    }\n    return hashSigningKey(this.signingKeyFallback);\n  }\n\n  /**\n   * Returns a `boolean` representing whether this handler will stream responses\n   * or not. Takes into account the user's preference and the platform's\n   * capabilities.\n   */\n  private async shouldStream(\n    actions: HandlerResponseWithErrors,\n  ): Promise<boolean> {\n    const rawProbe = await actions.queryStringWithDefaults(\n      \"testing for probe\",\n      queryKeys.Probe,\n    );\n    if (rawProbe !== undefined) {\n      return false;\n    }\n\n    // We must be able to stream responses to continue.\n    if (!actions.transformStreamingResponse) {\n      return false;\n    }\n\n    // If the user has forced streaming, we should always stream.\n    if (this.streaming === \"force\") {\n      return true;\n    }\n\n    // If the user has allowed streaming, we should stream if the platform\n    // supports it.\n    return (\n      this.streaming === \"allow\" &&\n      platformSupportsStreaming(\n        this.frameworkName as SupportedFrameworkName,\n        this.env,\n      )\n    );\n  }\n\n  /**\n   * `createHandler` should be used to return a type-equivalent version of the\n   * `handler` specified during instantiation.\n   *\n   * @example\n   * ```\n   * // my-custom-handler.ts\n   * import {\n   *   InngestCommHandler,\n   *   type ServeHandlerOptions,\n   * } from \"./components/InngestCommHandler\";\n   *\n   * export const serve = (options: ServeHandlerOptions) => {\n   *   const handler = new InngestCommHandler({\n   *     frameworkName: \"my-custom-handler\",\n   *     ...options,\n   *     handler: (req: Request) => {\n   *       return {\n   *         body: () => req.json(),\n   *         headers: (key) => req.headers.get(key),\n   *         method: () => req.method,\n   *         url: () => new URL(req.url, `https://${req.headers.get(\"host\") || \"\"}`),\n   *         transformResponse: ({ body, status, headers }) => {\n   *           return new Response(body, { status, headers });\n   *         },\n   *       };\n   *     },\n   *   });\n   *\n   *   return handler.createHandler();\n   * };\n   * ```\n   */\n  public createHandler(): (...args: Input) => Promise<Awaited<Output>> {\n    const handler = async (...args: Input) => {\n      const timer = new ServerTiming();\n\n      /**\n       * Used for testing, allow setting action overrides externally when\n       * calling the handler. Always search the final argument.\n       */\n      const lastArg = args[args.length - 1] as unknown;\n      const actionOverrides =\n        typeof lastArg === \"object\" &&\n        lastArg !== null &&\n        \"actionOverrides\" in lastArg &&\n        typeof lastArg[\"actionOverrides\"] === \"object\" &&\n        lastArg[\"actionOverrides\"] !== null\n          ? lastArg[\"actionOverrides\"]\n          : {};\n\n      /**\n       * We purposefully `await` the handler, as it could be either sync or\n       * async.\n       */\n      const rawActions = {\n        ...(await timer\n          .wrap(\"handler\", () => this.handler(...args))\n          .catch(rethrowError(\"Serve handler failed to run\"))),\n        ...actionOverrides,\n      };\n\n      /**\n       * Map over every `action` in `rawActions` and create a new `actions`\n       * object where each function is safely promisified with each access\n       * requiring a reason.\n       *\n       * This helps us provide high quality errors about what's going wrong for\n       * each access without having to wrap every access in a try/catch.\n       */\n      const promisifiedActions: ActionHandlerResponseWithErrors =\n        Object.entries(rawActions).reduce((acc, [key, value]) => {\n          if (typeof value !== \"function\") {\n            return acc;\n          }\n\n          return {\n            ...acc,\n            [key]: (reason: string, ...args: unknown[]) => {\n              const errMessage = [\n                `Failed calling \\`${key}\\` from serve handler`,\n                reason,\n              ]\n                .filter(Boolean)\n                .join(\" when \");\n\n              const fn = () =>\n                (value as (...args: unknown[]) => unknown)(...args);\n\n              return runAsPromise(fn)\n                .catch(rethrowError(errMessage))\n                .catch((err) => {\n                  this.log(\"error\", err);\n                  throw err;\n                });\n            },\n          };\n        }, {} as ActionHandlerResponseWithErrors);\n\n      /**\n       * Mapped promisified handlers from userland `serve()` function mixed in\n       * with some helpers.\n       */\n      const actions: HandlerResponseWithErrors = {\n        ...promisifiedActions,\n        queryStringWithDefaults: async (\n          reason: string,\n          key: string,\n        ): Promise<string | undefined> => {\n          const url = await actions.url(reason);\n\n          const ret =\n            (await actions.queryString?.(reason, key, url)) ||\n            url.searchParams.get(key) ||\n            undefined;\n\n          return ret;\n        },\n        ...actionOverrides,\n      };\n\n      const [env, expectedServerKind] = await Promise.all([\n        actions.env?.(\"starting to handle request\"),\n        actions.headers(\n          \"checking expected server kind\",\n          headerKeys.InngestServerKind,\n        ),\n      ]);\n\n      // Always make sure to merge whatever env we've been given with\n      // `process.env`; some platforms may not provide all the necessary\n      // environment variables or may use two sources.\n      this.env = {\n        ...allProcessEnv(),\n        ...env,\n      };\n\n      const getInngestHeaders = (): Record<string, string> =>\n        inngestHeaders({\n          env: this.env,\n          framework: this.frameworkName,\n          client: this.client,\n          expectedServerKind: expectedServerKind || undefined,\n          extras: {\n            \"Server-Timing\": timer.getHeader(),\n          },\n        });\n\n      const assumedMode = getMode({ env: this.env, client: this.client });\n\n      if (assumedMode.isExplicit) {\n        this._mode = assumedMode;\n      } else {\n        const serveIsProd = await actions.isProduction?.(\n          \"starting to handle request\",\n        );\n        if (typeof serveIsProd === \"boolean\") {\n          this._mode = new Mode({\n            type: serveIsProd ? \"cloud\" : \"dev\",\n            isExplicit: false,\n          });\n        } else {\n          this._mode = assumedMode;\n        }\n      }\n\n      this.upsertKeysFromEnv();\n\n      const methodP = actions.method(\"starting to handle request\");\n\n      const headerPromises = [\n        headerKeys.TraceParent,\n        headerKeys.TraceState,\n      ].map(async (header) => {\n        const value = await actions.headers(\n          `fetching ${header} for forwarding`,\n          header,\n        );\n\n        return { header, value };\n      });\n\n      const contentLength = await actions\n        .headers(\"checking signature for request\", headerKeys.ContentLength)\n        .then((value) => {\n          if (!value) {\n            return undefined;\n          }\n          return Number.parseInt(value, 10);\n        });\n\n      const [signature, method, body] = await Promise.all([\n        actions\n          .headers(\"checking signature for request\", headerKeys.Signature)\n          .then((headerSignature) => {\n            return headerSignature ?? undefined;\n          }),\n        methodP,\n        methodP.then((method) => {\n          if (method === \"POST\" || method === \"PUT\") {\n            if (!contentLength) {\n              // Return empty string because req.json() will throw an error.\n              return \"\";\n            }\n\n            return actions.body(\n              `checking body for request signing as method is ${method}`,\n            );\n          }\n\n          return \"\";\n        }),\n      ]);\n\n      const signatureValidation = this.validateSignature(signature, body);\n\n      const headersToForwardP = Promise.all(headerPromises).then(\n        (fetchedHeaders) => {\n          return fetchedHeaders.reduce<Record<string, string>>(\n            (acc, { header, value }) => {\n              if (value) {\n                acc[header] = value;\n              }\n\n              return acc;\n            },\n            {},\n          );\n        },\n      );\n\n      const actionRes = timer.wrap(\"action\", () =>\n        this.handleAction({\n          actions,\n          timer,\n          getInngestHeaders,\n          reqArgs: args,\n          signatureValidation,\n\n          body,\n          method,\n          headers: headersToForwardP,\n        }),\n      );\n\n      /**\n       * Prepares an action response by merging returned data to provide\n       * trailing information such as `Server-Timing` headers.\n       *\n       * It should always prioritize the headers returned by the action, as they\n       * may contain important information such as `Content-Type`.\n       */\n      const prepareActionRes = async (\n        res: ActionResponse,\n      ): Promise<ActionResponse> => {\n        const headers: Record<string, string> = {\n          ...getInngestHeaders(),\n          ...(await headersToForwardP),\n          ...res.headers,\n          ...(res.version === null\n            ? {}\n            : {\n                [headerKeys.RequestVersion]: (\n                  res.version ?? PREFERRED_EXECUTION_VERSION\n                ).toString(),\n              }),\n        };\n\n        let signature: string | undefined;\n\n        try {\n          signature = await signatureValidation.then((result) => {\n            if (!result.success || !result.keyUsed) {\n              return undefined;\n            }\n\n            return this.getResponseSignature(result.keyUsed, res.body);\n          });\n        } catch (err) {\n          // If we fail to sign, retun a 500 with the error.\n          return {\n            ...res,\n            headers,\n            body: stringify(serializeError(err)),\n            status: 500,\n          };\n        }\n\n        if (signature) {\n          headers[headerKeys.Signature] = signature;\n        }\n\n        return {\n          ...res,\n          headers,\n        };\n      };\n\n      if (await this.shouldStream(actions)) {\n        const method = await actions.method(\"starting streaming response\");\n\n        if (method === \"POST\") {\n          const { stream, finalize } = await createStream();\n\n          /**\n           * Errors are handled by `handleAction` here to ensure that an\n           * appropriate response is always given.\n           */\n          void actionRes.then((res) => {\n            return finalize(prepareActionRes(res));\n          });\n\n          return timer.wrap(\"res\", () => {\n            return actions.transformStreamingResponse?.(\n              \"starting streaming response\",\n              {\n                status: 201,\n                headers: getInngestHeaders(),\n                body: stream,\n                version: null,\n              },\n            );\n          });\n        }\n      }\n\n      return timer.wrap(\"res\", async () => {\n        return actionRes.then(prepareActionRes).then((actionRes) => {\n          return actions.transformResponse(\"sending back response\", actionRes);\n        });\n      });\n    };\n\n    /**\n     * Some platforms check (at runtime) the length of the function being used\n     * to handle an endpoint. If this is a variadic function, it will fail that\n     * check.\n     *\n     * Therefore, we expect the arguments accepted to be the same length as the\n     * `handler` function passed internally.\n     *\n     * We also set a name to avoid a common useless name in tracing such as\n     * `\"anonymous\"` or `\"bound function\"`.\n     *\n     * https://github.com/getsentry/sentry-javascript/issues/3284\n     */\n    Object.defineProperties(handler, {\n      name: {\n        value: \"InngestHandler\",\n      },\n      length: {\n        value: this.handler.length,\n      },\n    });\n\n    return handler;\n  }\n\n  // biome-ignore lint/correctness/noUnusedPrivateClassMembers: used in the SDK\n  private get mode(): Mode | undefined {\n    return this._mode;\n  }\n\n  // biome-ignore lint/correctness/noUnusedPrivateClassMembers: used in the SDK\n  private set mode(m) {\n    this._mode = m;\n\n    if (m) {\n      this.client[\"mode\"] = m;\n    }\n  }\n\n  /**\n   * Given a set of functions to check if an action is available from the\n   * instance's handler, enact any action that is found.\n   *\n   * This method can fetch varying payloads of data, but ultimately is the place\n   * where _decisions_ are made regarding functionality.\n   *\n   * For example, if we find that we should be viewing the UI, this function\n   * will decide whether the UI should be visible based on the payload it has\n   * found (e.g. env vars, options, etc).\n   */\n  private async handleAction({\n    actions,\n    timer,\n    getInngestHeaders,\n    reqArgs,\n    signatureValidation,\n    body,\n    method,\n    headers,\n  }: {\n    actions: HandlerResponseWithErrors;\n    timer: ServerTiming;\n    getInngestHeaders: () => Record<string, string>;\n    reqArgs: unknown[];\n    signatureValidation: ReturnType<InngestCommHandler[\"validateSignature\"]>;\n    // biome-ignore lint/suspicious/noExplicitAny: <explanation>\n    body: any;\n    method: string;\n    headers: Promise<Record<string, string>>;\n  }): Promise<ActionResponse> {\n    // This is when the request body is completely missing; it does not\n    // include an empty body. This commonly happens when the HTTP framework\n    // doesn't have body parsing middleware.\n    const isMissingBody = body === undefined;\n\n    try {\n      let url = await actions.url(\"starting to handle request\");\n\n      if (method === \"POST\") {\n        if (isMissingBody) {\n          this.log(\n            \"error\",\n            \"Missing body when executing, possibly due to missing request body middleware\",\n          );\n\n          return {\n            status: 500,\n            headers: {\n              \"Content-Type\": \"application/json\",\n            },\n            body: stringify(\n              serializeError(\n                new Error(\n                  \"Missing request body when executing, possibly due to missing request body middleware\",\n                ),\n              ),\n            ),\n            version: undefined,\n          };\n        }\n\n        const validationResult = await signatureValidation;\n        if (!validationResult.success) {\n          return {\n            status: 401,\n            headers: {\n              \"Content-Type\": \"application/json\",\n            },\n            body: stringify(serializeError(validationResult.err)),\n            version: undefined,\n          };\n        }\n\n        const rawProbe = await actions.queryStringWithDefaults(\n          \"testing for probe\",\n          queryKeys.Probe,\n        );\n        if (rawProbe) {\n          const probe = enumFromValue(probeEnum, rawProbe);\n          if (!probe) {\n            // If we're here, we've received a probe that we don't recognize.\n            // Fail.\n            return {\n              status: 400,\n              headers: {\n                \"Content-Type\": \"application/json\",\n              },\n              body: stringify(\n                serializeError(new Error(`Unknown probe \"${rawProbe}\"`)),\n              ),\n              version: undefined,\n            };\n          }\n\n          // Provide actions for every probe available.\n          const probeActions: Record<\n            probeEnum,\n            () => MaybePromise<ActionResponse>\n          > = {\n            [probeEnum.Trust]: () => ({\n              status: 200,\n              headers: {\n                \"Content-Type\": \"application/json\",\n              },\n              body: \"\",\n              version: undefined,\n            }),\n          };\n\n          return probeActions[probe]();\n        }\n\n        const fnId = await actions.queryStringWithDefaults(\n          \"processing run request\",\n          queryKeys.FnId,\n        );\n        if (!fnId) {\n          // TODO PrettyError\n          throw new Error(\"No function ID found in request\");\n        }\n\n        const stepId =\n          (await actions.queryStringWithDefaults(\n            \"processing run request\",\n            queryKeys.StepId,\n          )) || null;\n\n        const { version, result } = this.runStep({\n          functionId: fnId,\n          data: body,\n          stepId,\n          timer,\n          reqArgs,\n          headers: await headers,\n        });\n        const stepOutput = await result;\n\n        /**\n         * Functions can return `undefined`, but we'll always convert this to\n         * `null`, as this is appropriately serializable by JSON.\n         */\n        const opDataUndefinedToNull = (op: OutgoingOp) => {\n          op.data = undefinedToNull(op.data);\n          return op;\n        };\n\n        const resultHandlers: ExecutionResultHandlers<ActionResponse> = {\n          \"function-rejected\": (result) => {\n            return {\n              status: result.retriable ? 500 : 400,\n              headers: {\n                \"Content-Type\": \"application/json\",\n                [headerKeys.NoRetry]: result.retriable ? \"false\" : \"true\",\n                ...(typeof result.retriable === \"string\"\n                  ? { [headerKeys.RetryAfter]: result.retriable }\n                  : {}),\n              },\n              body: stringify(undefinedToNull(result.error)),\n              version,\n            };\n          },\n          \"function-resolved\": (result) => {\n            return {\n              status: 200,\n              headers: {\n                \"Content-Type\": \"application/json\",\n              },\n              body: stringify(undefinedToNull(result.data)),\n              version,\n            };\n          },\n          \"step-not-found\": (result) => {\n            return {\n              status: 500,\n              headers: {\n                \"Content-Type\": \"application/json\",\n                [headerKeys.NoRetry]: \"false\",\n              },\n              body: stringify({\n                error: `Could not find step \"${\n                  result.step.displayName || result.step.id\n                }\" to run; timed out`,\n              }),\n              version,\n            };\n          },\n          \"step-ran\": (result) => {\n            const step = opDataUndefinedToNull(result.step);\n\n            return {\n              status: 206,\n              headers: {\n                \"Content-Type\": \"application/json\",\n                ...(typeof result.retriable !== \"undefined\"\n                  ? {\n                      [headerKeys.NoRetry]: result.retriable ? \"false\" : \"true\",\n                      ...(typeof result.retriable === \"string\"\n                        ? { [headerKeys.RetryAfter]: result.retriable }\n                        : {}),\n                    }\n                  : {}),\n              },\n              body: stringify([step]),\n              version,\n            };\n          },\n          \"steps-found\": (result) => {\n            const steps = result.steps.map(opDataUndefinedToNull);\n\n            return {\n              status: 206,\n              headers: {\n                \"Content-Type\": \"application/json\",\n              },\n              body: stringify(steps),\n              version,\n            };\n          },\n        };\n\n        const handler = resultHandlers[\n          stepOutput.type\n        ] as ExecutionResultHandler<ActionResponse>;\n\n        try {\n          return await handler(stepOutput);\n        } catch (err) {\n          this.log(\"error\", \"Error handling execution result\", err);\n          throw err;\n        }\n      }\n\n      // TODO: This feels hacky, so we should probably make it not hacky.\n      const env = getInngestHeaders()[headerKeys.Environment] ?? null;\n\n      if (method === \"GET\") {\n        return {\n          status: 200,\n          body: stringify(\n            await this.introspectionBody({\n              actions,\n              env,\n              signatureValidation,\n              url,\n            }),\n          ),\n          headers: {\n            \"Content-Type\": \"application/json\",\n          },\n          version: undefined,\n        };\n      }\n\n      if (method === \"PUT\") {\n        const [deployId, inBandSyncRequested] = await Promise.all([\n          actions\n            .queryStringWithDefaults(\n              \"processing deployment request\",\n              queryKeys.DeployId,\n            )\n            .then((deployId) => {\n              return deployId === \"undefined\" ? undefined : deployId;\n            }),\n\n          Promise.resolve(\n            parseAsBoolean(this.env[envKeys.InngestAllowInBandSync]),\n          )\n            .then((allowInBandSync) => {\n              if (allowInBandSync !== undefined && !allowInBandSync) {\n                return syncKind.OutOfBand;\n              }\n\n              return actions.headers(\n                \"processing deployment request\",\n                headerKeys.InngestSyncKind,\n              );\n            })\n            .then((kind) => {\n              return kind === syncKind.InBand;\n            }),\n        ]);\n\n        if (inBandSyncRequested) {\n          if (isMissingBody) {\n            this.log(\n              \"error\",\n              \"Missing body when syncing, possibly due to missing request body middleware\",\n            );\n\n            return {\n              status: 500,\n              headers: {\n                \"Content-Type\": \"application/json\",\n              },\n              body: stringify(\n                serializeError(\n                  new Error(\n                    \"Missing request body when syncing, possibly due to missing request body middleware\",\n                  ),\n                ),\n              ),\n              version: undefined,\n            };\n          }\n\n          // Validation can be successful if we're in dev mode and did not\n          // actually validate a key. In this case, also check that we did indeed\n          // use a particular key to validate.\n          const sigCheck = await signatureValidation;\n\n          if (!sigCheck.success) {\n            return {\n              status: 401,\n              body: stringify({\n                code: \"sig_verification_failed\",\n              }),\n              headers: {\n                \"Content-Type\": \"application/json\",\n              },\n              version: undefined,\n            };\n          }\n\n          const res = inBandSyncRequestBodySchema.safeParse(body);\n          if (!res.success) {\n            return {\n              status: 400,\n              body: stringify({\n                code: \"invalid_request\",\n                message: res.error.message,\n              }),\n              headers: {\n                \"Content-Type\": \"application/json\",\n              },\n              version: undefined,\n            };\n          }\n\n          // We can trust the URL here because it's coming from\n          // signature-verified request.\n          url = this.reqUrl(new URL(res.data.url));\n\n          // This should be an in-band sync\n          const respBody = await this.inBandRegisterBody({\n            actions,\n            deployId,\n            env,\n            signatureValidation,\n            url,\n          });\n\n          return {\n            status: 200,\n            body: stringify(respBody),\n            headers: {\n              \"Content-Type\": \"application/json\",\n              [headerKeys.InngestSyncKind]: syncKind.InBand,\n            },\n            version: undefined,\n          };\n        }\n\n        // If we're here, this is a legacy out-of-band sync\n        const { status, message, modified } = await this.register(\n          this.reqUrl(url),\n          deployId,\n          getInngestHeaders,\n        );\n\n        return {\n          status,\n          body: stringify({ message, modified }),\n          headers: {\n            \"Content-Type\": \"application/json\",\n            [headerKeys.InngestSyncKind]: syncKind.OutOfBand,\n          },\n          version: undefined,\n        };\n      }\n    } catch (err) {\n      return {\n        status: 500,\n        body: stringify({\n          type: \"internal\",\n          ...serializeError(err as Error),\n        }),\n        headers: {\n          \"Content-Type\": \"application/json\",\n        },\n        version: undefined,\n      };\n    }\n\n    return {\n      status: 405,\n      body: JSON.stringify({\n        message: \"No action found; request was likely not POST, PUT, or GET\",\n        mode: this._mode,\n      }),\n      headers: {},\n      version: undefined,\n    };\n  }\n\n  protected runStep({\n    functionId,\n    stepId,\n    data,\n    timer,\n    reqArgs,\n    headers,\n  }: {\n    functionId: string;\n    stepId: string | null;\n    data: unknown;\n    timer: ServerTiming;\n    reqArgs: unknown[];\n    headers: Record<string, string>;\n  }): { version: ExecutionVersion; result: Promise<ExecutionResult> } {\n    const fn = this.fns[functionId];\n    if (!fn) {\n      // TODO PrettyError\n      throw new Error(`Could not find function with ID \"${functionId}\"`);\n    }\n\n    const immediateFnData = parseFnData(data);\n    let { version } = immediateFnData;\n\n    // Handle opting in to optimized parallelism in v3.\n    if (\n      version === ExecutionVersion.V1 &&\n      fn.fn[\"shouldOptimizeParallelism\"]?.()\n    ) {\n      version = ExecutionVersion.V2;\n    }\n\n    const result = runAsPromise(async () => {\n      const anyFnData = await fetchAllFnData({\n        data: immediateFnData,\n        api: this.client[\"inngestApi\"],\n        version,\n      });\n      if (!anyFnData.ok) {\n        throw new Error(anyFnData.error);\n      }\n\n      type ExecutionStarter<V> = (\n        fnData: V extends ExecutionVersion\n          ? Extract<FnData, { version: V }>\n          : FnData,\n      ) => MaybePromise<CreateExecutionOptions>;\n\n      type GenericExecutionStarters = Record<\n        ExecutionVersion,\n        ExecutionStarter<unknown>\n      >;\n\n      type ExecutionStarters = {\n        [V in ExecutionVersion]: ExecutionStarter<V>;\n      };\n\n      const executionStarters = ((s: ExecutionStarters) =>\n        s as GenericExecutionStarters)({\n        [ExecutionVersion.V0]: ({ event, events, steps, ctx, version }) => {\n          const stepState = Object.entries(steps ?? {}).reduce<\n            InngestExecutionOptions[\"stepState\"]\n          >((acc, [id, data]) => {\n            return {\n              ...acc,\n\n              [id]: { id, data },\n            };\n          }, {});\n\n          return {\n            version,\n            partialOptions: {\n              client: this.client,\n              runId: ctx?.run_id || \"\",\n              data: {\n                event: event as EventPayload,\n                events: events as [EventPayload, ...EventPayload[]],\n                runId: ctx?.run_id || \"\",\n                attempt: ctx?.attempt ?? 0,\n              },\n              stepState,\n              requestedRunStep:\n                stepId === \"step\" ? undefined : stepId || undefined,\n              timer,\n              isFailureHandler: fn.onFailure,\n              stepCompletionOrder: ctx?.stack?.stack ?? [],\n              reqArgs,\n              headers,\n            },\n          };\n        },\n        [ExecutionVersion.V1]: ({ event, events, steps, ctx, version }) => {\n          const stepState = Object.entries(steps ?? {}).reduce<\n            InngestExecutionOptions[\"stepState\"]\n          >((acc, [id, result]) => {\n            return {\n              ...acc,\n              [id]:\n                result.type === \"data\"\n                  ? { id, data: result.data }\n                  : result.type === \"input\"\n                    ? { id, input: result.input }\n                    : { id, error: result.error },\n            };\n          }, {});\n\n          return {\n            version,\n            partialOptions: {\n              client: this.client,\n              runId: ctx?.run_id || \"\",\n              data: {\n                event: event as EventPayload,\n                events: events as [EventPayload, ...EventPayload[]],\n                runId: ctx?.run_id || \"\",\n                attempt: ctx?.attempt ?? 0,\n              },\n              stepState,\n              requestedRunStep:\n                stepId === \"step\" ? undefined : stepId || undefined,\n              timer,\n              isFailureHandler: fn.onFailure,\n              disableImmediateExecution: ctx?.disable_immediate_execution,\n              stepCompletionOrder: ctx?.stack?.stack ?? [],\n              reqArgs,\n              headers,\n            },\n          };\n        },\n        [ExecutionVersion.V2]: ({ event, events, steps, ctx, version }) => {\n          const stepState = Object.entries(steps ?? {}).reduce<\n            InngestExecutionOptions[\"stepState\"]\n          >((acc, [id, result]) => {\n            return {\n              ...acc,\n              [id]:\n                result.type === \"data\"\n                  ? { id, data: result.data }\n                  : result.type === \"input\"\n                    ? { id, input: result.input }\n                    : { id, error: result.error },\n            };\n          }, {});\n\n          return {\n            version,\n            partialOptions: {\n              client: this.client,\n              runId: ctx?.run_id || \"\",\n              data: {\n                event: event as EventPayload,\n                events: events as [EventPayload, ...EventPayload[]],\n                runId: ctx?.run_id || \"\",\n                attempt: ctx?.attempt ?? 0,\n              },\n              stepState,\n              requestedRunStep:\n                stepId === \"step\" ? undefined : stepId || undefined,\n              timer,\n              isFailureHandler: fn.onFailure,\n              disableImmediateExecution: ctx?.disable_immediate_execution,\n              stepCompletionOrder: ctx?.stack?.stack ?? [],\n              reqArgs,\n              headers,\n            },\n          };\n        },\n      });\n\n      const executionOptions = await executionStarters[version](\n        anyFnData.value,\n      );\n\n      return fn.fn[\"createExecution\"](executionOptions).start();\n    });\n\n    return { version, result };\n  }\n\n  protected configs(url: URL): FunctionConfig[] {\n    const configs = Object.values(this.rawFns).reduce<FunctionConfig[]>(\n      (acc, fn) => [\n        ...acc,\n        ...fn[\"getConfig\"]({ baseUrl: url, appPrefix: this.id }),\n      ],\n      [],\n    );\n\n    for (const config of configs) {\n      const check = functionConfigSchema.safeParse(config);\n      if (!check.success) {\n        const errors = check.error.errors.map((err) => err.message).join(\"; \");\n\n        this.log(\n          \"warn\",\n          `Config invalid for function \"${config.id}\" : ${errors}`,\n        );\n      }\n    }\n\n    return configs;\n  }\n\n  /**\n   * Return an Inngest serve endpoint URL given a potential `path` and `host`.\n   *\n   * Will automatically use the `serveHost` and `servePath` if they have been\n   * set when registering.\n   */\n  protected reqUrl(url: URL): URL {\n    let ret = new URL(url);\n\n    const serveHost = this.serveHost || this.env[envKeys.InngestServeHost];\n    const servePath = this.servePath || this.env[envKeys.InngestServePath];\n\n    if (servePath) {\n      ret.pathname = servePath;\n    }\n\n    if (serveHost) {\n      ret = new URL(ret.pathname + ret.search, serveHost);\n    }\n\n    return ret;\n  }\n\n  protected registerBody({\n    url,\n    deployId,\n  }: {\n    url: URL;\n\n    /**\n     * Non-optional to ensure we always consider if we have a deploy ID\n     * available to us to use.\n     */\n    deployId: string | undefined | null;\n  }): RegisterRequest {\n    const body: RegisterRequest = {\n      url: url.href,\n      deployType: \"ping\",\n      framework: this.frameworkName,\n      appName: this.id,\n      functions: this.configs(url),\n      sdk: `js:v${version}`,\n      v: \"0.1\",\n      deployId: deployId || undefined,\n      capabilities: {\n        trust_probe: \"v1\",\n        connect: \"v1\",\n      },\n      appVersion: this.client.appVersion,\n    };\n\n    return body;\n  }\n\n  protected async inBandRegisterBody({\n    actions,\n    deployId,\n    env,\n    signatureValidation,\n    url,\n  }: {\n    actions: HandlerResponseWithErrors;\n\n    /**\n     * Non-optional to ensure we always consider if we have a deploy ID\n     * available to us to use.\n     */\n    deployId: string | undefined | null;\n\n    env: string | null;\n    signatureValidation: ReturnType<InngestCommHandler[\"validateSignature\"]>;\n\n    url: URL;\n  }): Promise<InBandRegisterRequest> {\n    const registerBody = this.registerBody({ deployId, url });\n    const introspectionBody = await this.introspectionBody({\n      actions,\n      env,\n      signatureValidation,\n      url,\n    });\n\n    const body: InBandRegisterRequest = {\n      app_id: this.id,\n      appVersion: this.client.appVersion,\n      capabilities: registerBody.capabilities,\n      env,\n      framework: registerBody.framework,\n      functions: registerBody.functions,\n      inspection: introspectionBody,\n      platform: getPlatformName({\n        ...allProcessEnv(),\n        ...this.env,\n      }),\n      sdk_author: \"inngest\",\n      sdk_language: \"\",\n      sdk_version: \"\",\n      sdk: registerBody.sdk,\n      url: registerBody.url,\n    };\n\n    if (introspectionBody.authentication_succeeded) {\n      body.sdk_language = introspectionBody.sdk_language;\n      body.sdk_version = introspectionBody.sdk_version;\n    }\n\n    return body;\n  }\n\n  protected async introspectionBody({\n    actions,\n    env,\n    signatureValidation,\n    url,\n  }: {\n    actions: HandlerResponseWithErrors;\n    env: string | null;\n    signatureValidation: ReturnType<InngestCommHandler[\"validateSignature\"]>;\n    url: URL;\n  }): Promise<UnauthenticatedIntrospection | AuthenticatedIntrospection> {\n    const registerBody = this.registerBody({\n      url: this.reqUrl(url),\n      deployId: null,\n    });\n\n    if (!this._mode) {\n      throw new Error(\"No mode set; cannot introspect without mode\");\n    }\n\n    let introspection:\n      | UnauthenticatedIntrospection\n      | AuthenticatedIntrospection = {\n      authentication_succeeded: null,\n      extra: {\n        is_mode_explicit: this._mode.isExplicit,\n      },\n      has_event_key: this.client[\"eventKeySet\"](),\n      has_signing_key: Boolean(this.signingKey),\n      function_count: registerBody.functions.length,\n      mode: this._mode.type,\n      schema_version: \"2024-05-24\",\n    } satisfies UnauthenticatedIntrospection;\n\n    // Only allow authenticated introspection in Cloud mode, since Dev mode skips\n    // signature validation\n    if (this._mode.type === \"cloud\") {\n      try {\n        const validationResult = await signatureValidation;\n        if (!validationResult.success) {\n          throw new Error(\"Signature validation failed\");\n        }\n\n        introspection = {\n          ...introspection,\n          authentication_succeeded: true,\n          api_origin: this.apiBaseUrl,\n          app_id: this.id,\n          capabilities: {\n            trust_probe: \"v1\",\n            connect: \"v1\",\n          },\n          env,\n          event_api_origin: this.eventApiBaseUrl,\n          event_key_hash: this.hashedEventKey ?? null,\n          extra: {\n            ...introspection.extra,\n            is_streaming: await this.shouldStream(actions),\n          },\n          framework: this.frameworkName,\n          sdk_language: \"js\",\n          sdk_version: version,\n          serve_origin: this.serveHost ?? null,\n          serve_path: this.servePath ?? null,\n          signing_key_fallback_hash: this.hashedSigningKeyFallback ?? null,\n          signing_key_hash: this.hashedSigningKey ?? null,\n        } satisfies AuthenticatedIntrospection;\n      } catch {\n        // Swallow signature validation error since we'll just return the\n        // unauthenticated introspection\n        introspection = {\n          ...introspection,\n          authentication_succeeded: false,\n        } satisfies UnauthenticatedIntrospection;\n      }\n    }\n\n    return introspection;\n  }\n\n  protected async register(\n    url: URL,\n    deployId: string | undefined | null,\n    getHeaders: () => Record<string, string>,\n  ): Promise<{ status: number; message: string; modified: boolean }> {\n    const body = this.registerBody({ url, deployId });\n\n    let res: globalThis.Response;\n\n    // Whenever we register, we check to see if the dev server is up.  This\n    // is a noop and returns false in production. Clone the URL object to avoid\n    // mutating the property between requests.\n    let registerURL = new URL(this.inngestRegisterUrl.href);\n\n    const inferredDevMode =\n      this._mode && this._mode.isInferred && this._mode.isDev;\n\n    if (inferredDevMode) {\n      const host = devServerHost(this.env);\n      const hasDevServer = await devServerAvailable(host, this.fetch);\n      if (hasDevServer) {\n        registerURL = devServerUrl(host, \"/fn/register\");\n      }\n    } else if (this._mode?.explicitDevUrl) {\n      registerURL = devServerUrl(\n        this._mode.explicitDevUrl.href,\n        \"/fn/register\",\n      );\n    }\n\n    if (deployId) {\n      registerURL.searchParams.set(queryKeys.DeployId, deployId);\n    }\n\n    try {\n      res = await fetchWithAuthFallback({\n        authToken: this.hashedSigningKey,\n        authTokenFallback: this.hashedSigningKeyFallback,\n        fetch: this.fetch,\n        url: registerURL.href,\n        options: {\n          method: \"POST\",\n          body: stringify(body),\n          headers: {\n            ...getHeaders(),\n            [headerKeys.InngestSyncKind]: syncKind.OutOfBand,\n          },\n          redirect: \"follow\",\n        },\n      });\n    } catch (err: unknown) {\n      this.log(\"error\", err);\n\n      return {\n        status: 500,\n        message: `Failed to register${\n          err instanceof Error ? `; ${err.message}` : \"\"\n        }`,\n        modified: false,\n      };\n    }\n\n    const raw = await res.text();\n\n    let data: z.input<typeof registerResSchema> = {};\n\n    try {\n      data = JSON.parse(raw);\n    } catch (err) {\n      this.log(\"warn\", \"Couldn't unpack register response:\", err);\n\n      let message = \"Failed to register\";\n      if (err instanceof Error) {\n        message += `; ${err.message}`;\n      }\n      message += `; status code: ${res.status}`;\n\n      return {\n        status: 500,\n        message,\n        modified: false,\n      };\n    }\n\n    let status: number;\n    let error: string;\n    let skipped: boolean;\n    let modified: boolean;\n    try {\n      ({ status, error, skipped, modified } = registerResSchema.parse(data));\n    } catch (err) {\n      this.log(\"warn\", \"Invalid register response schema:\", err);\n\n      let message = \"Failed to register\";\n      if (err instanceof Error) {\n        message += `; ${err.message}`;\n      }\n      message += `; status code: ${res.status}`;\n\n      return {\n        status: 500,\n        message,\n        modified: false,\n      };\n    }\n\n    // The dev server polls this endpoint to register functions every few\n    // seconds, but we only want to log that we've registered functions if\n    // the function definitions change.  Therefore, we compare the body sent\n    // during registration with the body of the current functions and refuse\n    // to register if the functions are the same.\n    if (!skipped) {\n      this.log(\n        \"debug\",\n        \"registered inngest functions:\",\n        res.status,\n        res.statusText,\n        data,\n      );\n    }\n\n    return { status, message: error, modified };\n  }\n\n  /**\n   * Given an environment, upsert any missing keys. This is useful in\n   * situations where environment variables are passed directly to handlers or\n   * are otherwise difficult to access during initialization.\n   */\n  private upsertKeysFromEnv() {\n    if (this.env[envKeys.InngestSigningKey]) {\n      if (!this.signingKey) {\n        this.signingKey = String(this.env[envKeys.InngestSigningKey]);\n      }\n\n      this.client[\"inngestApi\"].setSigningKey(this.signingKey);\n    }\n\n    if (this.env[envKeys.InngestSigningKeyFallback]) {\n      if (!this.signingKeyFallback) {\n        this.signingKeyFallback = String(\n          this.env[envKeys.InngestSigningKeyFallback],\n        );\n      }\n\n      this.client[\"inngestApi\"].setSigningKeyFallback(this.signingKeyFallback);\n    }\n\n    if (!this.client[\"eventKeySet\"]() && this.env[envKeys.InngestEventKey]) {\n      this.client.setEventKey(String(this.env[envKeys.InngestEventKey]));\n    }\n\n    // v2 -> v3 migration warnings\n    if (this.env[envKeys.InngestDevServerUrl]) {\n      this.log(\n        \"warn\",\n        `Use of ${envKeys.InngestDevServerUrl} has been deprecated in v3; please use ${envKeys.InngestBaseUrl} instead. See https://www.inngest.com/docs/sdk/migration`,\n      );\n    }\n  }\n\n  /**\n   * Validate the signature of a request and return the signing key used to\n   * validate it.\n   */\n\n  protected async validateSignature(\n    sig: string | undefined,\n    body: unknown,\n  ): Promise<\n    { success: true; keyUsed: string } | { success: false; err: Error }\n  > {\n    try {\n      // Skip signature validation if requested (used by connect)\n      if (this.skipSignatureValidation) {\n        return { success: true, keyUsed: \"\" };\n      }\n\n      // Never validate signatures outside of prod. Make sure to check the mode\n      // exists here instead of using nullish coalescing to confirm that the check\n      // has been completed.\n      if (this._mode && !this._mode.isCloud) {\n        return { success: true, keyUsed: \"\" };\n      }\n\n      // If we're here, we're in production; lack of a signing key is an error.\n      if (!this.signingKey) {\n        // TODO PrettyError\n        throw new Error(\n          `No signing key found in client options or ${envKeys.InngestSigningKey} env var. Find your keys at https://app.inngest.com/secrets`,\n        );\n      }\n\n      // If we're here, we're in production; lack of a req signature is an error.\n      if (!sig) {\n        // TODO PrettyError\n        throw new Error(`No ${headerKeys.Signature} provided`);\n      }\n\n      // Validate the signature\n      return {\n        success: true,\n        keyUsed: new RequestSignature(sig).verifySignature({\n          body,\n          allowExpiredSignatures: this.allowExpiredSignatures,\n          signingKey: this.signingKey,\n          signingKeyFallback: this.signingKeyFallback,\n        }),\n      };\n    } catch (err) {\n      return { success: false, err: err as Error };\n    }\n  }\n\n  protected getResponseSignature(key: string, body: string): string {\n    const now = Date.now();\n    const mac = signDataWithKey(body, key, now.toString());\n\n    return `t=${now}&s=${mac}`;\n  }\n\n  /**\n   * Log to stdout/stderr if the log level is set to include the given level.\n   * The default log level is `\"info\"`.\n   *\n   * This is an abstraction over `console.log` and will try to use the correct\n   * method for the given log level.  For example, `log(\"error\", \"foo\")` will\n   * call `console.error(\"foo\")`.\n   */\n  protected log(level: LogLevel, ...args: unknown[]) {\n    const logLevels: LogLevel[] = [\n      \"debug\",\n      \"info\",\n      \"warn\",\n      \"error\",\n      \"fatal\",\n      \"silent\",\n    ];\n\n    const logLevelSetting = logLevels.indexOf(this.logLevel);\n    const currentLevel = logLevels.indexOf(level);\n\n    if (currentLevel >= logLevelSetting) {\n      let logger = console.log;\n\n      if (Object.hasOwn(console, level)) {\n        logger = console[level as keyof typeof console] as typeof logger;\n      }\n\n      logger(`${logPrefix} ${level as string} -`, ...args);\n    }\n  }\n}\n\nclass RequestSignature {\n  public timestamp: string;\n  public signature: string;\n\n  constructor(sig: string) {\n    const params = new URLSearchParams(sig);\n    this.timestamp = params.get(\"t\") || \"\";\n    this.signature = params.get(\"s\") || \"\";\n\n    if (!this.timestamp || !this.signature) {\n      // TODO PrettyError\n      throw new Error(`Invalid ${headerKeys.Signature} provided`);\n    }\n  }\n\n  private hasExpired(allowExpiredSignatures?: boolean) {\n    if (allowExpiredSignatures) {\n      return false;\n    }\n\n    const delta =\n      Date.now() - new Date(Number.parseInt(this.timestamp) * 1000).valueOf();\n    return delta > 1000 * 60 * 5;\n  }\n\n  #verifySignature({\n    body,\n    signingKey,\n    allowExpiredSignatures,\n  }: {\n    body: unknown;\n    signingKey: string;\n    allowExpiredSignatures: boolean;\n  }): void {\n    if (this.hasExpired(allowExpiredSignatures)) {\n      // TODO PrettyError\n      throw new Error(\"Signature has expired\");\n    }\n\n    const mac = signDataWithKey(body, signingKey, this.timestamp);\n    if (mac !== this.signature) {\n      // TODO PrettyError\n      throw new Error(\"Invalid signature\");\n    }\n  }\n\n  public verifySignature({\n    body,\n    signingKey,\n    signingKeyFallback,\n    allowExpiredSignatures,\n  }: {\n    body: unknown;\n    signingKey: string;\n    signingKeyFallback: string | undefined;\n    allowExpiredSignatures: boolean;\n  }): string {\n    try {\n      this.#verifySignature({ body, signingKey, allowExpiredSignatures });\n\n      return signingKey;\n    } catch (err) {\n      if (!signingKeyFallback) {\n        throw err;\n      }\n\n      this.#verifySignature({\n        body,\n        signingKey: signingKeyFallback,\n        allowExpiredSignatures,\n      });\n\n      return signingKeyFallback;\n    }\n  }\n}\n\n/**\n * The broad definition of a handler passed when instantiating an\n * {@link InngestCommHandler} instance.\n */\nexport type Handler<\n  // biome-ignore lint/suspicious/noExplicitAny: <explanation>\n  Input extends any[] = any[],\n  // biome-ignore lint/suspicious/noExplicitAny: <explanation>\n  Output = any,\n  // biome-ignore lint/suspicious/noExplicitAny: <explanation>\n  StreamOutput = any,\n> = (...args: Input) => HandlerResponse<Output, StreamOutput>;\n\n// biome-ignore lint/suspicious/noExplicitAny: <explanation>\nexport type HandlerResponse<Output = any, StreamOutput = any> = {\n  // biome-ignore lint/suspicious/noExplicitAny: <explanation>\n  body: () => MaybePromise<any>;\n  env?: () => MaybePromise<Env | undefined>;\n  headers: (key: string) => MaybePromise<string | null | undefined>;\n\n  /**\n   * Whether the current environment is production. This is used to determine\n   * some functionality like whether to connect to the dev server or whether to\n   * show debug logging.\n   *\n   * If this is not provided--or is provided and returns `undefined`--we'll try\n   * to automatically detect whether we're in production by checking various\n   * environment variables.\n   */\n  isProduction?: () => MaybePromise<boolean | undefined>;\n  method: () => MaybePromise<string>;\n  queryString?: (\n    key: string,\n    url: URL,\n  ) => MaybePromise<string | null | undefined>;\n  url: () => MaybePromise<URL>;\n\n  /**\n   * The `transformResponse` function receives the output of the Inngest SDK and\n   * can decide how to package up that information to appropriately return the\n   * information to Inngest.\n   *\n   * Mostly, this is taking the given parameters and returning a new `Response`.\n   *\n   * The function is passed an {@link ActionResponse}, an object containing a\n   * `status` code, a `headers` object, and a stringified `body`. This ensures\n   * you can appropriately handle the response, including use of any required\n   * parameters such as `res` in Express-/Connect-like frameworks.\n   */\n  transformResponse: (res: ActionResponse<string>) => Output;\n\n  /**\n   * The `transformStreamingResponse` function, if defined, declares that this\n   * handler supports streaming responses back to Inngest. This is useful for\n   * functions that are expected to take a long time, as edge streaming can\n   * often circumvent restrictive request timeouts and other limitations.\n   *\n   * If your handler does not support streaming, do not define this function.\n   *\n   * It receives the output of the Inngest SDK and can decide how to package\n   * up that information to appropriately return the information in a stream\n   * to Inngest.\n   *\n   * Mostly, this is taking the given parameters and returning a new `Response`.\n   *\n   * The function is passed an {@link ActionResponse}, an object containing a\n   * `status` code, a `headers` object, and `body`, a `ReadableStream`. This\n   * ensures you can appropriately handle the response, including use of any\n   * required parameters such as `res` in Express-/Connect-like frameworks.\n   */\n  transformStreamingResponse?: (\n    res: ActionResponse<ReadableStream>,\n  ) => StreamOutput;\n};\n\n/**\n * The response from the Inngest SDK before it is transformed in to a\n * framework-compatible response by an {@link InngestCommHandler} instance.\n */\nexport interface ActionResponse<\n  TBody extends string | ReadableStream = string,\n> {\n  /**\n   * The HTTP status code to return.\n   */\n  status: number;\n\n  /**\n   * The headers to return in the response.\n   */\n  headers: Record<string, string>;\n\n  /**\n   * A stringified body to return.\n   */\n  body: TBody;\n\n  /**\n   * The version of the execution engine that was used to run this action.\n   *\n   * If the action didn't use the execution engine (for example, a GET request\n   * as a health check) or would have but errored before reaching it, this will\n   * be `undefined`.\n   *\n   * If the version should be entirely omitted from the response (for example,\n   * when sending preliminary headers when streaming), this will be `null`.\n   */\n  version: ExecutionVersion | null | undefined;\n}\n\n/**\n * A version of {@link HandlerResponse} where each function is safely\n * promisified and requires a reason for each access.\n *\n * This enables us to provide accurate errors for each access without having to\n * wrap every access in a try/catch.\n */\nexport type ActionHandlerResponseWithErrors = {\n  [K in keyof HandlerResponse]: NonNullable<HandlerResponse[K]> extends (\n    ...args: infer Args\n  ) => infer R\n    ? R extends MaybePromise<infer PR>\n      ? (errMessage: string, ...args: Args) => Promise<PR>\n      : (errMessage: string, ...args: Args) => Promise<R>\n    : HandlerResponse[K];\n};\n\n/**\n * A version of {@link ActionHandlerResponseWithErrors} that includes helper\n * functions that provide sensible defaults on top of the direct access given\n * from the bare response.\n */\nexport interface HandlerResponseWithErrors\n  extends ActionHandlerResponseWithErrors {\n  /**\n   * Fetch a query string value from the request. If no `querystring` action has\n   * been provided by the `serve()` handler, this will fall back to using the\n   * provided URL present in the request to parse the query string from instead.\n   */\n  queryStringWithDefaults: (\n    reason: string,\n    key: string,\n  ) => Promise<string | undefined>;\n}\n"],"names":["acc","defaultLogLevel: typeof this.logLevel","debug","defaultStreamingOption: typeof this.streaming","actions: HandlerResponseWithErrors","args","method","headers: Record<string, string>","signature: string | undefined","signature","actionRes","probe","probeEnum","result","deployId","version","data","body: InBandRegisterRequest","introspection:\n      | UnauthenticatedIntrospection\n      | AuthenticatedIntrospection","res: globalThis.Response","err: unknown","data: z.input<typeof registerResSchema>","status: number","error: string","skipped: boolean","modified: boolean","logLevels: LogLevel[]","logLevels","#verifySignature"],"mappings":"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","debugId":null}},
    {"offset": {"line": 3377, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/inngest/next.js","sources":["file:///Users/harshitgangwar/Desktop/SkillForge/node_modules/src/next.ts"],"sourcesContent":["/**\n * An adapter for Next.js to serve and register any declared functions with\n * Inngest, making them available to be triggered by events.\n *\n * Supports Next.js 12+, both serverless and edge.\n *\n * @example Next.js <=12 or the pages router can export the handler directly\n * ```ts\n * export default serve({ client: inngest, functions: [fn1, fn2] });\n * ```\n *\n * @example Next.js >=13 with the `app` dir must export individual methods\n * ```ts\n * export const { GET, POST, PUT } = serve({\n *            client: inngest,\n *            functions: [fn1, fn2],\n * });\n * ```\n *\n * @module\n */\n\nimport type { NextApiRequest, NextApiResponse } from \"next\";\nimport type { NextRequest } from \"next/server\";\nimport {\n  InngestCommHandler,\n  type ServeHandlerOptions,\n} from \"./components/InngestCommHandler.ts\";\nimport { getResponse } from \"./helpers/env.ts\";\nimport type { Either } from \"./helpers/types.ts\";\nimport type { SupportedFrameworkName } from \"./types.ts\";\n\n/**\n * The name of the framework, used to identify the framework in Inngest\n * dashboards and during testing.\n */\nexport const frameworkName: SupportedFrameworkName = \"nextjs\";\n\n/**\n * The shape of a request handler, supporting Next.js 12+.\n *\n * We are intentionally abstract with the arguments here, as Next.js's type\n * checking when building varies wildly between major versions; specifying\n * different types (even optional types) here can cause issues with the build.\n *\n * This change was initially made for Next.js 15, which specifies the second\n * argument as `RouteContext`, whereas Next.js 13 and 14 omit it and Next.js 12\n * provides a `NextApiResponse`, which is varies based on the execution\n * environment used (edge vs serverless).\n */\nexport type RequestHandler = (\n  expectedReq: NextRequest,\n  res: unknown,\n) => Promise<Response>;\n\nconst isRecord = (val: unknown): val is Record<string, unknown> => {\n  return typeof val === \"object\" && val !== null;\n};\n\nconst isFunction = (val: unknown): val is (...args: unknown[]) => unknown => {\n  return typeof val === \"function\";\n};\n\nconst isNext12ApiResponse = (val: unknown): val is NextApiResponse => {\n  return (\n    isRecord(val) &&\n    isFunction(val.setHeader) &&\n    isFunction(val.status) &&\n    isFunction(val.send)\n  );\n};\n\n/**\n * In Next.js, serve and register any declared functions with Inngest, making\n * them available to be triggered by events.\n *\n * Supports Next.js 12+, both serverless and edge.\n *\n * @example Next.js <=12 or the pages router can export the handler directly\n * ```ts\n * export default serve({ client: inngest, functions: [fn1, fn2] });\n * ```\n *\n * @example Next.js >=13 with the `app` dir must export individual methods\n * ```ts\n * export const { GET, POST, PUT } = serve({\n *            client: inngest,\n *            functions: [fn1, fn2],\n * });\n * ```\n *\n * @public\n */\n// Has explicit return type to avoid JSR-defined \"slow types\"\nexport const serve = (\n  options: ServeHandlerOptions,\n): RequestHandler & {\n  GET: RequestHandler;\n  POST: RequestHandler;\n  PUT: RequestHandler;\n} => {\n  const handler = new InngestCommHandler({\n    frameworkName,\n    ...options,\n    handler: (\n      reqMethod: \"GET\" | \"POST\" | \"PUT\" | undefined,\n      ...args: Parameters<RequestHandler>\n    ) => {\n      const [expectedReq, res] = args;\n      const req = expectedReq as Either<NextApiRequest, NextRequest>;\n\n      const getHeader = (key: string): string | null | undefined => {\n        const header =\n          typeof req.headers.get === \"function\"\n            ? req.headers.get(key)\n            : req.headers[key];\n\n        return Array.isArray(header) ? header[0] : header;\n      };\n\n      return {\n        body: () => (typeof req.json === \"function\" ? req.json() : req.body),\n        headers: getHeader,\n        method: () => {\n          /**\n           * `req.method`, though types say otherwise, is not available in Next.js\n           * 13 {@link https://beta.nextjs.org/docs/routing/route-handlers Route Handlers}.\n           *\n           * Therefore, we must try to set the method ourselves where we know it.\n           */\n          const method = reqMethod || req.method || \"\";\n          return method;\n        },\n        isProduction: () => {\n          /**\n           * Vercel Edge Functions do not allow dynamic access to environment\n           * variables, so we'll manage production checks directly here.\n           *\n           * We try/catch to avoid situations where Next.js is being used in\n           * environments where `process.env` is not accessible or polyfilled.\n           */\n          try {\n            const isProd = process.env.NODE_ENV === \"production\";\n            return isProd;\n          } catch (_err) {\n            // no-op\n          }\n\n          return;\n        },\n        queryString: (key, url) => {\n          const qs = req.query?.[key] || url.searchParams.get(key);\n          return Array.isArray(qs) ? qs[0] : qs;\n        },\n\n        url: () => {\n          let absoluteUrl: URL | undefined;\n          try {\n            absoluteUrl = new URL(req.url as string);\n          } catch {\n            // no-op\n          }\n\n          if (absoluteUrl) {\n            /**\n             * `req.url` here should may be the full URL, including query string.\n             * There are some caveats, however, where Next.js will obfuscate\n             * the host. For example, in the case of `host.docker.internal`,\n             * Next.js will instead set the host here to `localhost`.\n             *\n             * To avoid this, we'll try to parse the URL from `req.url`, but\n             * also use the `host` header if it's available.\n             */\n            const host = options.serveHost || getHeader(\"host\");\n            if (host) {\n              const hostWithProtocol = new URL(\n                host.includes(\"://\")\n                  ? host\n                  : `${absoluteUrl.protocol}//${host}`,\n              );\n\n              absoluteUrl.protocol = hostWithProtocol.protocol;\n              absoluteUrl.host = hostWithProtocol.host;\n              absoluteUrl.port = hostWithProtocol.port;\n              absoluteUrl.username = hostWithProtocol.username;\n              absoluteUrl.password = hostWithProtocol.password;\n            }\n\n            return absoluteUrl;\n          }\n\n          let scheme: \"http\" | \"https\" = \"https\";\n          const host = options.serveHost || getHeader(\"host\") || \"\";\n\n          try {\n            if (process.env.NODE_ENV === \"development\") {\n              scheme = \"http\";\n            }\n          } catch (_err) {\n            // no-op\n          }\n\n          const url = new URL(req.url as string, `${scheme}://${host}`);\n\n          return url;\n        },\n        transformResponse: ({ body, headers, status }): Response => {\n          /**\n           * Carefully attempt to set headers and data on the response object\n           * for Next.js 12 support.\n           *\n           * This also assumes that we're not using Next.js 15, where the `res`\n           * object is repopulated as a `RouteContext` object. We expect these\n           * methods to NOT be defined in Next.js 15.\n           *\n           * We could likely use `instanceof ServerResponse` to better check the\n           * type of this, though Next.js 12 had issues with this due to not\n           * instantiating the response correctly.\n           */\n          if (isNext12ApiResponse(res)) {\n            for (const [key, value] of Object.entries(headers)) {\n              res.setHeader(key, value);\n            }\n\n            res.status(status);\n            res.send(body);\n\n            /**\n             * If we're here, we're in a serverless endpoint (not edge), so\n             * we've correctly sent the response and can return `undefined`.\n             *\n             * Next.js 13 edge requires that the return value is typed as\n             * `Response`, so we still enforce that as we cannot dynamically\n             * adjust typing based on the environment.\n             */\n            return undefined as unknown as Response;\n          }\n\n          /**\n           * If we're here, we're in an edge environment and need to return a\n           * `Response` object.\n           *\n           * We also don't know if the current environment has a native\n           * `Response` object, so we'll grab that first.\n           */\n          const Res = getResponse();\n          return new Res(body, { status, headers });\n        },\n        transformStreamingResponse: ({ body, headers, status }) => {\n          return new Response(body, { status, headers });\n        },\n      };\n    },\n  });\n\n  /**\n   * Next.js 13 uses\n   * {@link https://beta.nextjs.org/docs/routing/route-handlers Route Handlers}\n   * to declare API routes instead of a generic catch-all method that was\n   * available using the `pages/api` directory.\n   *\n   * This means that users must now export a function for each method supported\n   * by the endpoint. For us, this means requiring a user explicitly exports\n   * `GET`, `POST`, and `PUT` functions.\n   *\n   * Because of this, we'll add circular references to those property names of\n   * the returned handler, meaning we can write some succinct code to export\n   * them. Thanks, @goodoldneon.\n   *\n   * @example\n   * ```ts\n   * export const { GET, POST, PUT } = serve(...);\n   * ```\n   *\n   * See {@link https://beta.nextjs.org/docs/routing/route-handlers}\n   */\n  const baseFn = handler.createHandler();\n\n  const fn = baseFn.bind(null, undefined);\n\n  /**\n   * Ensure we have a non-variadic length to avoid issues with forced type\n   * checking.\n   */\n  Object.defineProperty(fn, \"length\", { value: 1 });\n\n  type Fn = typeof fn;\n\n  const handlerFn = Object.defineProperties(fn, {\n    GET: { value: baseFn.bind(null, \"GET\") },\n    POST: { value: baseFn.bind(null, \"POST\") },\n    PUT: { value: baseFn.bind(null, \"PUT\") },\n  }) as Fn & {\n    GET: Fn;\n    POST: Fn;\n    PUT: Fn;\n  };\n\n  return handlerFn;\n};\n"],"names":["frameworkName: SupportedFrameworkName","absoluteUrl: URL | undefined","host","scheme: \"http\" | \"https\""],"mappings":"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","debugId":null}},
    {"offset": {"line": 3569, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/inngest/components/InngestMiddleware.js","sources":["file:///Users/harshitgangwar/Desktop/SkillForge/node_modules/src/components/InngestMiddleware.ts"],"sourcesContent":["import { cacheFn, waterfall } from \"../helpers/functions.ts\";\nimport type {\n  Await,\n  MaybePromise,\n  ObjectAssign,\n  PartialK,\n  Simplify,\n} from \"../helpers/types.ts\";\nimport type {\n  BaseContext,\n  EventPayload,\n  IncomingOp,\n  OutgoingOp,\n  SendEventBaseOutput,\n  TriggersFromClient,\n} from \"../types.ts\";\nimport type { Inngest } from \"./Inngest.ts\";\nimport type { InngestFunction } from \"./InngestFunction.ts\";\n\n/**\n * A middleware that can be registered with Inngest to hook into various\n * lifecycles of the SDK and affect input and output of Inngest functionality.\n *\n * See {@link https://innge.st/middleware}\n *\n * @example\n *\n * ```ts\n * export const inngest = new Inngest({\n *   middleware: [\n *     new InngestMiddleware({\n *       name: \"My Middleware\",\n *       init: () => {\n *         // ...\n *       }\n *     })\n *   ]\n * });\n * ```\n *\n * @public\n */\nexport class InngestMiddleware<TOpts extends MiddlewareOptions>\n  implements InngestMiddleware.Like\n{\n  get [Symbol.toStringTag](): typeof InngestMiddleware.Tag {\n    return InngestMiddleware.Tag;\n  }\n\n  /**\n   * The name of this middleware. Used primarily for debugging and logging\n   * purposes.\n   */\n  public readonly name: TOpts[\"name\"];\n\n  /**\n   * This function is used to initialize your middleware and register any hooks\n   * you want to use. It will be called once when the SDK is initialized, and\n   * should be used to store any state you want to use in other parts of your\n   * middleware.\n   *\n   * It can be synchronous or asynchronous, in which case the client will wait\n   * for it to resolve before continuing to initialize the next middleware.\n   *\n   * Multiple clients could be used in the same application with differing\n   * middleware, so do not store state in global variables or assume that your\n   * middleware will only be used once.\n   *\n   * Must return an object detailing the hooks you want to register.\n   */\n  public readonly init: TOpts[\"init\"];\n\n  constructor({ name, init }: TOpts) {\n    this.name = name;\n    this.init = init;\n  }\n}\n\nexport namespace InngestMiddleware {\n  export const Tag = \"Inngest.Middleware\" as const;\n\n  export type Any = InngestMiddleware<MiddlewareOptions>;\n  export interface Like {\n    readonly [Symbol.toStringTag]: typeof InngestMiddleware.Tag;\n  }\n  export type Stack = [InngestMiddleware.Like, ...InngestMiddleware.Like[]];\n}\n\ntype FnsWithSameInputAsOutput<\n  // biome-ignore lint/suspicious/noExplicitAny: <explanation>\n  TRecord extends Record<string, (arg: any) => any>,\n> = {\n  [K in keyof TRecord as Await<TRecord[K]> extends Parameters<TRecord[K]>[0]\n    ? K\n    : // biome-ignore lint/suspicious/noConfusingVoidType: <explanation>\n      Await<TRecord[K]> extends undefined | void\n      ? // biome-ignore lint/suspicious/noConfusingVoidType: <explanation>\n        Parameters<TRecord[K]>[0] extends undefined | void\n        ? K\n        : never\n      : never]: TRecord[K];\n};\n\ntype PromisifiedFunctionRecord<\n  // biome-ignore lint/suspicious/noExplicitAny: <explanation>\n  TRecord extends Record<string, (arg: any) => any>,\n> = Pick<\n  Partial<{\n    [K in keyof TRecord]: (\n      ...args: Parameters<TRecord[K]>\n    ) => Promise<Await<TRecord[K]>>;\n  }>,\n  keyof FnsWithSameInputAsOutput<TRecord>\n> &\n  Omit<\n    Partial<{\n      [K in keyof TRecord]: (\n        ...args: Parameters<TRecord[K]>\n      ) => Promise<Parameters<TRecord[K]>[0]>;\n    }>,\n    keyof FnsWithSameInputAsOutput<TRecord>\n  >;\n\nexport type RunHookStack = PromisifiedFunctionRecord<\n  Await<MiddlewareRegisterReturn[\"onFunctionRun\"]>\n>;\n\nexport type SendEventHookStack = PromisifiedFunctionRecord<\n  Await<MiddlewareRegisterReturn[\"onSendEvent\"]>\n>;\n\n/**\n * Given some middleware and an entrypoint, runs the initializer for the given\n * `key` and returns functions that will pass arguments through a stack of each\n * given hook in a middleware's lifecycle.\n *\n * Lets the middleware initialize before starting.\n */\nexport const getHookStack = async <\n  // biome-ignore lint/suspicious/noExplicitAny: <explanation>\n  TMiddleware extends Record<string, (arg: any) => any>,\n  TKey extends keyof TMiddleware,\n  TResult extends Await<TMiddleware[TKey]>,\n  TRet extends\n    PromisifiedFunctionRecord<TResult> = PromisifiedFunctionRecord<TResult>,\n>(\n  /**\n   * The stack of middleware that will be used to run hooks.\n   */\n  middleware: Promise<TMiddleware[]>,\n\n  /**\n   * The hook type to initialize.\n   */\n  key: TKey,\n\n  /**\n   * Arguments for the initial hook.\n   */\n  arg: Parameters<TMiddleware[TKey]>[0],\n\n  transforms: PartialK<\n    {\n      [K in keyof TResult]-?: (\n        prev: Parameters<TResult[K]>[0],\n        output: Await<TResult[K]>,\n      ) => Parameters<TResult[K]>[0];\n    },\n    keyof {\n      [K in keyof TResult as Await<TResult[K]> extends Parameters<TResult[K]>[0]\n        ? K\n        : // biome-ignore lint/suspicious/noConfusingVoidType: <explanation>\n          Await<TResult[K]> extends undefined | void\n          ? K\n          : never]: undefined;\n    }\n  >,\n): Promise<TRet> => {\n  // Get directions of hooks before we start running the middleware.\n  const hookDirs = hookDirections[key as keyof typeof hookDirections];\n  if (!hookDirs) {\n    throw new Error(\n      `No hook directions found for key \"${String(key)}\". This is likely a bug in the Inngest SDK.`,\n    );\n  }\n\n  // Wait for middleware to initialize\n  const mwStack = await middleware;\n\n  // Step through each middleware and get the hook for the given key\n  const keyFns = mwStack.reduce(\n    (acc, mw) => {\n      const fn = mw[key];\n\n      if (fn) {\n        return [...acc, fn];\n      }\n\n      return acc;\n    },\n    [] as NonNullable<TMiddleware[TKey]>[],\n  );\n\n  // Run each hook found in sequence and collect the results\n  const hooksRegistered = await keyFns.reduce<\n    Promise<Await<TMiddleware[TKey]>[]>\n  >(async (acc, fn) => {\n    return [...(await acc), await fn(arg)];\n  }, Promise.resolve([]));\n\n  // Prepare the return object - mutating this instead of using reduce as it\n  // results in cleaner code.\n  const ret = {} as TRet;\n\n  // Step through each hook result and create a waterfall joining each key\n  for (const hook of hooksRegistered) {\n    const hookKeys = Object.keys(hook) as (keyof TRet)[];\n\n    for (const key of hookKeys) {\n      let fns = [hook[key]];\n\n      const existingWaterfall = ret[key];\n      if (existingWaterfall) {\n        if (hookDirs[key as keyof typeof hookDirs] === \"forward\") {\n          fns = [existingWaterfall, hook[key]];\n        } else {\n          // For backward hooks, put the new hook before the existing waterfall\n          // This creates the proper onion pattern: [foo, bar] -> [bar, foo] for after* hooks\n          fns = [hook[key], existingWaterfall];\n        }\n      }\n\n      const transform = transforms[key as keyof typeof transforms] as (\n        arg: Await<(typeof fns)[number]>,\n      ) => Parameters<(typeof fns)[number]>;\n\n      ret[key] = waterfall(fns, transform) as TRet[keyof TRet];\n    }\n  }\n\n  // Cache each function in the stack to ensure each can only be called once\n  for (const k of Object.keys(ret)) {\n    const key = k as keyof typeof ret;\n\n    ret[key] = cacheFn(\n      ret[key] as (...args: unknown[]) => unknown,\n    ) as unknown as TRet[keyof TRet];\n  }\n\n  return ret;\n};\n\n/**\n * Options passed to new {@link InngestMiddleware} instance.\n *\n * @public\n */\nexport interface MiddlewareOptions {\n  /**\n   * The name of this middleware. Used primarily for debugging and logging\n   * purposes.\n   */\n  name: string;\n\n  /**\n   * This function is used to initialize your middleware and register any hooks\n   * you want to use. It will be called once when the SDK is initialized, and\n   * should be used to store any state you want to use in other parts of your\n   * middleware.\n   *\n   * It can be synchronous or asynchronous, in which case the client will wait\n   * for it to resolve before continuing to initialize the next middleware.\n   *\n   * Multiple clients could be used in the same application with differing\n   * middleware, so do not store state in global variables or assume that your\n   * middleware will only be used once.\n   *\n   * Must return an object detailing the hooks you want to register.\n   */\n  init: MiddlewareRegisterFn;\n}\n\n/**\n * @public\n */\nexport type MiddlewareRegisterReturn = {\n  /**\n   * This hook is called for every function execution and allows you to hook\n   * into various stages of a run's lifecycle. Use this to store any state you\n   * want to use for the entirety of a particular run.\n   *\n   * It can be synchronous or asynchronous, in which case the client will wait\n   * for it to resolve before continuing to initialize the next middleware.\n   *\n   * Must return an object detailing the hooks you want to register.\n   */\n  onFunctionRun?: (ctx: InitialRunInfo) => MaybePromise<{\n    /**\n     * The `input` hook is called once the input for the function has been\n     * properly set up. This is where you can modify the input before the\n     * function starts to memoize or execute by returning an object containing\n     * changes to the context.\n     *\n     * For example, to add `foo` to the context, you'd return\n     * `{ ctx: { foo: \"bar\" } }`.\n     *\n     * @param ctx - The context for the incoming request.\n     * @param steps - The step data in state. Does not include internal IDs.\n     */\n    transformInput?: MiddlewareRunInput;\n\n    /**\n     * The `beforeMemoization` hook is called before the function starts to\n     * memoize.\n     */\n    beforeMemoization?: BlankHook;\n\n    /**\n     * The `afterMemoization` hook is called after the function has finished\n     * memoizing.\n     */\n    afterMemoization?: BlankHook;\n\n    /**\n     * The `beforeExecution` hook is called before the function starts to\n     * execute. Execution here means that new code is being seen/run for the\n     * first time.\n     */\n    beforeExecution?: BlankHook;\n\n    /**\n     * The `afterExecution` hook is called after the function has finished\n     * executing.\n     */\n    afterExecution?: BlankHook;\n\n    /**\n     * The `output` hook is called after the function has finished executing\n     * and before the response is sent back to Inngest. This is where you\n     * can modify the output before it's sent back to Inngest by returning\n     * an object containing changes.\n     *\n     * @param err - The raw error that was thrown by the function, if any, so\n     * that you can capture exact error messages and stack traces.\n     *\n     * @param data - The prepared-but-unserialized data that was returned by\n     * the function, if any, so that you can modify the output.\n     */\n    transformOutput?: MiddlewareRunOutput;\n\n    /**\n     * The `finished` hook is called when the function has finished executing\n     * and has returned a final response that will end the run, either a\n     * successful or error response. In the case of an error response, further\n     * retries may be attempted and call this hook again.\n     *\n     * The output provided will be after `transformOutput` has been applied.\n     *\n     * This is not guaranteed to be called on every execution, and may be called\n     * multiple times if many parallel executions reach the end of the function;\n     * for a guaranteed single execution, create a function with an event\n     * trigger of `\"inngest/function.finished\"`.\n     */\n    finished?: MiddlewareRunFinished;\n\n    /**\n     * The `beforeResponse` hook is called after the output has been set and\n     * before the response is sent back to Inngest. This is where you can\n     * perform any final actions before the response is sent back to Inngest and\n     * is the final hook called.\n     */\n    beforeResponse?: BlankHook;\n  }>;\n\n  /**\n   * The `sendEvent` hook is called every time an event is sent to Inngest.\n   */\n  onSendEvent?: () => MaybePromise<{\n    /**\n     * The `input` hook is called before the event is sent to Inngest. This\n     * is where you can modify the event before it's sent to Inngest by\n     * returning an object containing changes.\n     */\n    transformInput?: MiddlewareSendEventInput;\n\n    /**\n     * The `output` hook is called after the event has been sent to Inngest.\n     * This is where you can perform any final actions after the event has\n     * been sent to Inngest and can modify the output the SDK sees.\n     */\n    transformOutput?: MiddlewareSendEventOutput;\n  }>;\n};\n\n/**\n * The direction of each hook that exists in the middleware lifecycle.\n * This is used to determine whether hooks found in a stack run forwards or\n * backwards, creating onion-like behaviour.\n */\nconst hookDirections: {\n  [K in keyof MiddlewareRegisterReturn]: Record<\n    keyof Await<NonNullable<MiddlewareRegisterReturn[K]>>,\n    \"forward\" | \"backward\"\n  >;\n} = {\n  onFunctionRun: {\n    transformInput: \"forward\",\n    beforeMemoization: \"forward\",\n    afterMemoization: \"backward\",\n    beforeExecution: \"forward\",\n    afterExecution: \"backward\",\n    transformOutput: \"backward\",\n    beforeResponse: \"forward\",\n    finished: \"forward\",\n  },\n  onSendEvent: {\n    transformInput: \"forward\",\n    transformOutput: \"backward\",\n  },\n};\n\n/**\n * @public\n */\nexport type MiddlewareRegisterFn = (ctx: {\n  /**\n   * The client this middleware is being registered on.\n   */\n  client: Inngest.Any;\n\n  /**\n   * If defined, this middleware has been applied directly to an Inngest\n   * function rather than on the client.\n   */\n  fn?: InngestFunction.Any;\n}) => MaybePromise<MiddlewareRegisterReturn>;\n\n/**\n * A blank, no-op hook that passes nothing and expects nothing in return.\n *\n * @internal\n */\ntype BlankHook = () => MaybePromise<void>;\n\n/**\n * Arguments sent to some `run` lifecycle hooks of a middleware.\n *\n * @internal\n */\ntype MiddlewareRunArgs = Readonly<{\n  /**\n   * The context object that will be passed to the function. This contains\n   * event data, some contextual data such as the run's ID, and step tooling.\n   */\n  ctx: Record<string, unknown> &\n    Readonly<BaseContext<Inngest.Any, TriggersFromClient<Inngest.Any>>>; // TODO Acceptable?\n\n  /**\n   * The step data that will be passed to the function.\n   */\n  steps: Readonly<IncomingOp>[];\n\n  /**\n   * The function that is being executed.\n   */\n  fn: InngestFunction.Any;\n\n  /**\n   * The raw arguments given to serve handler being used to execute the\n   * function.\n   */\n  reqArgs: Readonly<unknown[]>;\n}>;\n\n/**\n * The specific arguments sent to the `run` hook when an execution has begun.\n * Differs from {@link MiddlewareRunArgs} in that we don't have a complete\n * context yet.\n *\n * @internal\n */\ntype InitialRunInfo = Readonly<\n  Simplify<\n    Omit<MiddlewareRunArgs, \"ctx\"> & {\n      /**\n       * A partial context object that will be passed to the function. Does not\n       * necessarily contain all the data that will be passed to the function.\n       */\n      ctx: Readonly<{\n        event: EventPayload;\n        runId: string;\n      }>;\n    }\n  >\n>;\n\n/**\n * The shape of an `input` hook within a `run`, optionally returning change to\n * the context or steps.\n *\n * @internal\n */\ntype MiddlewareRunInput = (ctx: MiddlewareRunArgs) => MaybePromise<\n  | {\n      ctx?: Record<string, unknown>;\n      steps?: Pick<IncomingOp, \"data\">[];\n      // We need these in the future to allow users to specify their own complex\n      // types for transforming data above using just inference. e.g. every field\n      // ending with \"_at\" is transformed to a Date.\n      //\n      // transformEvent?: (event: EventPayload) => unknown;\n      // transformStep?: (data: unknown) => unknown;\n    }\n  | undefined\n  // biome-ignore lint/suspicious/noConfusingVoidType: <explanation>\n  | void\n>;\n\n/**\n * Arguments for the SendEventInput hook\n *\n * @internal\n */\ntype MiddlewareSendEventInputArgs = Readonly<{\n  payloads: ReadonlyArray<EventPayload>;\n}>;\n\n/**\n * The shape of an `input` hook within a `sendEvent`, optionally returning\n * change to the payloads.\n *\n * @internal\n */\ntype MiddlewareSendEventInput = (\n  ctx: MiddlewareSendEventInputArgs,\n) => MaybePromise<\n  | {\n      payloads?: EventPayload[];\n    }\n  | undefined\n  // biome-ignore lint/suspicious/noConfusingVoidType: <explanation>\n  | void\n>;\n\n/**\n * Arguments for the SendEventOutput hook\n *\n * @internal\n */\ntype MiddlewareSendEventOutputArgs = { result: Readonly<SendEventBaseOutput> };\n\n/**\n * The shape of an `output` hook within a `sendEvent`, optionally returning a\n * change to the result value.\n */\ntype MiddlewareSendEventOutput = (\n  ctx: MiddlewareSendEventOutputArgs,\n  // biome-ignore lint/suspicious/noConfusingVoidType: <explanation>\n) => MaybePromise<{ result?: Record<string, unknown> } | undefined | void>;\n\n/**\n * @internal\n */\ntype MiddlewareRunOutput = (ctx: {\n  result: Readonly<Pick<OutgoingOp, \"error\" | \"data\">>;\n  step?: Readonly<Omit<OutgoingOp, \"id\">>;\n}) => MaybePromise<\n  | {\n      result?: Partial<Pick<OutgoingOp, \"data\" | \"error\">>;\n    }\n  | undefined\n  // biome-ignore lint/suspicious/noConfusingVoidType: <explanation>\n  | void\n>;\n\ntype MiddlewareRunFinished = (ctx: {\n  result: Readonly<Pick<OutgoingOp, \"error\" | \"data\">>;\n}) => MaybePromise<void>;\n\n/**\n * @internal\n */\ntype GetMiddlewareRunInputMutation<TMiddleware extends InngestMiddleware.Like> =\n  TMiddleware extends InngestMiddleware<infer TOpts>\n    ? TOpts[\"init\"] extends MiddlewareRegisterFn\n      ? Await<\n          Await<Await<TOpts[\"init\"]>[\"onFunctionRun\"]>[\"transformInput\"]\n        > extends {\n          ctx: infer TCtx;\n        }\n        ? {\n            [K in keyof TCtx]: TCtx[K];\n          }\n        : {}\n      : {}\n    : {};\n\n/**\n * @internal\n */\ntype GetMiddlewareSendEventOutputMutation<\n  TMiddleware extends InngestMiddleware.Like,\n> = TMiddleware extends InngestMiddleware<infer TOpts>\n  ? TOpts[\"init\"] extends MiddlewareRegisterFn\n    ? Await<\n        Await<Await<TOpts[\"init\"]>[\"onSendEvent\"]>[\"transformOutput\"]\n      > extends {\n        result: infer TResult;\n      }\n      ? {\n          [K in keyof TResult]: TResult[K];\n        }\n      : {}\n    : {}\n  : {};\n\n/**\n * @internal\n */\nexport type MiddlewareStackSendEventOutputMutation<\n  TContext,\n  TMiddleware extends InngestMiddleware.Stack,\n> = ObjectAssign<\n  {\n    [K in keyof TMiddleware]: GetMiddlewareSendEventOutputMutation<\n      TMiddleware[K]\n    >;\n  },\n  TContext\n>;\n\nexport type ExtendWithMiddleware<\n  TMiddlewareStacks extends InngestMiddleware.Stack[],\n  TContext = {},\n> = ObjectAssign<\n  {\n    [K in keyof TMiddlewareStacks]: MiddlewareStackRunInputMutation<\n      {},\n      TMiddlewareStacks[K]\n    >;\n  },\n  TContext\n>;\n\nexport type ExtendSendEventWithMiddleware<\n  TMiddlewareStacks extends InngestMiddleware.Stack[],\n  TContext = {},\n> = ObjectAssign<\n  {\n    [K in keyof TMiddlewareStacks]: MiddlewareStackSendEventOutputMutation<\n      {},\n      TMiddlewareStacks[K]\n    >;\n  },\n  TContext\n>;\n\n/**\n * @internal\n */\nexport type MiddlewareStackRunInputMutation<\n  TContext,\n  TMiddleware extends InngestMiddleware.Stack,\n> = ObjectAssign<\n  {\n    [K in keyof TMiddleware]: GetMiddlewareRunInputMutation<TMiddleware[K]>;\n  },\n  TContext\n>;\n"],"names":["key","hookDirections: {\n  [K in keyof MiddlewareRegisterReturn]: Record<\n    keyof Await<NonNullable<MiddlewareRegisterReturn[K]>>,\n    \"forward\" | \"backward\"\n  >;\n}"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GA0CA,IAAa,oBAAb,MAAa,kBAEb;IACE,IAAA,CAAK,OAAO,WAAA,CAAA,GAA6C;QACvD,OAAO,kBAAkB,GAAA;;;;;IAOX,KAAA;;;;;;;;;;;;;;;IAiBA,KAAA;IAEhB,YAAY,EAAE,IAAA,EAAM,IAAA,EAAA,CAAe;QACjC,IAAA,CAAK,IAAA,GAAO;QACZ,IAAA,CAAK,IAAA,GAAO;;;;6BAKK;;;;;;;;GA2DrB,MAAa,eAAe,OAW1B,YAKA,KAKA,KAEA,eAgBkB;IAElB,MAAM,WAAW,cAAA,CAAe,IAAA;IAChC,IAAI,CAAC,SACH,CAAA,MAAM,IAAI,MACR,CAAA,kCAAA,EAAqC,OAAO,IAAI,CAAC,2CAAA,CAAA,CAClD;IAqBH,MAAM,kBAAkB,MAAA,CAjBR,MAAM,UAAA,EAGC,MAAA,CAAA,CACpB,KAAK,OAAO;QACX,MAAM,KAAK,EAAA,CAAG,IAAA;QAEd,IAAI,GACF,CAAA,OAAO,CAAC;eAAG;YAAK;SAAG;QAGrB,OAAO;OAET,EAAE,CACH,CAGoC,MAAA,CAEnC,OAAO,KAAK,OAAO;QACnB,OAAO,CAAC;eAAI,MAAM;YAAM,MAAM,GAAG,IAAI;SAAC;OACrC,QAAQ,OAAA,CAAQ,EAAE,CAAC,CAAC;IAIvB,MAAM,MAAM,CAAA,CAAE;IAGd,KAAK,MAAM,QAAQ,gBAAiB;QAClC,MAAM,WAAW,OAAO,IAAA,CAAK,KAAK;QAElC,KAAK,MAAMA,SAAO,SAAU;YAC1B,IAAI,MAAM;gBAAC,IAAA,CAAKA,MAAAA;aAAK;YAErB,MAAM,oBAAoB,GAAA,CAAIA,MAAAA;YAC9B,IAAI,kBACF,CAAA,IAAI,QAAA,CAASA,MAAAA,KAAkC,UAC7C,CAAA,MAAM;gBAAC;gBAAmB,IAAA,CAAKA,MAAAA;aAAK;iBAIpC,MAAM;gBAAC,IAAA,CAAKA,MAAAA;gBAAM;aAAkB;YAIxC,MAAM,YAAY,UAAA,CAAWA,MAAAA;YAI7B,GAAA,CAAIA,MAAAA,OAAO,8JAAA,EAAU,KAAK,UAAU;;;IAKxC,KAAK,MAAM,KAAK,OAAO,IAAA,CAAK,IAAI,CAAE;QAChC,MAAMA,QAAM;QAEZ,GAAA,CAAIA,MAAAA,OAAO,4JAAA,EACT,GAAA,CAAIA,MAAAA,CACL;;IAGH,OAAO;;;;;;GAsJT,MAAMC,iBAKF;IACF,eAAe;QACb,gBAAgB;QAChB,mBAAmB;QACnB,kBAAkB;QAClB,iBAAiB;QACjB,gBAAgB;QAChB,iBAAiB;QACjB,gBAAgB;QAChB,UAAU;KACX;IACD,aAAa;QACX,gBAAgB;QAChB,iBAAiB;KAClB;CACF","debugId":null}},
    {"offset": {"line": 3705, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/inngest/components/RetryAfterError.js","sources":["file:///Users/harshitgangwar/Desktop/SkillForge/node_modules/src/components/RetryAfterError.ts"],"sourcesContent":["import ms from \"ms\";\n\n/**\n * An error that, when thrown, indicates to Inngest that the function should be\n * retried after a given amount of time.\n *\n * A `message` must be provided, as well as a `retryAfter` parameter, which can\n * be a `number` of milliseconds, an `ms`-compatible time string, or a `Date`.\n *\n * An optional `cause` can be provided to provide more context to the error.\n *\n * @public\n */\nexport class RetryAfterError extends Error {\n  /**\n   * The underlying cause of the error, if any.\n   *\n   * This will be serialized and sent to Inngest.\n   */\n  public override readonly cause?: unknown;\n\n  /**\n   * The time after which the function should be retried. Represents either a\n   * number of milliseconds or a RFC3339 date.\n   */\n  public readonly retryAfter: string;\n\n  constructor(\n    message: string,\n\n    /**\n     * The time after which the function should be retried. Represents either a\n     * number of milliseconds or a RFC3339 date.\n     */\n    retryAfter: number | string | Date,\n\n    options?: {\n      /**\n       * The underlying cause of the error, if any.\n       *\n       * This will be serialized and sent to Inngest.\n       */\n      cause?: unknown;\n    },\n  ) {\n    super(message);\n\n    if (retryAfter instanceof Date) {\n      this.retryAfter = retryAfter.toISOString();\n    } else {\n      const seconds = `${Math.ceil(\n        (typeof retryAfter === \"string\"\n          ? ms(retryAfter as `${number}`)\n          : retryAfter) / 1000,\n      )}`;\n\n      if (!isFinite(Number(seconds))) {\n        throw new Error(\n          \"retryAfter must be a number of milliseconds, a ms-compatible string, or a Date\",\n        );\n      }\n\n      this.retryAfter = seconds;\n    }\n\n    this.cause = options?.cause;\n  }\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;GAaA,IAAa,kBAAb,cAAqC,MAAM;;;;;IAMhB,MAAA;;;;IAMT,WAAA;IAEhB,YACE,OAAA,EAMA,UAAA,EAEA,OAAA,CAQA;QACA,KAAA,CAAM,QAAQ;QAEd,IAAI,sBAAsB,KACxB,CAAA,IAAA,CAAK,UAAA,GAAa,WAAW,WAAA,EAAa;aACrC;YACL,MAAM,UAAU,GAAG,KAAK,IAAA,CAAA,CACrB,OAAO,eAAe,eACnB,wIAAA,EAAG,WAA0B,GAC7B,UAAA,IAAc,IACnB,EAAA;YAED,IAAI,CAAC,SAAS,OAAO,QAAQ,CAAC,CAC5B,CAAA,MAAM,IAAI,MACR,iFACD;YAGH,IAAA,CAAK,UAAA,GAAa;;QAGpB,IAAA,CAAK,KAAA,GAAQ,SAAS","debugId":null}},
    {"offset": {"line": 3749, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/inngest/helpers/temporal.js","sources":["file:///Users/harshitgangwar/Desktop/SkillForge/node_modules/src/helpers/temporal.ts"],"sourcesContent":["import type { Temporal } from \"temporal-polyfill\";\n\n/**\n * A type that represents a `Temporal.Instant` object.\n *\n * `*Like` types are available for many temporal objects, but not all of them.\n * Also, the `*Like` types can sometimes be linked to particular\n * implementations, and are not stable between them.\n *\n * Therefore, we try to detect only the hopefully-stable branding.\n */\nexport type InstantLike = {\n  readonly [Symbol.toStringTag]: \"Temporal.Instant\";\n};\n\n/**\n * A type that represents a `Temporal.Duration` object.\n *\n * `*Like` types are available for many temporal objects, but not all of them.\n * Also, the `*Like` types can sometimes be linked to particular\n * implementations, and are not stable between them.\n *\n * Therefore, we try to detect only the hopefully-stable branding.\n */\nexport type DurationLike = {\n  readonly [Symbol.toStringTag]: \"Temporal.Duration\";\n};\n\n/**\n * A type that represents a `Temporal.ZonedDateTime` object.\n *\n * `*Like` types are available for many temporal objects, but not all of them.\n * Also, the `*Like` types can sometimes be linked to particular\n * implementations, and are not stable between them.\n *\n * Therefore, we try to detect only the hopefully-stable branding.\n */\nexport type ZonedDateTimeLike = {\n  readonly [Symbol.toStringTag]: \"Temporal.ZonedDateTime\";\n};\n\n/**\n * Asserts that the given `input` is a `Temporal.Duration` object.\n */\nexport const isTemporalDuration = (\n  /**\n   * The input to check.\n   */\n  input: unknown,\n): input is Temporal.Duration => {\n  try {\n    // biome-ignore lint/suspicious/noExplicitAny: Safe access as we're catching\n    return (input as any)[Symbol.toStringTag] === \"Temporal.Duration\";\n  } catch {\n    return false;\n  }\n};\n\n/**\n * Asserts that the given `input` is a `Temporal.TimeZone` object.\n */\nexport const isTemporalInstant = (\n  /**\n   * The input to check.\n   */\n  input: unknown,\n): input is Temporal.Instant => {\n  try {\n    // biome-ignore lint/suspicious/noExplicitAny: Safe access as we're catching\n    return (input as any)[Symbol.toStringTag] === \"Temporal.Instant\";\n  } catch {\n    return false;\n  }\n};\n\n/**\n * Asserts that the given `input` is a `Temporal.ZonedDateTime` object.\n */\nexport const isTemporalZonedDateTime = (\n  /**\n   * The input to check.\n   */\n  input: unknown,\n): input is Temporal.ZonedDateTime => {\n  try {\n    // biome-ignore lint/suspicious/noExplicitAny: Safe access as we're catching\n    return (input as any)[Symbol.toStringTag] === \"Temporal.ZonedDateTime\";\n  } catch {\n    return false;\n  }\n};\n\n/**\n * Converts a given `Date`, `string`, `Temporal.Instant`, or\n * `Temporal.ZonedDateTime` to an ISO 8601 string.\n */\nexport const getISOString = (\n  time: Date | string | InstantLike | ZonedDateTimeLike,\n): string => {\n  if (typeof time === \"string\") {\n    return new Date(time).toISOString();\n  }\n\n  if (time instanceof Date) {\n    return time.toISOString();\n  }\n\n  if (isTemporalZonedDateTime(time)) {\n    return time.toInstant().toString();\n  }\n\n  if (isTemporalInstant(time)) {\n    return time.toString();\n  }\n\n  throw new TypeError(\"Invalid date input\");\n};\n"],"names":[],"mappings":";;;;;;;;;AA4CA,MAAa,qBAAA,CAIX,UAC+B;IAC/B,IAAI;QAEF,OAAQ,KAAA,CAAc,OAAO,WAAA,CAAA,KAAiB;aACxC;QACN,OAAO;;;;;GAOX,MAAa,oBAAA,CAIX,UAC8B;IAC9B,IAAI;QAEF,OAAQ,KAAA,CAAc,OAAO,WAAA,CAAA,KAAiB;aACxC;QACN,OAAO;;;;;GAOX,MAAa,0BAAA,CAIX,UACoC;IACpC,IAAI;QAEF,OAAQ,KAAA,CAAc,OAAO,WAAA,CAAA,KAAiB;aACxC;QACN,OAAO;;;;;;GAQX,MAAa,eAAA,CACX,SACW;IACX,IAAI,OAAO,SAAS,SAClB,CAAA,OAAO,IAAI,KAAK,KAAK,CAAC,WAAA,EAAa;IAGrC,IAAI,gBAAgB,KAClB,CAAA,OAAO,KAAK,WAAA,EAAa;IAG3B,IAAI,wBAAwB,KAAK,CAC/B,CAAA,OAAO,KAAK,SAAA,EAAW,CAAC,QAAA,EAAU;IAGpC,IAAI,kBAAkB,KAAK,CACzB,CAAA,OAAO,KAAK,QAAA,EAAU;IAGxB,MAAM,IAAI,UAAU,qBAAqB","debugId":null}},
    {"offset": {"line": 3799, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/inngest/components/InngestFunctionReference.js","sources":["file:///Users/harshitgangwar/Desktop/SkillForge/node_modules/src/components/InngestFunctionReference.ts"],"sourcesContent":["import type { IsAny, Simplify } from \"../helpers/types.ts\";\nimport type {\n  ResolveSchema,\n  ValidSchemaInput,\n  ValidSchemaOutput,\n} from \"../helpers/validators/index.ts\";\nimport type {\n  MinimalEventPayload,\n  PayloadForAnyInngestFunction,\n} from \"../types.ts\";\nimport type { GetFunctionOutput } from \"./Inngest.ts\";\nimport type { InngestFunction } from \"./InngestFunction.ts\";\n\n/**\n * A reference to an `InngestFunction` that can be used to represent both local\n * and remote functions without pulling in the full function definition (i.e.\n * dependencies).\n *\n * These references can be invoked in the same manner as a regular\n * `InngestFunction`.\n *\n * To create a reference function, use the {@link referenceFunction} helper.\n *\n * @public\n */\nexport class InngestFunctionReference<\n  /**\n   * The payload expected by the referenced function.\n   *\n   * Must be in the shape of an event payload.\n   */\n  _TInput extends MinimalEventPayload,\n  /**\n   * The output of the referenced function.\n   */\n  _TOutput,\n> {\n  constructor(public readonly opts: { functionId: string; appId?: string }) {}\n}\n\n/**\n * Create a reference to an `InngestFunction` that can be used to represent both\n * local and remote functions without pulling in the full function definition\n * (i.e. dependencies).\n *\n * These references can be invoked in the same manner as a regular\n * `InngestFunction`.\n *\n * @public\n */\nexport const referenceFunction = <\n  TArgs extends InngestFunctionReference.HelperGenericArgs<TFnInput, TFnOutput>,\n  TFnInput extends ValidSchemaInput = ValidSchemaInput,\n  TFnOutput extends ValidSchemaOutput = ValidSchemaOutput,\n>({\n  functionId,\n  appId,\n}: TArgs extends InngestFunction.Any\n  ? // biome-ignore lint/suspicious/noExplicitAny: <explanation>\n    Omit<InngestFunctionReference.HelperArgs<any, any>, \"schemas\">\n  : TArgs): InngestFunctionReference.HelperReturn<TArgs> => {\n  return new InngestFunctionReference({\n    functionId,\n    appId,\n  }) as InngestFunctionReference.HelperReturn<TArgs>;\n};\n\n/**\n * A reference to an `InngestFunction` that can be used to represent both local\n * and remote functions without pulling in the full function definition (i.e.\n * dependencies).\n *\n * These references can be invoked in the same manner as a regular\n * `InngestFunction`.\n *\n * To create a reference function, use the {@link referenceFunction} helper.\n *\n * @public\n */\nexport namespace InngestFunctionReference {\n  /**\n   * Represents any `InngestFunctionReference`.\n   *\n   * @public\n   */\n  export type Any = InngestFunctionReference<\n    MinimalEventPayload,\n    // biome-ignore lint/suspicious/noExplicitAny: <explanation>\n    any\n  >;\n\n  /**\n   * Arguments used by {@link referenceFunction} to create a reference to an\n   * `InngestFunction`.\n   *\n   * @public\n   */\n  export type HelperArgs<TFnInput, TFnOutput> = {\n    /**\n     * The ID of the function to reference. This can be either a local function\n     * ID or the ID of a function that exists in another app.\n     *\n     * If the latter, `appId` must also be provided. If `appId` is not provided,\n     * the function ID will be assumed to be a local function ID (the app ID of\n     * the calling app will be used).\n     */\n    functionId: string;\n\n    /**\n     * The ID of the app that the function belongs to. This is only required if\n     * the function being referenced exists in another app.\n     */\n    appId?: string;\n\n    /**\n     * The schemas of the referenced function, providing typing to the input\n     * `data` and `return` of invoking the referenced function.\n     *\n     * If not provided and a local function type is not being passed as a\n     * generic into {@link referenceFunction}, the schemas will be inferred as\n     * `unknown`.\n     */\n    schemas?: {\n      data?: TFnInput;\n      return?: TFnOutput;\n    };\n  };\n\n  /**\n   * A helper type that allows the passing of either `HelperArgs` or\n   * `InngestFunction.Any` to the {@link referenceFunction} generic in place of\n   * inferring options.\n   *\n   * This is used along with defaults to allow a generic to be passed by the\n   * user and still infer the correct types for other arguments being passed in.\n   *\n   * @public\n   */\n  export type HelperGenericArgs<TFnInput, TFnOutput> =\n    | HelperArgs<TFnInput, TFnOutput>\n    | InngestFunction.Any;\n\n  /**\n   * Given a set of `InngestFunctionReference.ConstructorArgs`, return an\n   * `InngestFunctionReference`. Also handles the manual passing of\n   * `InngestFunction.Any` to the {@link referenceFunction} generic in place\n   * of inferring options.\n   *\n   * @public\n   */\n  export type HelperReturn<TArgs> = TArgs extends InngestFunction.Any\n    ? InngestFunctionReference<\n        PayloadForAnyInngestFunction<TArgs>,\n        GetFunctionOutput<TArgs>\n      >\n    : TArgs extends HelperArgs<infer TFnInput, infer TFnOutput>\n      ? InngestFunctionReference<\n          // biome-ignore lint/suspicious/noExplicitAny: <explanation>\n          IsAny<ResolveSchema<TFnInput, TFnInput, any>> extends true\n            ? MinimalEventPayload\n            : Simplify<\n                // biome-ignore lint/suspicious/noExplicitAny: <explanation>\n                MinimalEventPayload<ResolveSchema<TFnInput, TFnInput, any>> &\n                  Required<\n                    Pick<\n                      MinimalEventPayload<\n                        // biome-ignore lint/suspicious/noExplicitAny: <explanation>\n                        ResolveSchema<TFnInput, TFnInput, any>\n                      >,\n                      \"data\"\n                    >\n                  >\n              >,\n          ResolveSchema<TFnOutput, TFnOutput, unknown>\n        >\n      : never;\n}\n"],"names":["opts: { functionId: string; appId?: string }"],"mappings":";;;;;;;;;;;;;;;;;;AAyBA,IAAa,2BAAb,MAWE;IACA,YAA4BA,IAAAA,CAA8C;QAA9C,IAAA,CAAA,IAAA,GAAA;;;;;;;;;;;;GAa9B,MAAa,oBAAA,CAIX,EACA,UAAA,EACA,KAAA,EAAA,KAI0D;IAC1D,OAAO,IAAI,yBAAyB;QAClC;QACA;KACD,CAAC","debugId":null}},
    {"offset": {"line": 3843, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/inngest/components/execution/als.js","sources":["file:///Users/harshitgangwar/Desktop/SkillForge/node_modules/src/components/execution/als.ts"],"sourcesContent":["import type { Context, StepOptions } from \"../../types.ts\";\nimport type { Inngest } from \"../Inngest.ts\";\n\nexport interface AsyncContext {\n  /**\n   * The Inngest App that is currently being used to execute the function.\n   */\n  app: Inngest.Like;\n\n  /**\n   * The `ctx` object that has been passed in to this function execution,\n   * including values such as `step` and `event`.\n   */\n  ctx: Context.Any;\n\n  /**\n   * If present, this indicates we are currently executing a `step.run()` step's\n   * callback. Useful to understand whether we are in the context of a step\n   * execution or within the main function body.\n   */\n  executingStep?: StepOptions;\n}\n\n/**\n * A local-only symbol used as a key in global state to store the async local\n * storage instance.\n */\nconst alsSymbol = Symbol.for(\"inngest:als\");\n\n/**\n * A type that represents a partial, runtime-agnostic interface of\n * `AsyncLocalStorage`.\n */\ntype AsyncLocalStorageIsh = {\n  getStore: () => AsyncContext | undefined;\n  run: <R>(store: AsyncContext, fn: () => R) => R;\n};\n\n/**\n * Retrieve the async context for the current execution.\n */\nexport const getAsyncCtx = async (): Promise<AsyncContext | undefined> => {\n  return getAsyncLocalStorage().then((als) => als.getStore());\n};\n\n/**\n * Get a singleton instance of `AsyncLocalStorage` used to store and retrieve\n * async context for the current execution.\n */\nexport const getAsyncLocalStorage = async (): Promise<AsyncLocalStorageIsh> => {\n  (globalThis as Record<string | symbol | number, unknown>)[alsSymbol] ??=\n    new Promise<AsyncLocalStorageIsh>(async (resolve) => {\n      try {\n        const { AsyncLocalStorage } = await import(\"node:async_hooks\");\n\n        resolve(new AsyncLocalStorage<AsyncContext>());\n      } catch (_err) {\n        console.warn(\n          \"node:async_hooks is not supported in this runtime. Experimental async context is disabled.\",\n        );\n\n        resolve({\n          getStore: () => undefined,\n          run: (_, fn) => fn(),\n        });\n      }\n    });\n\n  return (globalThis as Record<string | symbol | number, unknown>)[\n    alsSymbol\n  ] as Promise<AsyncLocalStorageIsh>;\n};\n"],"names":[],"mappings":";;;;;;;;;;AA2BA,MAAM,YAAY,OAAO,GAAA,CAAI,cAAc;;;GAc3C,MAAa,cAAc,YAA+C;IACxE,OAAO,sBAAsB,CAAC,IAAA,CAAA,CAAM,MAAQ,IAAI,QAAA,EAAU,CAAC;;;;;GAO7D,MAAa,uBAAuB,YAA2C;IAC5E,UAAA,CAAyD,UAAA,KACxD,IAAI,QAA8B,OAAO,YAAY;QACnD,IAAI;YACF,MAAM,EAAE,iBAAA,EAAA,GAAsB,MAAM,OAAO;YAE3C,QAAQ,IAAI,mBAAiC,CAAC;iBACvC,MAAM;YACb,QAAQ,IAAA,CACN,6FACD;YAED,QAAQ;gBACN,UAAA,IAAgB,KAAA;gBAChB,KAAA,CAAM,GAAG,KAAO,IAAI;aACrB,CAAC;;MAEJ;IAEJ,OAAQ,UAAA,CACN,UAAA","debugId":null}},
    {"offset": {"line": 3883, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/inngest/components/Fetch.js","sources":["file:///Users/harshitgangwar/Desktop/SkillForge/node_modules/src/components/Fetch.ts"],"sourcesContent":["import Debug from \"debug\";\nimport type { Simplify } from \"../helpers/types.ts\";\nimport { getAsyncCtx } from \"./execution/als.ts\";\nimport { gatewaySymbol, type InternalStepTools } from \"./InngestStepTools.ts\";\n\nconst globalFetch = globalThis.fetch;\ntype Fetch = typeof globalFetch;\n\nexport type StepFetch = Fetch &\n  Simplify<\n    {\n      config: (options: StepFetch.Options) => StepFetch;\n    } & Readonly<StepFetch.Options>\n  >;\n\nexport namespace StepFetch {\n  export interface Options {\n    fallback?: Fetch | undefined;\n  }\n\n  export interface Extras extends Options {\n    config: (options: Options) => StepFetch;\n  }\n}\n\nconst debug = Debug(\"inngest:fetch\");\n\nconst createFetchShim = (): StepFetch => {\n  // biome-ignore lint/style/useConst: need this to allow fns to be defined\n  let stepFetch: StepFetch;\n\n  const fetch: Fetch = async (input, init) => {\n    const ctx = await getAsyncCtx();\n    if (!ctx) {\n      // Not in a function run\n      if (!stepFetch.fallback) {\n        // TODO Tell the user how to solve\n        throw new Error(\n          \"step.fetch() called outside of a function and had no fallback set\",\n        );\n      }\n\n      debug(\n        \"step.fetch() called outside of a function; falling back to global fetch\",\n      );\n\n      return stepFetch.fallback(input, init);\n    }\n\n    // In a function run\n    if (ctx.executingStep) {\n      // Inside a step\n      if (!stepFetch.fallback) {\n        // TODO Tell the user how to solve\n        throw new Error(\n          `step.fetch() called inside step \"${ctx.executingStep.id}\" and had no fallback set`,\n        );\n      }\n\n      debug(\n        `step.fetch() called inside step \"${ctx.executingStep.id}\"; falling back to global fetch`,\n      );\n\n      return stepFetch.fallback(input, init);\n    }\n\n    const targetUrl = new URL(\n      input instanceof Request ? input.url : input.toString(),\n    );\n\n    debug(\"step.fetch() shimming request to\", targetUrl.hostname);\n\n    // Purposefully do not try/cacth this; if it throws then we treat that as a\n    // regular `fetch()` throw, which also would not return a `Response`.\n    const jsonRes = await (ctx.ctx.step as InternalStepTools)[gatewaySymbol](\n      `step.fetch: ${targetUrl.hostname}`,\n      input,\n      init,\n    );\n\n    return new Response(jsonRes.body, {\n      headers: jsonRes.headers,\n      status: jsonRes.status,\n    });\n  };\n\n  const optionsRef: StepFetch.Options = {\n    fallback: globalFetch,\n  };\n\n  const extras: StepFetch.Extras = {\n    config: (options) => {\n      Object.assign(optionsRef, options);\n      Object.assign(stepFetch, optionsRef);\n\n      return stepFetch;\n    },\n    ...optionsRef,\n  };\n\n  stepFetch = Object.assign(fetch, extras);\n\n  return stepFetch;\n};\n\n/**\n * `fetch` is a Fetch API-compatible function that can be used to make any HTTP\n * code durable if it's called within an Inngest function.\n *\n * It will gracefully fall back to the global `fetch` if called outside of this\n * context, and a custom fallback can be set using the `config` method.\n *\n * @example Basic usage\n * ```ts\n * import { fetch } from \"inngest\";\n *\n * const api = new MyProductApi({ fetch });\n * ```\n *\n * @example Setting a custom fallback\n * ```ts\n * import { fetch } from \"inngest\";\n *\n * const api = new MyProductApi({\n *            fetch: fetch.config({ fallback: myCustomFetch }),\n * });\n * ```\n *\n * @example Do not allow fallback\n * ```ts\n * import { fetch } from \"inngest\";\n *\n * const api = new MyProductApi({\n *            fetch: fetch.config({ fallback: undefined }),\n * });\n * ```\n */\nexport const fetch = createFetchShim();\n"],"names":["stepFetch: StepFetch","fetch: Fetch","optionsRef: StepFetch.Options","extras: StepFetch.Extras","fetch"],"mappings":";;;;;;;;;;;AAKA,MAAM,cAAc,WAAW,KAAA;AAoB/B,MAAM,YAAQ,kJAAA,EAAM,gBAAgB;AAEpC,MAAM,kBAAA,MAAmC;IAEvC,IAAIA;IAEJ,MAAMC,UAAe,OAAO,OAAO,SAAS;QAC1C,MAAM,MAAM,UAAM,0KAAA,EAAa;QAC/B,IAAI,CAAC,KAAK;YAER,IAAI,CAAC,UAAU,QAAA,CAEb,CAAA,MAAM,IAAI,MACR,oEACD;YAGH,MACE,0EACD;YAED,OAAO,UAAU,QAAA,CAAS,OAAO,KAAK;;QAIxC,IAAI,IAAI,aAAA,EAAe;YAErB,IAAI,CAAC,UAAU,QAAA,CAEb,CAAA,MAAM,IAAI,MACR,CAAA,iCAAA,EAAoC,IAAI,aAAA,CAAc,EAAA,CAAG,yBAAA,CAAA,CAC1D;YAGH,MACE,CAAA,iCAAA,EAAoC,IAAI,aAAA,CAAc,EAAA,CAAG,+BAAA,CAAA,CAC1D;YAED,OAAO,UAAU,QAAA,CAAS,OAAO,KAAK;;QAGxC,MAAM,YAAY,IAAI,IACpB,iBAAiB,UAAU,MAAM,GAAA,GAAM,MAAM,QAAA,EAAU,CACxD;QAED,MAAM,oCAAoC,UAAU,QAAA,CAAS;QAI7D,MAAM,UAAU,MAAO,IAAI,GAAA,CAAI,IAAA,CAA2B,4KAAA,CAAA,CACxD,CAAA,YAAA,EAAe,UAAU,QAAA,EAAA,EACzB,OACA,KACD;QAED,OAAO,IAAI,SAAS,QAAQ,IAAA,EAAM;YAChC,SAAS,QAAQ,OAAA;YACjB,QAAQ,QAAQ,MAAA;SACjB,CAAC;;IAGJ,MAAMC,aAAgC;QACpC,UAAU;IAAA,CACX;IAED,MAAMC,SAA2B;QAC/B,QAAA,CAAS,YAAY;YACnB,OAAO,MAAA,CAAO,YAAY,QAAQ;YAClC,OAAO,MAAA,CAAO,WAAW,WAAW;YAEpC,OAAO;;QAET,GAAG,UAAA;KACJ;IAED,YAAY,OAAO,MAAA,CAAOC,SAAO,OAAO;IAExC,OAAO;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAmCT,MAAa,QAAQ,iBAAiB","debugId":null}},
    {"offset": {"line": 3970, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/inngest/components/InngestStepTools.js","sources":["file:///Users/harshitgangwar/Desktop/SkillForge/node_modules/src/components/InngestStepTools.ts"],"sourcesContent":["import { type AiAdapter, models } from \"@inngest/ai\";\nimport { z } from \"zod/v3\";\nimport { logPrefix } from \"../helpers/consts.ts\";\nimport type { Jsonify } from \"../helpers/jsonify.ts\";\nimport { timeStr } from \"../helpers/strings.ts\";\nimport * as Temporal from \"../helpers/temporal.ts\";\nimport type {\n  ExclusiveKeys,\n  ParametersExceptFirst,\n  SendEventPayload,\n  SimplifyDeep,\n  WithoutInternalStr,\n} from \"../helpers/types.ts\";\nimport {\n  type EventPayload,\n  type HashedOp,\n  type InvocationResult,\n  type InvokeTargetFunctionDefinition,\n  type MinimalEventPayload,\n  type SendEventOutput,\n  StepOpCode,\n  type StepOptions,\n  type StepOptionsOrId,\n  type TriggerEventFromFunction,\n  type TriggersFromClient,\n} from \"../types.ts\";\nimport type { InngestExecution } from \"./execution/InngestExecution.ts\";\nimport { fetch as stepFetch } from \"./Fetch.ts\";\nimport type {\n  ClientOptionsFromInngest,\n  GetEvents,\n  GetFunctionOutput,\n  GetStepTools,\n  Inngest,\n} from \"./Inngest.ts\";\nimport { InngestFunction } from \"./InngestFunction.ts\";\nimport { InngestFunctionReference } from \"./InngestFunctionReference.ts\";\n\nexport interface FoundStep extends HashedOp {\n  hashedId: string;\n  fn?: (...args: unknown[]) => unknown;\n  rawArgs: unknown[];\n\n  /**\n   * A boolean representing whether the step has been fulfilled, either\n   * resolving or rejecting the `Promise` returned to userland code.\n   *\n   * Note that this is distinct from {@link hasStepState}, which instead tracks\n   * whether the step has been given some state from the Executor. State from\n   * the Executor could be data other than a resolution or rejection, such as\n   * inputs.\n   */\n  fulfilled: boolean;\n\n  /**\n   * A boolean representing whether the step has been given some state from the\n   * Executor. State from the Executor could be data other than a resolution or\n   * rejection, such as inputs.\n   *\n   * This is distinct from {@link fulfilled}, which instead tracks whether the\n   * step has been fulfilled, either resolving or rejecting the `Promise`\n   * returned to userland code.\n   */\n  hasStepState: boolean;\n\n  handled: boolean;\n\n  /**\n   * The promise that has been returned to userland code for this step.\n   */\n  promise: Promise<unknown>;\n\n  /**\n   * Returns a boolean representing whether or not the step was handled on this\n   * invocation.\n   */\n  handle: () => boolean;\n\n  // TODO This is used to track the input we want for this step. Might be\n  // present in ctx from Executor.\n  input?: unknown;\n}\n\nexport type MatchOpFn<\n  T extends (...args: unknown[]) => Promise<unknown> = (\n    ...args: unknown[]\n  ) => Promise<unknown>,\n> = (\n  stepOptions: StepOptions,\n  /**\n   * Arguments passed by the user.\n   */\n  ...args: ParametersExceptFirst<T>\n) => Omit<HashedOp, \"data\" | \"error\">;\n\nexport type StepHandler = (info: {\n  matchOp: MatchOpFn;\n  opts?: StepToolOptions;\n  args: [StepOptionsOrId, ...unknown[]];\n}) => Promise<unknown>;\n\nexport interface StepToolOptions<\n  T extends (...args: unknown[]) => Promise<unknown> = (\n    ...args: unknown[]\n  ) => Promise<unknown>,\n> {\n  /**\n   * Optionally, we can also provide a function that will be called when\n   * Inngest tells us to run this operation.\n   *\n   * If this function is defined, the first time the tool is used it will\n   * report the desired operation (including options) to the Inngest. Inngest\n   * will then call back to the function to tell it to run the step and then\n   * retrieve data.\n   *\n   * We do this in order to allow functionality such as per-step retries; this\n   * gives the SDK the opportunity to tell Inngest what it wants to do before\n   * it does it.\n   *\n   * This function is passed the arguments passed by the user. It will be run\n   * when we receive an operation matching this one that does not contain a\n   * `data` property.\n   */\n  fn?: (...args: Parameters<T>) => unknown;\n}\n\nexport const getStepOptions = (options: StepOptionsOrId): StepOptions => {\n  if (typeof options === \"string\") {\n    return { id: options };\n  }\n\n  return options;\n};\n\n/**\n * Suffix used to namespace steps that are automatically indexed.\n */\nexport const STEP_INDEXING_SUFFIX = \":\";\n\n/**\n * Create a new set of step function tools ready to be used in a step function.\n * This function should be run and a fresh set of tools provided every time a\n * function is run.\n *\n * An op stack (function state) is passed in as well as some mutable properties\n * that the tools can use to submit a new op.\n */\nexport const createStepTools = <TClient extends Inngest.Any>(\n  client: TClient,\n  execution: InngestExecution,\n  stepHandler: StepHandler,\n) => {\n  /**\n   * A local helper used to create tools that can be used to submit an op.\n   *\n   * When using this function, a generic type should be provided which is the\n   * function signature exposed to the user.\n   */\n  // biome-ignore lint/suspicious/noExplicitAny: <explanation>\n  const createTool = <T extends (...args: any[]) => Promise<unknown>>(\n    /**\n     * A function that returns an ID for this op. This is used to ensure that\n     * the op stack is correctly filled, submitted, and retrieved with the same\n     * ID.\n     *\n     * It is passed the arguments passed by the user.\n     *\n     * Most simple tools will likely only need to define this.\n     */\n    matchOp: MatchOpFn<T>,\n    opts?: StepToolOptions<T>,\n  ): T => {\n    return (async (...args: Parameters<T>): Promise<unknown> => {\n      const parsedArgs = args as unknown as [StepOptionsOrId, ...unknown[]];\n      return stepHandler({ args: parsedArgs, matchOp, opts });\n    }) as T;\n  };\n\n  /**\n   * Create a new step run tool that can be used to run a step function using\n   * `step.run()` as a shim.\n   */\n  const createStepRun = (\n    /**\n     * The sub-type of this step tool, exposed via `opts.type` when the op is\n     * reported.\n     */\n    type?: string,\n  ) => {\n    return createTool<\n      // biome-ignore lint/suspicious/noExplicitAny: <explanation>\n      <TFn extends (...args: any[]) => unknown>(\n        idOrOptions: StepOptionsOrId,\n\n        /**\n         * The function to run when this step is executed. Can be synchronous or\n         * asynchronous.\n         *\n         * The return value of this function will be the return value of this\n         * call to `run`, meaning you can return and reason about return data\n         * for next steps.\n         */\n        fn: TFn,\n\n        /**\n         * Optional input to pass to the function. If this is specified, Inngest\n         * will keep track of the input for this step and be able to display it\n         * in the UI.\n         */\n        ...input: Parameters<TFn>\n      ) => Promise<\n        /**\n         * TODO Middleware can affect this. If run input middleware has returned\n         * new step data, do not Jsonify.\n         */\n        SimplifyDeep<\n          Jsonify<\n            TFn extends (...args: Parameters<TFn>) => Promise<infer U>\n              ? Awaited<U extends void ? null : U>\n              : ReturnType<TFn> extends void\n                ? null\n                : ReturnType<TFn>\n          >\n        >\n      >\n    >(\n      ({ id, name }, _fn, ...input) => {\n        const opts: HashedOp[\"opts\"] = {\n          ...(input.length ? { input } : {}),\n          ...(type ? { type } : {}),\n        };\n\n        return {\n          id,\n          op: StepOpCode.StepPlanned,\n          name: id,\n          displayName: name ?? id,\n          ...(Object.keys(opts).length ? { opts } : {}),\n        };\n      },\n      {\n        fn: (_, fn, ...input) => fn(...input),\n      },\n    );\n  };\n\n  /**\n   * Define the set of tools the user has access to for their step functions.\n   *\n   * Each key is the function name and is expected to run `createTool` and pass\n   * a generic type for that function as it will appear in the user's code.\n   */\n  const tools = {\n    /**\n     * Send one or many events to Inngest. Should always be used in place of\n     * `inngest.send()` to ensure that the event send is successfully retried\n     * and not sent multiple times due to memoisation.\n     *\n     * @example\n     * ```ts\n     * await step.sendEvent(\"emit-user-creation\", {\n     *   name: \"app/user.created\",\n     *   data: { id: 123 },\n     * });\n     *\n     * await step.sendEvent(\"emit-user-updates\", [\n     *   {\n     *     name: \"app/user.created\",\n     *     data: { id: 123 },\n     *   },\n     *   {\n     *     name: \"app/user.feed.created\",\n     *     data: { id: 123 },\n     *   },\n     * ]);\n     * ```\n     *\n     * Returns a promise that will resolve once the event has been sent.\n     */\n    sendEvent: createTool<\n      <Payload extends SendEventPayload<GetEvents<TClient>>>(\n        idOrOptions: StepOptionsOrId,\n        payload: Payload,\n      ) => Promise<SendEventOutput<ClientOptionsFromInngest<TClient>>>\n    >(\n      ({ id, name }) => {\n        return {\n          id,\n          op: StepOpCode.StepPlanned,\n          name: \"sendEvent\",\n          displayName: name ?? id,\n          opts: {\n            type: \"step.sendEvent\",\n          },\n        };\n      },\n      {\n        fn: (_idOrOptions, payload) => {\n          return client[\"_send\"]({\n            payload,\n            headers: execution[\"options\"][\"headers\"],\n          });\n        },\n      },\n    ),\n\n    /**\n     * EXPERIMENTAL: This API is not yet stable and may change in the future\n     * without a major version bump.\n     *\n     * Wait for a particular signal to be received before continuing. When the\n     * signal is received, its data will be returned.\n     */\n    waitForSignal: createTool<\n      <TData>(\n        idOrOptions: StepOptionsOrId,\n        opts: WaitForSignalOpts,\n      ) => Promise<{ signal: string; data: Jsonify<TData> } | null>\n    >(({ id, name }, opts) => {\n      // TODO Should support Temporal.DurationLike, Temporal.InstantLike,\n      // Temporal.ZonedDateTimeLike\n      return {\n        id,\n        op: StepOpCode.WaitForSignal,\n        name: opts.signal,\n        displayName: name ?? id,\n        opts: {\n          signal: opts.signal,\n          timeout: timeStr(opts.timeout),\n          conflict: opts.onConflict,\n        },\n      };\n    }),\n\n    /**\n     * Send a Signal to Inngest.\n     */\n    sendSignal: createTool<\n      (idOrOptions: StepOptionsOrId, opts: SendSignalOpts) => Promise<null>\n    >(\n      ({ id, name }, opts) => {\n        return {\n          id,\n          op: StepOpCode.StepPlanned,\n          name: \"sendSignal\",\n          displayName: name ?? id,\n          opts: {\n            type: \"step.sendSignal\",\n            signal: opts.signal,\n          },\n        };\n      },\n      {\n        fn: (_idOrOptions, opts) => {\n          return client[\"_sendSignal\"]({\n            signal: opts.signal,\n            data: opts.data,\n            headers: execution[\"options\"][\"headers\"],\n          });\n        },\n      },\n    ),\n\n    /**\n     * Wait for a particular event to be received before continuing. When the\n     * event is received, it will be returned.\n     *\n     * You can also provide options to control the particular event that is\n     * received, for example to ensure that a user ID matches between two\n     * events, or to only wait a maximum amount of time before giving up and\n     * returning `null` instead of any event data.\n     */\n    waitForEvent: createTool<\n      <IncomingEvent extends WithoutInternalStr<TriggersFromClient<TClient>>>(\n        idOrOptions: StepOptionsOrId,\n        opts: WaitForEventOpts<GetEvents<TClient, true>, IncomingEvent>,\n      ) => Promise<\n        IncomingEvent extends WithoutInternalStr<TriggersFromClient<TClient>>\n          ? GetEvents<TClient, false>[IncomingEvent] | null\n          : IncomingEvent | null\n      >\n    >(\n      (\n        { id, name },\n\n        /**\n         * Options to control the event we're waiting for.\n         */\n        opts,\n      ) => {\n        const matchOpts: { timeout: string; if?: string } = {\n          timeout: timeStr(typeof opts === \"string\" ? opts : opts.timeout),\n        };\n\n        if (typeof opts !== \"string\") {\n          if (opts?.match) {\n            matchOpts.if = `event.${opts.match} == async.${opts.match}`;\n          } else if (opts?.if) {\n            matchOpts.if = opts.if;\n          }\n        }\n\n        return {\n          id,\n          op: StepOpCode.WaitForEvent,\n          name: opts.event,\n          opts: matchOpts,\n          displayName: name ?? id,\n        };\n      },\n    ),\n\n    /**\n     * Use this tool to run business logic. Each call to `run` will be retried\n     * individually, meaning you can compose complex workflows that safely\n     * retry dependent asynchronous actions.\n     *\n     * The function you pass to `run` will be called only when this \"step\" is to\n     * be executed and can be synchronous or asynchronous.\n     *\n     * In either case, the return value of the function will be the return value\n     * of the `run` tool, meaning you can return and reason about return data\n     * for next steps.\n     */\n    run: createStepRun(),\n\n    /**\n     * AI tooling for running AI models and other AI-related tasks.\n     */\n    ai: {\n      /**\n       * Use this tool to have Inngest make your AI calls. Useful for agentic workflows.\n       *\n       * Input is also tracked for this tool, meaning you can pass input to the\n       * function and it will be displayed and editable in the UI.\n       */\n      infer: createTool<\n        <TAdapter extends AiAdapter>(\n          idOrOptions: StepOptionsOrId,\n          options: AiInferOpts<TAdapter>,\n        ) => Promise<AiAdapter.Output<TAdapter>>\n      >(({ id, name }, options) => {\n        // eslint-disable-next-line\n        const { model, body, ...rest } = options;\n\n        const modelCopy = { ...model };\n\n        // Allow the model to mutate options and body for this call\n        options.model.onCall?.(modelCopy, options.body);\n\n        return {\n          id,\n          op: StepOpCode.AiGateway,\n          displayName: name ?? id,\n          opts: {\n            type: \"step.ai.infer\",\n            url: modelCopy.url,\n            headers: modelCopy.headers,\n            auth_key: modelCopy.authKey,\n            format: modelCopy.format,\n            // eslint-disable-next-line\n            body,\n            // eslint-disable-next-line\n            ...rest,\n          },\n        };\n      }),\n\n      /**\n       * Use this tool to wrap AI models and other AI-related tasks. Each call\n       * to `wrap` will be retried individually, meaning you can compose complex\n       * workflows that safely retry dependent asynchronous actions.\n       *\n       * Input is also tracked for this tool, meaning you can pass input to the\n       * function and it will be displayed and editable in the UI.\n       */\n      wrap: createStepRun(\"step.ai.wrap\"),\n\n      /**\n       * Models for AI inference and other AI-related tasks.\n       */\n      models: {\n        ...models,\n      },\n    },\n\n    /**\n     * Wait a specified amount of time before continuing.\n     *\n     * The time to wait can be specified using a `number` of milliseconds or an\n     * `ms`-compatible time string like `\"1 hour\"`, `\"30 mins\"`, or `\"2.5d\"`.\n     *\n     * {@link https://npm.im/ms}\n     *\n     * To wait until a particular date, use `sleepUntil` instead.\n     */\n    sleep: createTool<\n      (\n        idOrOptions: StepOptionsOrId,\n\n        /**\n         * The amount of time to wait before continuing.\n         */\n        time: number | string | Temporal.DurationLike,\n      ) => Promise<void>\n    >(({ id, name }, time) => {\n      /**\n       * The presence of this operation in the returned stack indicates that the\n       * sleep is over and we should continue execution.\n       */\n      const msTimeStr: string = timeStr(\n        Temporal.isTemporalDuration(time)\n          ? time.total({ unit: \"milliseconds\" })\n          : (time as number | string),\n      );\n\n      return {\n        id,\n        op: StepOpCode.Sleep,\n        name: msTimeStr,\n        displayName: name ?? id,\n      };\n    }),\n\n    /**\n     * Wait until a particular date before continuing by passing a `Date`.\n     *\n     * To wait for a particular amount of time from now, always use `sleep`\n     * instead.\n     */\n    sleepUntil: createTool<\n      (\n        idOrOptions: StepOptionsOrId,\n\n        /**\n         * The date to wait until before continuing.\n         */\n        time: Date | string | Temporal.InstantLike | Temporal.ZonedDateTimeLike,\n      ) => Promise<void>\n    >(({ id, name }, time) => {\n      try {\n        const iso = Temporal.getISOString(time);\n\n        /**\n         * The presence of this operation in the returned stack indicates that the\n         * sleep is over and we should continue execution.\n         */\n        return {\n          id,\n          op: StepOpCode.Sleep,\n          name: iso,\n          displayName: name ?? id,\n        };\n      } catch (err) {\n        /**\n         * If we're here, it's because the date is invalid. We'll throw a custom\n         * error here to standardise this response.\n         */\n        // TODO PrettyError\n        console.warn(\n          \"Invalid `Date`, date string, `Temporal.Instant`, or `Temporal.ZonedDateTime` passed to sleepUntil;\",\n          err,\n        );\n\n        // TODO PrettyError\n        throw new Error(\n          `Invalid \\`Date\\`, date string, \\`Temporal.Instant\\`, or \\`Temporal.ZonedDateTime\\` passed to sleepUntil: ${\n            time\n          }`,\n        );\n      }\n    }),\n\n    /**\n     * Invoke a passed Inngest `function` with the given `data`. Returns the\n     * result of the returned value of the function or `null` if the function\n     * does not return a value.\n     *\n     * A string ID can also be passed to reference functions outside of the\n     * current app.\n     */\n    invoke: createTool<\n      <TFunction extends InvokeTargetFunctionDefinition>(\n        idOrOptions: StepOptionsOrId,\n        opts: InvocationOpts<TFunction>,\n      ) => InvocationResult<GetFunctionOutput<TFunction>>\n    >(({ id, name }, invokeOpts) => {\n      // Create a discriminated union to operate on based on the input types\n      // available for this tool.\n      const optsSchema = invokePayloadSchema.extend({\n        timeout: z.union([z.number(), z.string(), z.date()]).optional(),\n      });\n\n      const parsedFnOpts = optsSchema\n        .extend({\n          _type: z.literal(\"fullId\").optional().default(\"fullId\"),\n          function: z.string().min(1),\n        })\n        .or(\n          optsSchema.extend({\n            _type: z.literal(\"fnInstance\").optional().default(\"fnInstance\"),\n            function: z.instanceof(InngestFunction),\n          }),\n        )\n        .or(\n          optsSchema.extend({\n            _type: z.literal(\"refInstance\").optional().default(\"refInstance\"),\n            function: z.instanceof(InngestFunctionReference),\n          }),\n        )\n        .safeParse(invokeOpts);\n\n      if (!parsedFnOpts.success) {\n        throw new Error(\n          `Invalid invocation options passed to invoke; must include either a function or functionId.`,\n        );\n      }\n\n      const { _type, function: fn, data, user, v, timeout } = parsedFnOpts.data;\n      const payload = { data, user, v } satisfies MinimalEventPayload;\n      const opts: {\n        payload: MinimalEventPayload;\n        function_id: string;\n        timeout?: string;\n      } = {\n        payload,\n        function_id: \"\",\n        timeout: typeof timeout === \"undefined\" ? undefined : timeStr(timeout),\n      };\n\n      switch (_type) {\n        case \"fnInstance\":\n          opts.function_id = fn.id(fn[\"client\"].id);\n          break;\n\n        case \"fullId\":\n          console.warn(\n            `${logPrefix} Invoking function with \\`function: string\\` is deprecated and will be removed in v4.0.0; use an imported function or \\`referenceFunction()\\` instead. See https://innge.st/ts-referencing-functions`,\n          );\n          opts.function_id = fn;\n          break;\n\n        case \"refInstance\":\n          opts.function_id = [fn.opts.appId || client.id, fn.opts.functionId]\n            .filter(Boolean)\n            .join(\"-\");\n          break;\n      }\n\n      return {\n        id,\n        op: StepOpCode.InvokeFunction,\n        displayName: name ?? id,\n        opts,\n      };\n    }),\n\n    /**\n     * `step.fetch` is a Fetch-API-compatible function that can be used to make\n     * any HTTP code durable if it's called within an Inngest function.\n     *\n     * It will gracefully fall back to the global `fetch` if called outside of\n     * this context, and a custom fallback can be set using the `config` method.\n     */\n    fetch: stepFetch,\n  };\n\n  // Add an uptyped gateway\n  (tools as unknown as InternalStepTools)[gatewaySymbol] = createTool(\n    ({ id, name }, input, init) => {\n      const url = input instanceof Request ? input.url : input.toString();\n\n      const headers: Record<string, string> = {};\n      if (input instanceof Request) {\n        input.headers.forEach((value, key) => {\n          headers[key] = value;\n        });\n      } else if (init?.headers) {\n        const h = new Headers(init.headers);\n        h.forEach((value, key) => {\n          headers[key] = value;\n        });\n      }\n\n      return {\n        id,\n        op: StepOpCode.Gateway,\n        displayName: name ?? id,\n        opts: {\n          url,\n          method: init?.method ?? \"GET\",\n          headers,\n          body: init?.body,\n        },\n      };\n    },\n  );\n\n  return tools;\n};\n\nexport const gatewaySymbol = Symbol.for(\"inngest.step.gateway\");\n\nexport type InternalStepTools = GetStepTools<Inngest.Any> & {\n  [gatewaySymbol]: (\n    idOrOptions: StepOptionsOrId,\n    ...args: Parameters<typeof fetch>\n  ) => Promise<{\n    status: number;\n    headers: Record<string, string>;\n    body: string;\n  }>;\n};\n\n/**\n * The event payload portion of the options for `step.invoke()`. This does not\n * include non-payload options like `timeout` or the function to invoke.\n */\nexport const invokePayloadSchema = z.object({\n  data: z.record(z.any()).optional(),\n  user: z.record(z.any()).optional(),\n  v: z.string().optional(),\n});\n\ntype InvocationTargetOpts<TFunction extends InvokeTargetFunctionDefinition> = {\n  function: TFunction;\n};\n\ntype InvocationOpts<TFunction extends InvokeTargetFunctionDefinition> =\n  InvocationTargetOpts<TFunction> &\n    Omit<TriggerEventFromFunction<TFunction>, \"id\"> & {\n      /**\n       * The step function will wait for the invocation to finish for a maximum\n       * of this time, at which point the retured promise will be rejected\n       * instead of resolved with the output of the invoked function.\n       *\n       * Note that the invoked function will continue to run even if this step\n       * times out.\n       *\n       * The time to wait can be specified using a `number` of milliseconds, an\n       * `ms`-compatible time string like `\"1 hour\"`, `\"30 mins\"`, or `\"2.5d\"`,\n       * or a `Date` object.\n       *\n       * {@link https://npm.im/ms}\n       */\n      timeout?: number | string | Date;\n    };\n\n/**\n * A set of parameters given to a `sendSignal` call.\n */\ntype SendSignalOpts = {\n  /**\n   * The signal to send.\n   */\n  signal: string;\n\n  /**\n   * The data to send with the signal.\n   */\n  data?: unknown;\n};\n\n/**\n * A set of parameters given to a `waitForSignal` call.\n */\ntype WaitForSignalOpts = {\n  /**\n   * The signal to wait for.\n   */\n  signal: string;\n\n  /**\n   * The step function will wait for the signal for a maximum of this time, at\n   * which point the signal will be returned as `null` instead of any signal\n   * data.\n   *\n   * The time to wait can be specified using a `number` of milliseconds, an\n   * `ms`-compatible time string like `\"1 hour\"`, `\"30 mins\"`, or `\"2.5d\"`, or\n   * a `Date` object.\n   *\n   * {@link https://npm.im/ms}\n   */\n  timeout: number | string | Date;\n\n  /**\n   * When this `step.waitForSignal()` call is made, choose whether an existing\n   * wait for the same signal should be replaced, or whether this run should\n   * fail.\n   *\n   * `\"replace\"` will replace any existing wait with this one, and the existing\n   * wait will remain pending until it reaches its timeout.\n   *\n   * `\"fail\"` will cause this run to fail if there is already a wait for the\n   * same signal.\n   */\n  onConflict: \"replace\" | \"fail\";\n};\n\n/**\n * A set of optional parameters given to a `waitForEvent` call to control how\n * the event is handled.\n */\ntype WaitForEventOpts<\n  Events extends Record<string, EventPayload>,\n  IncomingEvent extends keyof Events,\n> = {\n  event: IncomingEvent;\n\n  /**\n   * The step function will wait for the event for a maximum of this time, at\n   * which point the event will be returned as `null` instead of any event data.\n   *\n   * The time to wait can be specified using a `number` of milliseconds, an\n   * `ms`-compatible time string like `\"1 hour\"`, `\"30 mins\"`, or `\"2.5d\"`, or\n   * a `Date` object.\n   *\n   * {@link https://npm.im/ms}\n   */\n  timeout: number | string | Date;\n} & ExclusiveKeys<\n  {\n    /**\n     * If provided, the step function will wait for the incoming event to match\n     * particular criteria. If the event does not match, it will be ignored and\n     * the step function will wait for another event.\n     *\n     * It must be a string of a dot-notation field name within both events to\n     * compare, e.g. `\"data.id\"` or `\"user.email\"`.\n     *\n     * ```\n     * // Wait for an event where the `user.email` field matches\n     * match: \"user.email\"\n     * ```\n     *\n     * All of these are helpers for the `if` option, which allows you to specify\n     * a custom condition to check. This can be useful if you need to compare\n     * multiple fields or use a more complex condition.\n     *\n     * See the Inngest expressions docs for more information.\n     *\n     * {@link https://www.inngest.com/docs/functions/expressions}\n     *\n     * @deprecated Use `if` instead.\n     */\n    match?: string;\n\n    /**\n     * If provided, the step function will wait for the incoming event to match\n     * the given condition. If the event does not match, it will be ignored and\n     * the step function will wait for another event.\n     *\n     * The condition is a string of Google's Common Expression Language. For most\n     * simple cases, you might prefer to use `match` instead.\n     *\n     * See the Inngest expressions docs for more information.\n     *\n     * {@link https://www.inngest.com/docs/functions/expressions}\n     */\n    if?: string;\n  },\n  \"match\",\n  \"if\"\n>;\n\n/**\n * Options for `step.ai.infer()`.\n */\ntype AiInferOpts<TModel extends AiAdapter> = {\n  /**\n   * The model to use for the inference. Create a model by importing from\n   * `\"inngest\"` or by using `step.ai.models.*`.\n   *\n   * @example Import `openai()`\n   * ```ts\n   * import { openai } from \"inngest\";\n   *\n   * const model = openai({ model: \"gpt-4\" });\n   * ```\n   *\n   * @example Use a model from `step.ai.models`\n   * ```ts\n   * async ({ step }) => {\n   *            const model = step.ai.models.openai({ model: \"gpt-4\" });\n   * }\n   * ```\n   */\n  model: TModel;\n\n  /**\n   * The input to pass to the model.\n   */\n  body: AiAdapter.Input<TModel>;\n};\n"],"names":["opts: HashedOp[\"opts\"]","matchOpts: { timeout: string; if?: string }","msTimeStr: string","Temporal.isTemporalDuration","Temporal.getISOString","opts: {\n        payload: MinimalEventPayload;\n        function_id: string;\n        timeout?: string;\n      }","stepFetch","headers: Record<string, string>"],"mappings":"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","debugId":null}},
    {"offset": {"line": 4285, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/inngest/components/execution/v0.js","sources":["file:///Users/harshitgangwar/Desktop/SkillForge/node_modules/src/components/execution/v0.ts"],"sourcesContent":["import canonicalize from \"canonicalize\";\nimport hashjs from \"hash.js\";\nimport { z } from \"zod/v3\";\nimport {\n  deserializeError,\n  ErrCode,\n  functionStoppedRunningErr,\n  prettyError,\n  serializeError,\n} from \"../../helpers/errors.ts\";\nimport { undefinedToNull } from \"../../helpers/functions.ts\";\nimport {\n  resolveAfterPending,\n  resolveNextTick,\n  runAsPromise,\n} from \"../../helpers/promises.ts\";\nimport type { MaybePromise, PartialK } from \"../../helpers/types.ts\";\nimport {\n  type BaseContext,\n  type Context,\n  type EventPayload,\n  type FailureEventArgs,\n  type Handler,\n  type HashedOp,\n  type IncomingOp,\n  jsonErrorSchema,\n  type OpStack,\n  type OutgoingOp,\n  StepOpCode,\n} from \"../../types.ts\";\nimport type { Inngest } from \"../Inngest.ts\";\nimport { getHookStack, type RunHookStack } from \"../InngestMiddleware.ts\";\nimport {\n  createStepTools,\n  getStepOptions,\n  type StepHandler,\n} from \"../InngestStepTools.ts\";\nimport { NonRetriableError } from \"../NonRetriableError.ts\";\nimport { RetryAfterError } from \"../RetryAfterError.ts\";\nimport {\n  type ExecutionResult,\n  type IInngestExecution,\n  InngestExecution,\n  type InngestExecutionFactory,\n  type InngestExecutionOptions,\n  type MemoizedOp,\n} from \"./InngestExecution.ts\";\n\nconst { sha1 } = hashjs;\n\nexport const createV0InngestExecution: InngestExecutionFactory = (options) => {\n  return new V0InngestExecution(options);\n};\n\nexport class V0InngestExecution\n  extends InngestExecution\n  implements IInngestExecution\n{\n  private state: V0ExecutionState;\n  private execution: Promise<ExecutionResult> | undefined;\n  private userFnToRun: Handler.Any;\n  private fnArg: Context.Any;\n\n  constructor(options: InngestExecutionOptions) {\n    super(options);\n\n    this.userFnToRun = this.getUserFnToRun();\n    this.state = this.createExecutionState();\n    this.fnArg = this.createFnArg();\n  }\n\n  public start() {\n    this.debug(\"starting V0 execution\");\n\n    // biome-ignore lint/suspicious/noAssignInExpressions: <explanation>\n    return (this.execution ??= this._start().then((result) => {\n      this.debug(\"result:\", result);\n      return result;\n    }));\n  }\n\n  private async _start(): Promise<ExecutionResult> {\n    this.state.hooks = await this.initializeMiddleware();\n\n    try {\n      await this.transformInput();\n      await this.state.hooks.beforeMemoization?.();\n\n      if (this.state.opStack.length === 0 && !this.options.requestedRunStep) {\n        await this.state.hooks.afterMemoization?.();\n        await this.state.hooks.beforeExecution?.();\n      }\n\n      const userFnPromise = runAsPromise(() => this.userFnToRun(this.fnArg));\n\n      let pos = -1;\n\n      do {\n        if (pos >= 0) {\n          if (\n            !this.options.requestedRunStep &&\n            pos === this.state.opStack.length - 1\n          ) {\n            await this.state.hooks.afterMemoization?.();\n            await this.state.hooks.beforeExecution?.();\n          }\n\n          this.state.tickOps = {};\n          const incomingOp = this.state.opStack[pos] as IncomingOp;\n          this.state.currentOp = this.state.allFoundOps[incomingOp.id];\n\n          if (!this.state.currentOp) {\n            /**\n             * We're trying to resume the function, but we can't find where to go.\n             *\n             * This means that either the function has changed or there are async\n             * actions in-between steps that we haven't noticed in previous\n             * executions.\n             *\n             * Whichever the case, this is bad and we can't continue in this\n             * undefined state.\n             */\n            throw new NonRetriableError(\n              prettyError({\n                whatHappened: \" Your function was stopped from running\",\n                why: \"We couldn't resume your function's state because it may have changed since the run started or there are async actions in-between steps that we haven't noticed in previous executions.\",\n                consequences:\n                  \"Continuing to run the function may result in unexpected behaviour, so we've stopped your function to ensure nothing unexpected happened!\",\n                toFixNow:\n                  \"Ensure that your function is either entirely step-based or entirely non-step-based, by either wrapping all asynchronous logic in `step.run()` calls or by removing all `step.*()` calls.\",\n                otherwise:\n                  \"For more information on why step functions work in this manner, see https://www.inngest.com/docs/functions/multi-step#gotchas\",\n                stack: true,\n                code: ErrCode.NON_DETERMINISTIC_FUNCTION,\n              }),\n            );\n          }\n\n          this.state.currentOp.fulfilled = true;\n\n          if (typeof incomingOp.data !== \"undefined\") {\n            this.state.currentOp.resolve(incomingOp.data);\n          } else {\n            this.state.currentOp.reject(incomingOp.error);\n          }\n        }\n\n        await resolveAfterPending();\n        this.state.reset();\n        pos++;\n      } while (pos < this.state.opStack.length);\n\n      await this.state.hooks.afterMemoization?.();\n\n      const discoveredOps = Object.values(this.state.tickOps).map<OutgoingOp>(\n        tickOpToOutgoing,\n      );\n\n      const runStep =\n        this.options.requestedRunStep ||\n        this.getEarlyExecRunStep(discoveredOps);\n\n      if (runStep) {\n        const userFnOp = this.state.allFoundOps[runStep];\n        const stepToRun = userFnOp?.fn;\n\n        if (!stepToRun) {\n          throw new Error(\n            `Bad stack; executor requesting to run unknown step \"${runStep}\"`,\n          );\n        }\n\n        const outgoingUserFnOp = {\n          ...tickOpToOutgoing(userFnOp),\n          op: StepOpCode.Step,\n        };\n\n        await this.state.hooks.beforeExecution?.();\n        this.state.executingStep = true;\n\n        const result = await runAsPromise(stepToRun)\n          .finally(() => {\n            this.state.executingStep = false;\n          })\n          .catch(async (error: Error) => {\n            return await this.transformOutput({ error }, outgoingUserFnOp);\n          })\n          .then(async (data) => {\n            await this.state.hooks?.afterExecution?.();\n            return await this.transformOutput({ data }, outgoingUserFnOp);\n          });\n\n        const { type: _type, ...rest } = result;\n\n        return {\n          type: \"step-ran\",\n          ctx: this.fnArg,\n          ops: this.ops,\n          step: { ...outgoingUserFnOp, ...rest },\n        };\n      }\n\n      if (!discoveredOps.length) {\n        const fnRet = await Promise.race([\n          userFnPromise.then((data) => ({ type: \"complete\", data }) as const),\n          resolveNextTick().then(() => ({ type: \"incomplete\" }) as const),\n        ]);\n\n        if (fnRet.type === \"complete\") {\n          await this.state.hooks.afterExecution?.();\n\n          const allOpsFulfilled = Object.values(this.state.allFoundOps).every(\n            (op) => {\n              return op.fulfilled;\n            },\n          );\n\n          if (allOpsFulfilled) {\n            return await this.transformOutput({ data: fnRet.data });\n          }\n        } else if (!this.state.hasUsedTools) {\n          this.state.nonStepFnDetected = true;\n          const data = await userFnPromise;\n          await this.state.hooks.afterExecution?.();\n          return await this.transformOutput({ data });\n        } else {\n          const hasOpsPending = Object.values(this.state.allFoundOps).some(\n            (op) => {\n              return op.fulfilled === false;\n            },\n          );\n\n          if (!hasOpsPending) {\n            throw new NonRetriableError(\n              functionStoppedRunningErr(\n                ErrCode.ASYNC_DETECTED_AFTER_MEMOIZATION,\n              ),\n            );\n          }\n        }\n      }\n\n      await this.state.hooks.afterExecution?.();\n\n      return {\n        type: \"steps-found\",\n        ctx: this.fnArg,\n        ops: this.ops,\n        steps: discoveredOps as [OutgoingOp, ...OutgoingOp[]],\n      };\n    } catch (error) {\n      return await this.transformOutput({ error });\n    } finally {\n      await this.state.hooks.beforeResponse?.();\n    }\n  }\n\n  private async initializeMiddleware(): Promise<RunHookStack> {\n    const ctx = this.options.data as Pick<\n      Readonly<BaseContext<Inngest.Any>>,\n      \"event\" | \"events\" | \"runId\"\n    >;\n\n    const hooks = await getHookStack(\n      this.options.fn[\"middleware\"],\n      \"onFunctionRun\",\n      {\n        ctx,\n        fn: this.options.fn,\n        steps: Object.values(this.options.stepState),\n        reqArgs: this.options.reqArgs,\n      },\n      {\n        transformInput: (prev, output) => {\n          return {\n            ctx: { ...prev.ctx, ...output?.ctx },\n            fn: this.options.fn,\n            steps: prev.steps.map((step, i) => ({\n              ...step,\n              ...output?.steps?.[i],\n            })),\n            reqArgs: prev.reqArgs,\n          };\n        },\n        transformOutput: (prev, output) => {\n          return {\n            result: { ...prev.result, ...output?.result },\n            step: prev.step,\n          };\n        },\n      },\n    );\n\n    return hooks;\n  }\n\n  private createExecutionState(): V0ExecutionState {\n    const state: V0ExecutionState = {\n      allFoundOps: {},\n      tickOps: {},\n      tickOpHashes: {},\n      currentOp: undefined,\n      hasUsedTools: false,\n      reset: () => {\n        state.tickOpHashes = {};\n        state.allFoundOps = { ...state.allFoundOps, ...state.tickOps };\n      },\n      nonStepFnDetected: false,\n      executingStep: false,\n      opStack: this.options.stepCompletionOrder.reduce<IncomingOp[]>(\n        (acc, stepId) => {\n          const stepState = this.options.stepState[stepId];\n          if (!stepState) {\n            return acc;\n          }\n\n          return [...acc, stepState];\n        },\n        [],\n      ),\n    };\n\n    return state;\n  }\n\n  get ops(): Record<string, MemoizedOp> {\n    return Object.fromEntries(\n      Object.entries(this.state.allFoundOps).map<[string, MemoizedOp]>(\n        ([id, op]) => [\n          id,\n          {\n            id: op.id,\n            rawArgs: op.rawArgs,\n            data: op.data,\n            error: op.error,\n            fulfilled: op.fulfilled,\n            seen: true,\n          },\n        ],\n      ),\n    );\n  }\n\n  private getUserFnToRun(): Handler.Any {\n    if (!this.options.isFailureHandler) {\n      return this.options.fn[\"fn\"];\n    }\n\n    if (!this.options.fn[\"onFailureFn\"]) {\n      /**\n       * Somehow, we've ended up detecting that this is a failure handler but\n       * doesn't have an `onFailure` function. This should never happen.\n       */\n      throw new Error(\"Cannot find function `onFailure` handler\");\n    }\n\n    // TODO: Review; inferred types results in an `any` here!\n    return this.options.fn[\"onFailureFn\"];\n  }\n\n  private createFnArg(): Context.Any {\n    // Start referencing everything\n    this.state.tickOps = this.state.allFoundOps;\n\n    /**\n     * Create a unique hash of an operation using only a subset of the operation's\n     * properties; will never use `data` and will guarantee the order of the\n     * object so we don't rely on individual tools for that.\n     *\n     * If the operation already contains an ID, the current ID will be used\n     * instead, so that users can provide their own IDs.\n     */\n    const hashOp = (\n      /**\n       * The op to generate a hash from. We only use a subset of the op's\n       * properties when creating the hash.\n       */\n      op: PartialK<HashedOp, \"id\">,\n    ): HashedOp => {\n      /**\n       * It's difficult for v0 to understand whether or not an op has\n       * historically contained a custom ID, as all step usage now require them.\n       *\n       * For this reason, we make the assumption that steps in v0 do not have a\n       * custom ID and generate one for them as we would in all recommendations\n       * and examples.\n       */\n      const obj = {\n        parent: this.state.currentOp?.id ?? null,\n        op: op.op,\n        name: op.name as string,\n\n        // Historically, no v0 runs could have options for `step.run()` call,\n        // but this object can be specified in future versions.\n        //\n        // For this purpose, we change this to always use `null` if the op is\n        // that of a `step.run()`.\n        opts: op.op === StepOpCode.StepPlanned ? null : (op.opts ?? null),\n      };\n\n      const collisionHash = _internals.hashData(obj);\n\n      // biome-ignore lint/suspicious/noAssignInExpressions: <explanation>\n      const pos = (this.state.tickOpHashes[collisionHash] =\n        (this.state.tickOpHashes[collisionHash] ?? -1) + 1);\n\n      return {\n        ...op,\n        id: _internals.hashData({ pos, ...obj }),\n      };\n    };\n\n    const stepHandler: StepHandler = ({ args, matchOp, opts }) => {\n      if (this.state.nonStepFnDetected) {\n        throw new NonRetriableError(\n          functionStoppedRunningErr(ErrCode.STEP_USED_AFTER_ASYNC),\n        );\n      }\n\n      if (this.state.executingStep) {\n        throw new NonRetriableError(\n          prettyError({\n            whatHappened: \"Your function was stopped from running\",\n            why: \"We detected that you have nested `step.*` tooling.\",\n            consequences: \"Nesting `step.*` tooling is not supported.\",\n            stack: true,\n            toFixNow:\n              \"Make sure you're not using `step.*` tooling inside of other `step.*` tooling. If you need to compose steps together, you can create a new async function and call it from within your step function, or use promise chaining.\",\n            otherwise:\n              \"For more information on step functions with Inngest, see https://www.inngest.com/docs/functions/multi-step\",\n            code: ErrCode.NESTING_STEPS,\n          }),\n        );\n      }\n\n      this.state.hasUsedTools = true;\n\n      const stepOptions = getStepOptions(args[0]);\n      const opId = hashOp(matchOp(stepOptions, ...args.slice(1)));\n\n      return new Promise<unknown>((resolve, reject) => {\n        this.state.tickOps[opId.id] = {\n          ...opId,\n          ...(opts?.fn ? { fn: () => opts.fn?.(...args) } : {}),\n          rawArgs: args,\n          resolve,\n          reject,\n          fulfilled: false,\n        };\n      });\n    };\n\n    const step = createStepTools(this.options.client, this, stepHandler);\n\n    let fnArg = {\n      ...(this.options.data as { event: EventPayload }),\n      step,\n    } as Context.Any;\n\n    if (this.options.isFailureHandler) {\n      const eventData = z\n        .object({ error: jsonErrorSchema })\n        .parse(fnArg.event?.data);\n\n      (fnArg as Partial<Pick<FailureEventArgs, \"error\">>) = {\n        ...fnArg,\n        error: deserializeError(eventData.error),\n      };\n    }\n\n    return this.options.transformCtx?.(fnArg) ?? fnArg;\n  }\n\n  /**\n   * Using middleware, transform input before running.\n   */\n  private async transformInput() {\n    const inputMutations = await this.state.hooks?.transformInput?.({\n      ctx: { ...this.fnArg },\n      steps: Object.values(this.options.stepState),\n      fn: this.options.fn,\n      reqArgs: this.options.reqArgs,\n    });\n\n    if (inputMutations?.ctx) {\n      this.fnArg = inputMutations.ctx;\n    }\n\n    if (inputMutations?.steps) {\n      this.state.opStack = [...inputMutations.steps];\n    }\n  }\n\n  private getEarlyExecRunStep(ops: OutgoingOp[]): string | undefined {\n    if (ops.length !== 1) return;\n\n    const op = ops[0];\n\n    if (\n      op &&\n      op.op === StepOpCode.StepPlanned\n      // TODO We must individually check properties here that we do not want to\n      // execute on, such as retry counts. Nothing exists here that falls in to\n      // this case, but should be accounted for when we add them.\n      // && typeof op.opts === \"undefined\"\n    ) {\n      return op.id;\n    }\n\n    return;\n  }\n\n  /**\n   * Using middleware, transform output before returning.\n   */\n  private async transformOutput(\n    dataOrError: Parameters<\n      NonNullable<RunHookStack[\"transformOutput\"]>\n    >[0][\"result\"],\n    step?: Readonly<Omit<OutgoingOp, \"id\">>,\n  ): Promise<ExecutionResult> {\n    const output = { ...dataOrError };\n\n    if (typeof output.error !== \"undefined\") {\n      output.data = serializeError(output.error);\n    }\n\n    const transformedOutput = await this.state.hooks?.transformOutput?.({\n      result: { ...output },\n      step,\n    });\n\n    const { data, error } = { ...output, ...transformedOutput?.result };\n\n    if (!step) {\n      await this.state.hooks?.finished?.({\n        result: { ...(typeof error !== \"undefined\" ? { error } : { data }) },\n      });\n    }\n\n    if (typeof error !== \"undefined\") {\n      /**\n       * Ensure we give middleware the chance to decide on retriable behaviour\n       * by looking at the error returned from output transformation.\n       */\n      let retriable: boolean | string = !(error instanceof NonRetriableError);\n      if (retriable && error instanceof RetryAfterError) {\n        retriable = error.retryAfter;\n      }\n\n      const serializedError = serializeError(error);\n\n      return {\n        type: \"function-rejected\",\n        ctx: this.fnArg,\n        ops: this.ops,\n        error: serializedError,\n        retriable,\n      };\n    }\n\n    return {\n      type: \"function-resolved\",\n      ctx: this.fnArg,\n      ops: this.ops,\n      data: undefinedToNull(data),\n    };\n  }\n}\n\ninterface TickOp extends HashedOp {\n  rawArgs: unknown[];\n  fn?: (...args: unknown[]) => unknown;\n  fulfilled: boolean;\n  resolve: (value: MaybePromise<unknown>) => void;\n  reject: (reason?: unknown) => void;\n}\n\nexport interface V0ExecutionState {\n  /**\n   * The tree of all found ops in the entire invocation.\n   */\n  allFoundOps: Record<string, TickOp>;\n\n  /**\n   * All synchronous operations found in this particular tick. The array is\n   * reset every tick.\n   */\n  tickOps: Record<string, TickOp>;\n\n  /**\n   * A hash of operations found within this tick, with keys being the hashed\n   * ops themselves (without a position) and the values being the number of\n   * times that op has been found.\n   *\n   * This is used to provide some mutation resilience to the op stack,\n   * allowing us to survive same-tick mutations of code by ensuring per-tick\n   * hashes are based on uniqueness rather than order.\n   */\n  tickOpHashes: Record<string, number>;\n\n  /**\n   * Tracks the current operation being processed. This can be used to\n   * understand the contextual parent of any recorded operations.\n   */\n  currentOp: TickOp | undefined;\n\n  /**\n   * If we've found a user function to run, we'll store it here so a component\n   * higher up can invoke and await it.\n   */\n  userFnToRun?: (...args: unknown[]) => unknown;\n\n  /**\n   * A boolean to represent whether the user's function is using any step\n   * tools.\n   *\n   * If the function survives an entire tick of the event loop and hasn't\n   * touched any tools, we assume that it is a single-step async function and\n   * should be awaited as usual.\n   */\n  hasUsedTools: boolean;\n\n  /**\n   * A function that should be used to reset the state of the tools after a\n   * tick has completed.\n   */\n  reset: () => void;\n\n  /**\n   * If `true`, any use of step tools will, by default, throw an error. We do\n   * this when we detect that a function may be mixing step and non-step code.\n   *\n   * Created step tooling can decide how to manually handle this on a\n   * case-by-case basis.\n   *\n   * In the future, we can provide a way for a user to override this if they\n   * wish to and understand the danger of side-effects.\n   *\n   * Defaults to `false`.\n   */\n  nonStepFnDetected: boolean;\n\n  /**\n   * When true, we are currently executing a user's code for a single step\n   * within a step function.\n   */\n  executingStep: boolean;\n\n  /**\n   * Initialized middleware hooks for this execution.\n   *\n   * Middleware hooks are cached to ensure they can only be run once, which\n   * means that these hooks can be called in many different places to ensure we\n   * handle all possible execution paths.\n   */\n  hooks?: RunHookStack;\n\n  /**\n   * The op stack to pass to the function as state, likely stored in\n   * `ctx._state` in the Inngest payload.\n   *\n   * This must be provided in order to always be cognizant of step function\n   * state and to allow for multi-step functions.\n   */\n  opStack: OpStack;\n}\n\nconst tickOpToOutgoing = (op: TickOp): OutgoingOp => {\n  return {\n    op: op.op,\n    id: op.id,\n    name: op.name,\n    opts: op.opts,\n  };\n};\n\n/**\n * An operation ready to hash to be used to memoise step function progress.\n *\n * @internal\n */\nexport type UnhashedOp = {\n  name: string;\n  op: StepOpCode;\n  opts: Record<string, unknown> | null;\n  parent: string | null;\n  pos?: number;\n};\n\nconst hashData = (op: UnhashedOp): string => {\n  return sha1().update(canonicalize(op)).digest(\"hex\");\n};\n\n/**\n * Exported for testing.\n */\nexport const _internals = { hashData };\n"],"names":["createV0InngestExecution: InngestExecutionFactory","state: V0ExecutionState","stepHandler: StepHandler","retriable: boolean | string"],"mappings":"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","debugId":null}},
    {"offset": {"line": 4719, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/inngest/components/execution/otel/access.js","sources":["file:///Users/harshitgangwar/Desktop/SkillForge/node_modules/src/components/execution/otel/access.ts"],"sourcesContent":["/**\n * A file used to access client processors safely without also importing any\n * otel-specific libraries. Useful for ensuring that the otel libraries can be\n * tree-shaken if they're not used directly by the user.\n */\n\nimport type { Inngest } from \"../../Inngest.ts\";\nimport type { InngestSpanProcessor } from \"./processor.ts\";\n\n/**\n * A map of Inngest clients to their OTel span processors. This is used to\n * ensure that we only create one span processor per client, and that we can\n * access the span processor from the client without exposing the OTel\n * libraries to the user.\n */\nexport const clientProcessorMap = new WeakMap<\n  Inngest.Any,\n  InngestSpanProcessor\n>();\n"],"names":[],"mappings":";;;;;;;;;;AAeA,MAAa,qBAAA,aAAA,GAAqB,IAAI,SAGnC","debugId":null}},
    {"offset": {"line": 4736, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/inngest/components/StepError.js","sources":["file:///Users/harshitgangwar/Desktop/SkillForge/node_modules/src/components/StepError.ts"],"sourcesContent":["import { deserializeError } from \"../helpers/errors.ts\";\nimport { jsonErrorSchema } from \"../types.ts\";\n\n/**\n * An error that represents a step exhausting all retries and failing. This is\n * thrown by an Inngest step if it fails.\n *\n * It's synonymous with an `Error`, with the addition of the `stepId` that\n * failed.\n *\n * @public\n */\nexport class StepError extends Error {\n  public override cause?: unknown;\n\n  constructor(\n    /**\n     * The ID of the step that failed.\n     */\n    public readonly stepId: string,\n    err: unknown,\n  ) {\n    const parsedErr = jsonErrorSchema.parse(err);\n\n    super(parsedErr.message);\n    this.name = parsedErr.name;\n    this.stepId = stepId;\n\n    // Don't show the internal stack trace if we don't have one.\n    this.stack = parsedErr.stack ?? undefined;\n\n    // Try setting the cause if we have one\n    this.cause = parsedErr.cause\n      ? deserializeError(parsedErr.cause, true)\n      : undefined;\n  }\n}\n"],"names":["stepId: string"],"mappings":";;;;;;;;;;;;;;;;;GAYA,IAAa,YAAb,cAA+B,MAAM;IACnB,MAAA;IAEhB,YAIkBA,MAAAA,EAChB,GAAA,CACA;QACA,MAAM,YAAY,qJAAA,CAAgB,KAAA,CAAM,IAAI;QAE5C,KAAA,CAAM,UAAU,OAAA,CAAQ;QALR,IAAA,CAAA,MAAA,GAAA;QAMhB,IAAA,CAAK,IAAA,GAAO,UAAU,IAAA;QACtB,IAAA,CAAK,MAAA,GAAS;QAGd,IAAA,CAAK,KAAA,GAAQ,UAAU,KAAA,IAAS,KAAA;QAGhC,IAAA,CAAK,KAAA,GAAQ,UAAU,KAAA,OACnB,kKAAA,EAAiB,UAAU,KAAA,EAAO,KAAK,GACvC,KAAA","debugId":null}},
    {"offset": {"line": 4771, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/inngest/components/execution/v1.js","sources":["file:///Users/harshitgangwar/Desktop/SkillForge/node_modules/src/components/execution/v1.ts"],"sourcesContent":["import { trace } from \"@opentelemetry/api\";\nimport hashjs from \"hash.js\";\nimport { z } from \"zod/v3\";\nimport { headerKeys, internalEvents } from \"../../helpers/consts.ts\";\nimport {\n  deserializeError,\n  ErrCode,\n  minifyPrettyError,\n  prettyError,\n  serializeError,\n} from \"../../helpers/errors.ts\";\nimport { undefinedToNull } from \"../../helpers/functions.ts\";\nimport {\n  createDeferredPromise,\n  createDeferredPromiseWithStack,\n  createTimeoutPromise,\n  resolveAfterPending,\n  runAsPromise,\n} from \"../../helpers/promises.ts\";\nimport type { MaybePromise, Simplify } from \"../../helpers/types.ts\";\nimport {\n  type BaseContext,\n  type Context,\n  type EventPayload,\n  type FailureEventArgs,\n  type Handler,\n  jsonErrorSchema,\n  type OutgoingOp,\n  StepOpCode,\n} from \"../../types.ts\";\nimport { version } from \"../../version.ts\";\nimport type { Inngest } from \"../Inngest.ts\";\nimport { getHookStack, type RunHookStack } from \"../InngestMiddleware.ts\";\nimport {\n  createStepTools,\n  type FoundStep,\n  getStepOptions,\n  invokePayloadSchema,\n  STEP_INDEXING_SUFFIX,\n  type StepHandler,\n} from \"../InngestStepTools.ts\";\nimport { NonRetriableError } from \"../NonRetriableError.ts\";\nimport { RetryAfterError } from \"../RetryAfterError.ts\";\nimport { StepError } from \"../StepError.ts\";\nimport { getAsyncCtx, getAsyncLocalStorage } from \"./als.ts\";\nimport {\n  type ExecutionResult,\n  type IInngestExecution,\n  InngestExecution,\n  type InngestExecutionFactory,\n  type InngestExecutionOptions,\n  type MemoizedOp,\n} from \"./InngestExecution.ts\";\nimport { clientProcessorMap } from \"./otel/access.ts\";\n\nconst { sha1 } = hashjs;\n\nexport const createV1InngestExecution: InngestExecutionFactory = (options) => {\n  return new V1InngestExecution(options);\n};\n\nclass V1InngestExecution extends InngestExecution implements IInngestExecution {\n  private state: V1ExecutionState;\n  private fnArg: Context.Any;\n  private checkpointHandlers: CheckpointHandlers;\n  private timeoutDuration = 1000 * 10;\n  private execution: Promise<ExecutionResult> | undefined;\n  private userFnToRun: Handler.Any;\n\n  /**\n   * If we're supposed to run a particular step via `requestedRunStep`, this\n   * will be a `Promise` that resolves after no steps have been found for\n   * `timeoutDuration` milliseconds.\n   *\n   * If we're not supposed to run a particular step, this will be `undefined`.\n   */\n  private timeout?: ReturnType<typeof createTimeoutPromise>;\n\n  constructor(options: InngestExecutionOptions) {\n    super(options);\n\n    this.userFnToRun = this.getUserFnToRun();\n    this.state = this.createExecutionState();\n    this.fnArg = this.createFnArg();\n    this.checkpointHandlers = this.createCheckpointHandlers();\n    this.initializeTimer(this.state);\n\n    this.debug(\n      \"created new V1 execution for run;\",\n      this.options.requestedRunStep\n        ? `wanting to run step \"${this.options.requestedRunStep}\"`\n        : \"discovering steps\",\n    );\n\n    this.debug(\"existing state keys:\", Object.keys(this.state.stepState));\n  }\n\n  /**\n   * Idempotently start the execution of the user's function.\n   */\n  public start() {\n    if (!this.execution) {\n      this.debug(\"starting V1 execution\");\n\n      const tracer = trace.getTracer(\"inngest\", version);\n\n      this.execution = getAsyncLocalStorage().then((als) => {\n        return als.run(\n          { app: this.options.client, ctx: this.fnArg },\n          async () => {\n            return tracer.startActiveSpan(\"inngest.execution\", (span) => {\n              clientProcessorMap.get(this.options.client)?.declareStartingSpan({\n                span,\n                runId: this.options.runId,\n                traceparent: this.options.headers[headerKeys.TraceParent],\n                tracestate: this.options.headers[headerKeys.TraceState],\n              });\n\n              return this._start()\n                .then((result) => {\n                  this.debug(\"result:\", result);\n                  return result;\n                })\n                .finally(() => {\n                  span.end();\n                });\n            });\n          },\n        );\n      });\n    }\n\n    return this.execution;\n  }\n\n  /**\n   * Starts execution of the user's function and the core loop.\n   */\n  private async _start(): Promise<ExecutionResult> {\n    try {\n      const allCheckpointHandler = this.getCheckpointHandler(\"\");\n      this.state.hooks = await this.initializeMiddleware();\n      await this.startExecution();\n\n      for await (const checkpoint of this.state.loop) {\n        await allCheckpointHandler(checkpoint);\n\n        const handler = this.getCheckpointHandler(checkpoint.type);\n        const result = await handler(checkpoint);\n\n        if (result) {\n          return result;\n        }\n      }\n    } catch (error) {\n      return await this.transformOutput({ error });\n    } finally {\n      void this.state.loop.return();\n      await this.state.hooks?.beforeResponse?.();\n    }\n\n    /**\n     * If we're here, the generator somehow finished without returning a value.\n     * This should never happen.\n     */\n    throw new Error(\"Core loop finished without returning a value\");\n  }\n\n  /**\n   * Creates a handler for every checkpoint type, defining what to do when we\n   * reach that checkpoint in the core loop.\n   */\n  private createCheckpointHandlers(): CheckpointHandlers {\n    return {\n      /**\n       * Run for all checkpoints. Best used for logging or common actions.\n       * Use other handlers to return values and interrupt the core loop.\n       */\n      \"\": (checkpoint) => {\n        this.debug(\"checkpoint:\", checkpoint);\n      },\n\n      /**\n       * The user's function has completed and returned a value.\n       */\n      \"function-resolved\": async (checkpoint) => {\n        return await this.transformOutput({ data: checkpoint.data });\n      },\n\n      /**\n       * The user's function has thrown an error.\n       */\n      \"function-rejected\": async (checkpoint) => {\n        return await this.transformOutput({ error: checkpoint.error });\n      },\n\n      /**\n       * We've found one or more steps. Here we may want to run a step or report\n       * them back to Inngest.\n       */\n      \"steps-found\": async ({ steps }) => {\n        const stepResult = await this.tryExecuteStep(steps);\n        if (stepResult) {\n          const transformResult = await this.transformOutput(stepResult);\n\n          /**\n           * Transforming output will always return either function rejection or\n           * resolution. In most cases, this can be immediately returned, but in\n           * this particular case we want to handle it differently.\n           */\n          if (transformResult.type === \"function-resolved\") {\n            return {\n              type: \"step-ran\",\n              ctx: transformResult.ctx,\n              ops: transformResult.ops,\n              step: _internals.hashOp({\n                ...stepResult,\n                data: transformResult.data,\n              }),\n            };\n          } else if (transformResult.type === \"function-rejected\") {\n            return {\n              type: \"step-ran\",\n              ctx: transformResult.ctx,\n              ops: transformResult.ops,\n              step: _internals.hashOp({\n                ...stepResult,\n                error: transformResult.error,\n              }),\n              retriable: transformResult.retriable,\n            };\n          }\n\n          return transformResult;\n        }\n\n        const newSteps = await this.filterNewSteps(\n          Array.from(this.state.steps.values()),\n        );\n        if (newSteps) {\n          return {\n            type: \"steps-found\",\n            ctx: this.fnArg,\n            ops: this.ops,\n            steps: newSteps,\n          };\n        }\n\n        return;\n      },\n\n      /**\n       * While trying to find a step that Inngest has told us to run, we've\n       * timed out or have otherwise decided that it doesn't exist.\n       */\n      \"step-not-found\": ({ step }) => {\n        return { type: \"step-not-found\", ctx: this.fnArg, ops: this.ops, step };\n      },\n    };\n  }\n\n  private getCheckpointHandler(type: keyof CheckpointHandlers) {\n    return this.checkpointHandlers[type] as (\n      checkpoint: Checkpoint,\n    ) => MaybePromise<ExecutionResult | undefined>;\n  }\n\n  private async tryExecuteStep(\n    steps: FoundStep[],\n  ): Promise<OutgoingOp | undefined> {\n    const hashedStepIdToRun =\n      this.options.requestedRunStep || this.getEarlyExecRunStep(steps);\n    if (!hashedStepIdToRun) {\n      return;\n    }\n\n    const step = steps.find(\n      (step) => step.hashedId === hashedStepIdToRun && step.fn,\n    );\n\n    if (step) {\n      return await this.executeStep(step);\n    }\n\n    /**\n     * Ensure we reset the timeout if we have a requested run step but couldn't\n     * find it, but also that we don't reset if we found and executed it.\n     */\n    return void this.timeout?.reset();\n  }\n\n  /**\n   * Given a list of outgoing ops, decide if we can execute an op early and\n   * return the ID of the step to execute if we can.\n   */\n  private getEarlyExecRunStep(steps: FoundStep[]): string | undefined {\n    /**\n     * We may have been disabled due to parallelism, in which case we can't\n     * immediately execute unless explicitly requested.\n     */\n    if (this.options.disableImmediateExecution) return;\n\n    const unfulfilledSteps = steps.filter((step) => !step.fulfilled);\n    if (unfulfilledSteps.length !== 1) return;\n\n    const op = unfulfilledSteps[0];\n\n    if (\n      op &&\n      op.op === StepOpCode.StepPlanned\n      // TODO We must individually check properties here that we do not want to\n      // execute on, such as retry counts. Nothing exists here that falls in to\n      // this case, but should be accounted for when we add them.\n      // && typeof op.opts === \"undefined\"\n    ) {\n      return op.hashedId;\n    }\n\n    return;\n  }\n\n  private async filterNewSteps(\n    foundSteps: FoundStep[],\n  ): Promise<[OutgoingOp, ...OutgoingOp[]] | undefined> {\n    if (this.options.requestedRunStep) {\n      return;\n    }\n\n    /**\n     * Gather any steps that aren't memoized and report them.\n     */\n    const newSteps = foundSteps.filter((step) => !step.fulfilled);\n\n    if (!newSteps.length) {\n      return;\n    }\n\n    /**\n     * Warn if we've found new steps but haven't yet seen all previous\n     * steps. This may indicate that step presence isn't determinate.\n     */\n    let knownSteps = 0;\n    for (const step of foundSteps) {\n      if (step.fulfilled) {\n        knownSteps++;\n      }\n    }\n    const foundAllCompletedSteps = this.state.stepsToFulfill === knownSteps;\n\n    if (!foundAllCompletedSteps) {\n      // TODO Tag\n      console.warn(\n        prettyError({\n          type: \"warn\",\n          whatHappened: \"Function may be indeterminate\",\n          why: \"We found new steps before seeing all previous steps, which may indicate that the function is non-deterministic.\",\n          consequences:\n            \"This may cause unexpected behaviour as Inngest executes your function.\",\n          reassurance:\n            \"This is expected if a function is updated in the middle of a run, but may indicate a bug if not.\",\n        }),\n      );\n    }\n\n    /**\n     * We're finishing up; let's trigger the last of the hooks.\n     */\n    await this.state.hooks?.afterMemoization?.();\n    await this.state.hooks?.beforeExecution?.();\n    await this.state.hooks?.afterExecution?.();\n\n    const stepList = newSteps.map<OutgoingOp>((step) => ({\n      displayName: step.displayName,\n      op: step.op,\n      id: step.hashedId,\n      name: step.name,\n      opts: step.opts,\n    })) as [OutgoingOp, ...OutgoingOp[]];\n\n    /**\n     * We also run `onSendEvent` middleware hooks against `step.invoke()` steps\n     * to ensure that their `data` is transformed correctly.\n     */\n    return await this.transformNewSteps(stepList);\n  }\n\n  /**\n   * Using middleware, transform any newly-found steps before returning them to\n   * an Inngest Server.\n   */\n  private async transformNewSteps<T extends [OutgoingOp, ...OutgoingOp[]]>(\n    steps: T,\n  ): Promise<T> {\n    return Promise.all(\n      steps.map(async (step) => {\n        if (step.op !== StepOpCode.InvokeFunction) {\n          return step;\n        }\n\n        const onSendEventHooks = await getHookStack(\n          this.options.fn[\"middleware\"],\n          \"onSendEvent\",\n          undefined,\n          {\n            transformInput: (prev, output) => {\n              return { ...prev, ...output };\n            },\n            transformOutput: (prev, output) => {\n              return {\n                result: { ...prev.result, ...output?.result },\n              };\n            },\n          },\n        );\n\n        /**\n         * For each event being sent, create a new `onSendEvent` hook stack to\n         * process it. We do this as middleware hooks are intended to run once\n         * during each lifecycle (onFunctionRun or onSendEvent) and here, a hook\n         * is run for every single event.\n         *\n         * This is done because a developer can use this hook to filter out\n         * events entirely; if we batch all of the events together, we can't\n         * tell which ones were filtered out if we're processing >1 invocation\n         * here.\n         */\n        const transformedPayload = await onSendEventHooks.transformInput?.({\n          payloads: [\n            {\n              ...(step.opts?.payload ?? {}),\n              name: internalEvents.FunctionInvoked,\n            },\n          ],\n        });\n\n        const newPayload = invokePayloadSchema.parse(\n          transformedPayload?.payloads?.[0] ?? {},\n        );\n\n        return {\n          ...step,\n          opts: {\n            ...step.opts,\n            payload: {\n              ...(step.opts?.payload ?? {}),\n              ...newPayload,\n            },\n          },\n        };\n      }),\n    ) as Promise<T>;\n  }\n\n  private async executeStep({\n    id,\n    name,\n    opts,\n    fn,\n    displayName,\n  }: FoundStep): Promise<OutgoingOp> {\n    this.timeout?.clear();\n    await this.state.hooks?.afterMemoization?.();\n    await this.state.hooks?.beforeExecution?.();\n\n    const outgoingOp: OutgoingOp = {\n      id,\n      op: StepOpCode.StepRun,\n      name,\n      opts,\n      displayName,\n    };\n    this.state.executingStep = outgoingOp;\n\n    const store = await getAsyncCtx();\n\n    if (store) {\n      store.executingStep = {\n        id,\n        name: displayName,\n      };\n    }\n\n    this.debug(`executing step \"${id}\"`);\n\n    return runAsPromise(fn)\n      .finally(async () => {\n        if (store) {\n          delete store.executingStep;\n        }\n\n        await this.state.hooks?.afterExecution?.();\n      })\n      .then<OutgoingOp>((data) => {\n        return {\n          ...outgoingOp,\n          data,\n        };\n      })\n      .catch<OutgoingOp>((error) => {\n        return {\n          ...outgoingOp,\n          op: StepOpCode.StepError,\n\n          error,\n        };\n      });\n  }\n\n  /**\n   * Starts execution of the user's function, including triggering checkpoints\n   * and middleware hooks where appropriate.\n   */\n  private async startExecution(): Promise<void> {\n    /**\n     * Mutate input as neccessary based on middleware.\n     */\n    await this.transformInput();\n\n    /**\n     * Start the timer to time out the run if needed.\n     */\n    void this.timeout?.start();\n\n    await this.state.hooks?.beforeMemoization?.();\n\n    /**\n     * If we had no state to begin with, immediately end the memoization phase.\n     */\n    if (this.state.allStateUsed()) {\n      await this.state.hooks?.afterMemoization?.();\n      await this.state.hooks?.beforeExecution?.();\n    }\n\n    /**\n     * Trigger the user's function.\n     */\n    runAsPromise(() => this.userFnToRun(this.fnArg))\n      .finally(async () => {\n        await this.state.hooks?.afterMemoization?.();\n        await this.state.hooks?.beforeExecution?.();\n        await this.state.hooks?.afterExecution?.();\n      })\n      .then((data) => {\n        this.state.setCheckpoint({ type: \"function-resolved\", data });\n      })\n      .catch((error) => {\n        this.state.setCheckpoint({ type: \"function-rejected\", error });\n      });\n  }\n\n  /**\n   * Using middleware, transform input before running.\n   */\n  private async transformInput() {\n    const inputMutations = await this.state.hooks?.transformInput?.({\n      ctx: { ...this.fnArg },\n      steps: Object.values(this.state.stepState),\n      fn: this.options.fn,\n      reqArgs: this.options.reqArgs,\n    });\n\n    if (inputMutations?.ctx) {\n      this.fnArg = inputMutations.ctx;\n    }\n\n    if (inputMutations?.steps) {\n      this.state.stepState = Object.fromEntries(\n        inputMutations.steps.map((step) => [step.id, step]),\n      );\n    }\n  }\n\n  /**\n   * Using middleware, transform output before returning.\n   */\n  private async transformOutput(\n    dataOrError: Parameters<\n      NonNullable<RunHookStack[\"transformOutput\"]>\n    >[0][\"result\"],\n  ): Promise<ExecutionResult> {\n    const output = { ...dataOrError };\n\n    /**\n     * If we've been given an error and it's one that we just threw from a step,\n     * we should return a `NonRetriableError` to stop execution.\n     */\n    if (typeof output.error !== \"undefined\") {\n      output.data = serializeError(output.error);\n    }\n\n    const isStepExecution = Boolean(this.state.executingStep);\n\n    const transformedOutput = await this.state.hooks?.transformOutput?.({\n      result: { ...output },\n      step: this.state.executingStep,\n    });\n\n    const { data, error } = { ...output, ...transformedOutput?.result };\n\n    if (!isStepExecution) {\n      await this.state.hooks?.finished?.({\n        result: { ...(typeof error !== \"undefined\" ? { error } : { data }) },\n      });\n    }\n\n    if (typeof error !== \"undefined\") {\n      /**\n       * Ensure we give middleware the chance to decide on retriable behaviour\n       * by looking at the error returned from output transformation.\n       */\n      let retriable: boolean | string = !(\n        error instanceof NonRetriableError || error instanceof StepError\n      );\n      if (retriable && error instanceof RetryAfterError) {\n        retriable = error.retryAfter;\n      }\n\n      const serializedError = minifyPrettyError(serializeError(error));\n\n      return {\n        type: \"function-rejected\",\n        ctx: this.fnArg,\n        ops: this.ops,\n        error: serializedError,\n        retriable,\n      };\n    }\n\n    return {\n      type: \"function-resolved\",\n      ctx: this.fnArg,\n      ops: this.ops,\n      data: undefinedToNull(data),\n    };\n  }\n\n  private createExecutionState(): V1ExecutionState {\n    const d = createDeferredPromiseWithStack<Checkpoint>();\n    let checkpointResolve = d.deferred.resolve;\n    const checkpointResults = d.results;\n\n    const loop: V1ExecutionState[\"loop\"] = (async function* (\n      cleanUp?: () => void,\n    ) {\n      try {\n        while (true) {\n          const res = (await checkpointResults.next()).value;\n          if (res) {\n            yield res;\n          }\n        }\n      } finally {\n        cleanUp?.();\n      }\n    })(() => {\n      this.timeout?.clear();\n      void checkpointResults.return();\n    });\n\n    const stepsToFulfill = Object.keys(this.options.stepState).length;\n\n    const state: V1ExecutionState = {\n      stepState: this.options.stepState,\n      stepsToFulfill,\n      steps: new Map(),\n      loop,\n      hasSteps: Boolean(stepsToFulfill),\n      stepCompletionOrder: [...this.options.stepCompletionOrder],\n      remainingStepsToBeSeen: new Set(this.options.stepCompletionOrder),\n      setCheckpoint: (checkpoint: Checkpoint) => {\n        ({ resolve: checkpointResolve } = checkpointResolve(checkpoint));\n      },\n      allStateUsed: () => {\n        return this.state.remainingStepsToBeSeen.size === 0;\n      },\n    };\n\n    return state;\n  }\n\n  get ops(): Record<string, MemoizedOp> {\n    return Object.fromEntries(this.state.steps);\n  }\n\n  private createFnArg(): Context.Any {\n    const step = this.createStepTools();\n\n    let fnArg = {\n      ...(this.options.data as { event: EventPayload }),\n      step,\n    } as Context.Any;\n\n    /**\n     * Handle use of the `onFailure` option by deserializing the error.\n     */\n    if (this.options.isFailureHandler) {\n      const eventData = z\n        .object({ error: jsonErrorSchema })\n        .parse(fnArg.event?.data);\n\n      (fnArg as Partial<Pick<FailureEventArgs, \"error\">>) = {\n        ...fnArg,\n        error: deserializeError(eventData.error),\n      };\n    }\n\n    return this.options.transformCtx?.(fnArg) ?? fnArg;\n  }\n\n  private createStepTools(): ReturnType<typeof createStepTools> {\n    /**\n     * A list of steps that have been found and are being rolled up before being\n     * reported to the core loop.\n     */\n    const foundStepsToReport: Map<string, FoundStep> = new Map();\n\n    /**\n     * A map of the subset of found steps to report that have not yet been\n     * handled. Used for fast access to steps that need to be handled in order.\n     */\n    const unhandledFoundStepsToReport: Map<string, FoundStep> = new Map();\n\n    /**\n     * A map of the latest sequential step indexes found for each step ID. Used\n     * to ensure that we don't index steps in parallel.\n     *\n     * Note that these must be sequential; if we've seen or assigned `a:1`,\n     * `a:2` and `a:4`, the latest sequential step index is `2`.\n     *\n     */\n    const expectedNextStepIndexes: Map<string, number> = new Map();\n\n    /**\n     * An ordered list of step IDs that have yet to be handled in this\n     * execution. Used to ensure that we handle steps in the order they were\n     * found and based on the `stepCompletionOrder` in this execution's state.\n     */\n    const remainingStepCompletionOrder: string[] =\n      this.state.stepCompletionOrder.slice();\n\n    /**\n     * A promise that's used to ensure that step reporting cannot be run more than\n     * once in a given asynchronous time span.\n     */\n    let foundStepsReportPromise: Promise<void> | undefined;\n\n    /**\n     * A promise that's used to represent middleware hooks running before\n     * execution.\n     */\n    let beforeExecHooksPromise: Promise<void> | undefined;\n\n    /**\n     * A flag used to ensure that we only warn about parallel indexing once per\n     * execution to avoid spamming the console.\n     */\n    let warnOfParallelIndexing = false;\n\n    /**\n     * Counts the number of times we've extended this tick.\n     */\n    let tickExtensionCount = 0;\n\n    /**\n     * Given a colliding step ID, maybe warn the user about parallel indexing.\n     */\n    const maybeWarnOfParallelIndexing = (collisionId: string) => {\n      if (warnOfParallelIndexing) {\n        return;\n      }\n\n      const stepExists = this.state.steps.has(collisionId);\n      if (stepExists) {\n        const stepFoundThisTick = foundStepsToReport.has(collisionId);\n        if (!stepFoundThisTick) {\n          warnOfParallelIndexing = true;\n\n          console.warn(\n            prettyError({\n              type: \"warn\",\n              whatHappened:\n                \"We detected that you have multiple steps with the same ID.\",\n              code: ErrCode.AUTOMATIC_PARALLEL_INDEXING,\n              why: `This can happen if you're using the same ID for multiple steps across different chains of parallel work. We found the issue with step \"${collisionId}\".`,\n              reassurance:\n                \"Your function is still running, though it may exhibit unexpected behaviour.\",\n              consequences:\n                \"Using the same IDs across parallel chains of work can cause unexpected behaviour.\",\n              toFixNow:\n                \"We recommend using a unique ID for each step, especially those happening in parallel.\",\n            }),\n          );\n        }\n      }\n    };\n\n    /**\n     * A helper used to report steps to the core loop. Used after adding an item\n     * to `foundStepsToReport`.\n     */\n    const reportNextTick = () => {\n      // Being explicit instead of using `??=` to appease TypeScript.\n      if (foundStepsReportPromise) {\n        return;\n      }\n\n      let extensionPromise: Promise<void>;\n      if (++tickExtensionCount >= 10) {\n        tickExtensionCount = 0;\n        extensionPromise = new Promise((resolve) => setTimeout(resolve));\n      } else {\n        extensionPromise = resolveAfterPending();\n      }\n\n      foundStepsReportPromise = extensionPromise\n        /**\n         * Ensure that we wait for this promise to resolve before continuing.\n         *\n         * The groups in which steps are reported can affect how we detect some\n         * more complex determinism issues like parallel indexing. This promise\n         * can represent middleware hooks being run early, in the middle of\n         * ingesting steps to report.\n         *\n         * Because of this, it's important we wait for this middleware to resolve\n         * before continuing to report steps to ensure that all steps have a\n         * chance to be reported throughout this asynchronous action.\n         */\n        .then(() => beforeExecHooksPromise)\n        .then(() => {\n          foundStepsReportPromise = undefined;\n\n          for (let i = 0; i < remainingStepCompletionOrder.length; i++) {\n            const nextStepId = remainingStepCompletionOrder[i];\n            if (!nextStepId) {\n              // Strange - skip this empty index\n              continue;\n            }\n\n            const handled = unhandledFoundStepsToReport\n              .get(nextStepId)\n              ?.handle();\n            if (handled) {\n              remainingStepCompletionOrder.splice(i, 1);\n              unhandledFoundStepsToReport.delete(nextStepId);\n              return void reportNextTick();\n            }\n          }\n\n          // If we've handled no steps in this \"tick,\" roll up everything we've\n          // found and report it.\n          const steps = [...foundStepsToReport.values()] as [\n            FoundStep,\n            ...FoundStep[],\n          ];\n          foundStepsToReport.clear();\n          unhandledFoundStepsToReport.clear();\n\n          return void this.state.setCheckpoint({\n            type: \"steps-found\",\n            steps: steps,\n          });\n        });\n    };\n\n    /**\n     * A helper used to push a step to the list of steps to report.\n     */\n    const pushStepToReport = (step: FoundStep) => {\n      foundStepsToReport.set(step.id, step);\n      unhandledFoundStepsToReport.set(step.hashedId, step);\n      reportNextTick();\n    };\n\n    const stepHandler: StepHandler = async ({\n      args,\n      matchOp,\n      opts,\n    }): Promise<unknown> => {\n      await beforeExecHooksPromise;\n\n      const stepOptions = getStepOptions(args[0]);\n      const opId = matchOp(stepOptions, ...args.slice(1));\n\n      if (this.state.executingStep) {\n        /**\n         * If a step is found after asynchronous actions during another step's\n         * execution, everything is fine. The problem here is if we've found\n         * that a step nested inside another a step, which is something we don't\n         * support at the time of writing.\n         *\n         * In this case, we could use something like Async Hooks to understand\n         * how the step is being triggered, though this isn't available in all\n         * environments.\n         *\n         * Therefore, we'll only show a warning here to indicate that this is\n         * potentially an issue.\n         */\n        console.warn(\n          prettyError({\n            whatHappened: `We detected that you have nested \\`step.*\\` tooling in \\`${\n              opId.displayName ?? opId.id\n            }\\``,\n            consequences: \"Nesting `step.*` tooling is not supported.\",\n            type: \"warn\",\n            reassurance:\n              \"It's possible to see this warning if steps are separated by regular asynchronous calls, which is fine.\",\n            stack: true,\n            toFixNow:\n              \"Make sure you're not using `step.*` tooling inside of other `step.*` tooling. If you need to compose steps together, you can create a new async function and call it from within your step function, or use promise chaining.\",\n            code: ErrCode.NESTING_STEPS,\n          }),\n        );\n      }\n\n      if (this.state.steps.has(opId.id)) {\n        const originalId = opId.id;\n        maybeWarnOfParallelIndexing(originalId);\n\n        const expectedNextIndex = expectedNextStepIndexes.get(originalId) ?? 1;\n        for (let i = expectedNextIndex; ; i++) {\n          const newId = originalId + STEP_INDEXING_SUFFIX + i;\n\n          if (!this.state.steps.has(newId)) {\n            expectedNextStepIndexes.set(originalId, i + 1);\n            opId.id = newId;\n            break;\n          }\n        }\n      }\n\n      const { promise, resolve, reject } = createDeferredPromise();\n      const hashedId = _internals.hashId(opId.id);\n      const stepState = this.state.stepState[hashedId];\n      let isFulfilled = false;\n      if (stepState) {\n        stepState.seen = true;\n        this.state.remainingStepsToBeSeen.delete(hashedId);\n\n        if (typeof stepState.input === \"undefined\") {\n          isFulfilled = true;\n        }\n      }\n\n      let extraOpts: Record<string, unknown> | undefined;\n      let fnArgs = [...args];\n\n      if (\n        typeof stepState?.input !== \"undefined\" &&\n        Array.isArray(stepState.input)\n      ) {\n        switch (opId.op) {\n          // `step.run()` has its function input affected\n          case StepOpCode.StepPlanned: {\n            fnArgs = [...args.slice(0, 2), ...stepState.input];\n\n            extraOpts = { input: [...stepState.input] };\n            break;\n          }\n\n          // `step.ai.infer()` has its body affected\n          case StepOpCode.AiGateway: {\n            extraOpts = {\n              body: {\n                ...(typeof opId.opts?.body === \"object\"\n                  ? { ...opId.opts.body }\n                  : {}),\n                ...stepState.input[0],\n              },\n            };\n            break;\n          }\n        }\n      }\n\n      const step: FoundStep = {\n        ...opId,\n        opts: { ...opId.opts, ...extraOpts },\n        rawArgs: fnArgs, // TODO What is the right value here? Should this be raw args without affected input?\n        hashedId,\n        input: stepState?.input,\n\n        fn: opts?.fn ? () => opts.fn?.(...fnArgs) : undefined,\n        promise,\n        fulfilled: isFulfilled,\n        hasStepState: Boolean(stepState),\n        displayName: opId.displayName ?? opId.id,\n        handled: false,\n        handle: () => {\n          if (step.handled) {\n            return false;\n          }\n\n          step.handled = true;\n\n          if (isFulfilled && stepState) {\n            stepState.fulfilled = true;\n\n            // For some execution scenarios such as testing, `data`, `error`,\n            // and `input` may be `Promises`. This could also be the case for\n            // future middleware applications. For this reason, we'll make sure\n            // the values are fully resolved before continuing.\n            void Promise.all([\n              stepState.data,\n              stepState.error,\n              stepState.input,\n            ]).then(() => {\n              if (typeof stepState.data !== \"undefined\") {\n                resolve(stepState.data);\n              } else {\n                this.state.recentlyRejectedStepError = new StepError(\n                  opId.id,\n                  stepState.error,\n                );\n\n                reject(this.state.recentlyRejectedStepError);\n              }\n            });\n          }\n\n          return true;\n        },\n      };\n\n      this.state.steps.set(opId.id, step);\n      this.state.hasSteps = true;\n      pushStepToReport(step);\n\n      /**\n       * If this is the last piece of state we had, we've now finished\n       * memoizing.\n       */\n      if (!beforeExecHooksPromise && this.state.allStateUsed()) {\n        // biome-ignore lint/suspicious/noAssignInExpressions: <explanation>\n        await (beforeExecHooksPromise = (async () => {\n          await this.state.hooks?.afterMemoization?.();\n          await this.state.hooks?.beforeExecution?.();\n        })());\n      }\n\n      return promise;\n    };\n\n    return createStepTools(this.options.client, this, stepHandler);\n  }\n\n  private getUserFnToRun(): Handler.Any {\n    if (!this.options.isFailureHandler) {\n      return this.options.fn[\"fn\"];\n    }\n\n    if (!this.options.fn[\"onFailureFn\"]) {\n      /**\n       * Somehow, we've ended up detecting that this is a failure handler but\n       * doesn't have an `onFailure` function. This should never happen.\n       */\n      throw new Error(\"Cannot find function `onFailure` handler\");\n    }\n\n    return this.options.fn[\"onFailureFn\"];\n  }\n\n  private initializeTimer(state: V1ExecutionState): void {\n    if (!this.options.requestedRunStep) {\n      return;\n    }\n\n    this.timeout = createTimeoutPromise(this.timeoutDuration);\n\n    void this.timeout.then(async () => {\n      await this.state.hooks?.afterMemoization?.();\n      await this.state.hooks?.beforeExecution?.();\n      await this.state.hooks?.afterExecution?.();\n\n      state.setCheckpoint({\n        type: \"step-not-found\",\n        step: {\n          id: this.options.requestedRunStep as string,\n          op: StepOpCode.StepNotFound,\n        },\n      });\n    });\n  }\n\n  private async initializeMiddleware(): Promise<RunHookStack> {\n    const ctx = this.options.data as Pick<\n      Readonly<BaseContext<Inngest.Any>>,\n      \"event\" | \"events\" | \"runId\"\n    >;\n\n    const hooks = await getHookStack(\n      this.options.fn[\"middleware\"],\n      \"onFunctionRun\",\n      {\n        ctx,\n        fn: this.options.fn,\n        steps: Object.values(this.options.stepState),\n        reqArgs: this.options.reqArgs,\n      },\n      {\n        transformInput: (prev, output) => {\n          return {\n            ctx: { ...prev.ctx, ...output?.ctx },\n            fn: this.options.fn,\n            steps: prev.steps.map((step, i) => ({\n              ...step,\n              ...output?.steps?.[i],\n            })),\n            reqArgs: prev.reqArgs,\n          };\n        },\n        transformOutput: (prev, output) => {\n          return {\n            result: { ...prev.result, ...output?.result },\n            step: prev.step,\n          };\n        },\n      },\n    );\n\n    return hooks;\n  }\n}\n\n/**\n * Types of checkpoints that can be reached during execution.\n */\nexport interface Checkpoints {\n  \"steps-found\": { steps: [FoundStep, ...FoundStep[]] };\n  \"function-rejected\": { error: unknown };\n  \"function-resolved\": { data: unknown };\n  \"step-not-found\": { step: OutgoingOp };\n}\n\ntype Checkpoint = {\n  [K in keyof Checkpoints]: Simplify<{ type: K } & Checkpoints[K]>;\n}[keyof Checkpoints];\n\ntype CheckpointHandlers = {\n  [C in Checkpoint as C[\"type\"]]: (\n    checkpoint: C,\n  ) => MaybePromise<ExecutionResult | undefined>;\n} & {\n  \"\": (checkpoint: Checkpoint) => MaybePromise<void>;\n};\n\nexport interface V1ExecutionState {\n  /**\n   * A value that indicates that we're executing this step. Can be used to\n   * ensure steps are not accidentally nested until we support this across all\n   * platforms.\n   */\n  executingStep?: Readonly<Omit<OutgoingOp, \"id\">>;\n\n  /**\n   * A map of step IDs to their data, used to fill previously-completed steps\n   * with state from the executor.\n   */\n  stepState: Record<string, MemoizedOp>;\n\n  /**\n   * The number of steps we expect to fulfil based on the state passed from the\n   * Executor.\n   */\n  stepsToFulfill: number;\n\n  /**\n   * A map of step IDs to their functions to run. The executor can request a\n   * specific step to run, so we need to store the function to run here.\n   */\n  steps: Map<string, FoundStep>;\n\n  /**\n   * A flag which represents whether or not steps are understood to be used in\n   * this function. This is used to determine whether or not we should run\n   * some steps (such as `step.sendEvent`) inline as they are found.\n   */\n  hasSteps: boolean;\n\n  /**\n   * The core loop - a generator used to take an action upon finding the next\n   * checkpoint. Manages the flow of execution and cleaning up after itself.\n   */\n  loop: AsyncGenerator<Checkpoint, void, void>;\n\n  /**\n   * A function that resolves the `Promise` returned by `waitForNextDecision`.\n   */\n  setCheckpoint: (data: Checkpoint) => void;\n\n  /**\n   * Initialized middleware hooks for this execution.\n   *\n   * Middleware hooks are cached to ensure they can only be run once, which\n   * means that these hooks can be called in many different places to ensure we\n   * handle all possible execution paths.\n   */\n  hooks?: RunHookStack;\n\n  /**\n   * Returns whether or not all state passed from the executor has been used to\n   * fulfill found steps.\n   */\n  allStateUsed: () => boolean;\n\n  /**\n   * An ordered list of step IDs that represents the order in which their\n   * execution was completed.\n   */\n  stepCompletionOrder: string[];\n\n  /**\n   * An set of step IDs that have yet to be seen in this execution. Used to\n   * decide when to trigger middleware based on the current state.\n   */\n  remainingStepsToBeSeen: Set<string>;\n\n  /**\n   * If defined, this is the error that purposefully thrown when memoizing step\n   * state in order to support per-step errors.\n   *\n   * We use this so that if the function itself rejects with the same error, we\n   * know that it was entirely uncaught (or at the very least rethrown), so we\n   * should send a `NonRetriableError` to stop needless execution of a function\n   * that will continue to fail.\n   *\n   * TODO This is imperfect, as this state is currently kept around for longer\n   * than it needs to be. It should disappear as soon as we've seen that the\n   * error did not immediately throw. It may need to be refactored to work a\n   * little more smoothly with the core loop.\n   */\n  recentlyRejectedStepError?: StepError;\n}\n\nconst hashId = (id: string): string => {\n  return sha1().update(id).digest(\"hex\");\n};\n\nconst hashOp = (op: OutgoingOp): OutgoingOp => {\n  return {\n    ...op,\n    id: hashId(op.id),\n  };\n};\n\n/**\n * Exported for testing.\n */\nexport const _internals = { hashOp, hashId };\n"],"names":["createV1InngestExecution: InngestExecutionFactory","step","outgoingOp: OutgoingOp","retriable: boolean | string","loop: V1ExecutionState[\"loop\"]","foundStepsToReport: Map<string, FoundStep>","unhandledFoundStepsToReport: Map<string, FoundStep>","expectedNextStepIndexes: Map<string, number>","remainingStepCompletionOrder: string[]","foundStepsReportPromise: Promise<void> | undefined","beforeExecHooksPromise: Promise<void> | undefined","extensionPromise: Promise<void>","stepHandler: StepHandler","extraOpts: Record<string, unknown> | undefined","step: FoundStep"],"mappings":"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","debugId":null}},
    {"offset": {"line": 5571, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/inngest/components/execution/v2.js","sources":["file:///Users/harshitgangwar/Desktop/SkillForge/node_modules/src/components/execution/v2.ts"],"sourcesContent":["import { trace } from \"@opentelemetry/api\";\nimport hashjs from \"hash.js\";\nimport { z } from \"zod/v3\";\nimport { headerKeys, internalEvents } from \"../../helpers/consts.ts\";\nimport {\n  deserializeError,\n  ErrCode,\n  minifyPrettyError,\n  prettyError,\n  serializeError,\n} from \"../../helpers/errors.ts\";\nimport { undefinedToNull } from \"../../helpers/functions.ts\";\nimport {\n  createDeferredPromise,\n  createDeferredPromiseWithStack,\n  createTimeoutPromise,\n  runAsPromise,\n} from \"../../helpers/promises.ts\";\nimport type { MaybePromise, Simplify } from \"../../helpers/types.ts\";\nimport {\n  type BaseContext,\n  type Context,\n  type EventPayload,\n  type FailureEventArgs,\n  type Handler,\n  jsonErrorSchema,\n  type OutgoingOp,\n  StepOpCode,\n} from \"../../types.ts\";\nimport { version } from \"../../version.ts\";\nimport type { Inngest } from \"../Inngest.ts\";\nimport { getHookStack, type RunHookStack } from \"../InngestMiddleware.ts\";\nimport {\n  createStepTools,\n  type FoundStep,\n  getStepOptions,\n  invokePayloadSchema,\n  STEP_INDEXING_SUFFIX,\n  type StepHandler,\n} from \"../InngestStepTools.ts\";\nimport { NonRetriableError } from \"../NonRetriableError.ts\";\nimport { RetryAfterError } from \"../RetryAfterError.ts\";\nimport { StepError } from \"../StepError.ts\";\nimport { getAsyncCtx, getAsyncLocalStorage } from \"./als.ts\";\nimport {\n  type ExecutionResult,\n  type IInngestExecution,\n  InngestExecution,\n  type InngestExecutionFactory,\n  type InngestExecutionOptions,\n  type MemoizedOp,\n} from \"./InngestExecution.ts\";\nimport { clientProcessorMap } from \"./otel/access.ts\";\n\nconst { sha1 } = hashjs;\n\nexport const createV2InngestExecution: InngestExecutionFactory = (options) => {\n  return new V2InngestExecution(options);\n};\n\nclass V2InngestExecution extends InngestExecution implements IInngestExecution {\n  private state: V2ExecutionState;\n  private fnArg: Context.Any;\n  private checkpointHandlers: CheckpointHandlers;\n  private timeoutDuration = 1000 * 10;\n  private execution: Promise<ExecutionResult> | undefined;\n  private userFnToRun: Handler.Any;\n\n  /**\n   * If we're supposed to run a particular step via `requestedRunStep`, this\n   * will be a `Promise` that resolves after no steps have been found for\n   * `timeoutDuration` milliseconds.\n   *\n   * If we're not supposed to run a particular step, this will be `undefined`.\n   */\n  private timeout?: ReturnType<typeof createTimeoutPromise>;\n\n  constructor(options: InngestExecutionOptions) {\n    super(options);\n\n    this.userFnToRun = this.getUserFnToRun();\n    this.state = this.createExecutionState();\n    this.fnArg = this.createFnArg();\n    this.checkpointHandlers = this.createCheckpointHandlers();\n    this.initializeTimer(this.state);\n\n    this.debug(\n      \"created new V2 execution for run;\",\n      this.options.requestedRunStep\n        ? `wanting to run step \"${this.options.requestedRunStep}\"`\n        : \"discovering steps\",\n    );\n\n    this.debug(\"existing state keys:\", Object.keys(this.state.stepState));\n  }\n\n  /**\n   * Idempotently start the execution of the user's function.\n   */\n  public start() {\n    if (!this.execution) {\n      this.debug(\"starting V2 execution\");\n\n      const tracer = trace.getTracer(\"inngest\", version);\n\n      this.execution = getAsyncLocalStorage().then((als) => {\n        return als.run(\n          { app: this.options.client, ctx: this.fnArg },\n          async () => {\n            return tracer.startActiveSpan(\"inngest.execution\", (span) => {\n              clientProcessorMap.get(this.options.client)?.declareStartingSpan({\n                span,\n                runId: this.options.runId,\n                traceparent: this.options.headers[headerKeys.TraceParent],\n                tracestate: this.options.headers[headerKeys.TraceState],\n              });\n\n              return this._start()\n                .then((result) => {\n                  this.debug(\"result:\", result);\n                  return result;\n                })\n                .finally(() => {\n                  span.end();\n                });\n            });\n          },\n        );\n      });\n    }\n\n    return this.execution;\n  }\n\n  /**\n   * Starts execution of the user's function and the core loop.\n   */\n  private async _start(): Promise<ExecutionResult> {\n    try {\n      const allCheckpointHandler = this.getCheckpointHandler(\"\");\n      this.state.hooks = await this.initializeMiddleware();\n      await this.startExecution();\n\n      for await (const checkpoint of this.state.loop) {\n        await allCheckpointHandler(checkpoint);\n\n        const handler = this.getCheckpointHandler(checkpoint.type);\n        const result = await handler(checkpoint);\n\n        if (result) {\n          return result;\n        }\n      }\n    } catch (error) {\n      return await this.transformOutput({ error });\n    } finally {\n      void this.state.loop.return();\n      await this.state.hooks?.beforeResponse?.();\n    }\n\n    /**\n     * If we're here, the generator somehow finished without returning a value.\n     * This should never happen.\n     */\n    throw new Error(\"Core loop finished without returning a value\");\n  }\n\n  /**\n   * Creates a handler for every checkpoint type, defining what to do when we\n   * reach that checkpoint in the core loop.\n   */\n  private createCheckpointHandlers(): CheckpointHandlers {\n    return {\n      /**\n       * Run for all checkpoints. Best used for logging or common actions.\n       * Use other handlers to return values and interrupt the core loop.\n       */\n      \"\": (checkpoint) => {\n        this.debug(\"checkpoint:\", checkpoint);\n      },\n\n      /**\n       * The user's function has completed and returned a value.\n       */\n      \"function-resolved\": async (checkpoint) => {\n        return await this.transformOutput({ data: checkpoint.data });\n      },\n\n      /**\n       * The user's function has thrown an error.\n       */\n      \"function-rejected\": async (checkpoint) => {\n        return await this.transformOutput({ error: checkpoint.error });\n      },\n\n      /**\n       * We've found one or more steps. Here we may want to run a step or report\n       * them back to Inngest.\n       */\n      \"steps-found\": async ({ steps }) => {\n        const stepResult = await this.tryExecuteStep(steps);\n        if (stepResult) {\n          const transformResult = await this.transformOutput(stepResult);\n\n          /**\n           * Transforming output will always return either function rejection or\n           * resolution. In most cases, this can be immediately returned, but in\n           * this particular case we want to handle it differently.\n           */\n          if (transformResult.type === \"function-resolved\") {\n            return {\n              type: \"step-ran\",\n              ctx: transformResult.ctx,\n              ops: transformResult.ops,\n              step: _internals.hashOp({\n                ...stepResult,\n                data: transformResult.data,\n              }),\n            };\n          } else if (transformResult.type === \"function-rejected\") {\n            return {\n              type: \"step-ran\",\n              ctx: transformResult.ctx,\n              ops: transformResult.ops,\n              step: _internals.hashOp({\n                ...stepResult,\n                error: transformResult.error,\n              }),\n              retriable: transformResult.retriable,\n            };\n          }\n\n          return transformResult;\n        }\n\n        const newSteps = await this.filterNewSteps(\n          Array.from(this.state.steps.values()),\n        );\n        if (newSteps) {\n          return {\n            type: \"steps-found\",\n            ctx: this.fnArg,\n            ops: this.ops,\n            steps: newSteps,\n          };\n        }\n\n        return;\n      },\n\n      /**\n       * While trying to find a step that Inngest has told us to run, we've\n       * timed out or have otherwise decided that it doesn't exist.\n       */\n      \"step-not-found\": ({ step }) => {\n        return { type: \"step-not-found\", ctx: this.fnArg, ops: this.ops, step };\n      },\n    };\n  }\n\n  private getCheckpointHandler(type: keyof CheckpointHandlers) {\n    return this.checkpointHandlers[type] as (\n      checkpoint: Checkpoint,\n    ) => MaybePromise<ExecutionResult | undefined>;\n  }\n\n  private async tryExecuteStep(\n    steps: FoundStep[],\n  ): Promise<OutgoingOp | undefined> {\n    const hashedStepIdToRun =\n      this.options.requestedRunStep || this.getEarlyExecRunStep(steps);\n    if (!hashedStepIdToRun) {\n      return;\n    }\n\n    const step = steps.find(\n      (step) => step.hashedId === hashedStepIdToRun && step.fn,\n    );\n\n    if (step) {\n      return await this.executeStep(step);\n    }\n\n    /**\n     * Ensure we reset the timeout if we have a requested run step but couldn't\n     * find it, but also that we don't reset if we found and executed it.\n     */\n    return void this.timeout?.reset();\n  }\n\n  /**\n   * Given a list of outgoing ops, decide if we can execute an op early and\n   * return the ID of the step to execute if we can.\n   */\n  private getEarlyExecRunStep(steps: FoundStep[]): string | undefined {\n    /**\n     * We may have been disabled due to parallelism, in which case we can't\n     * immediately execute unless explicitly requested.\n     */\n    if (this.options.disableImmediateExecution) return;\n\n    const unfulfilledSteps = steps.filter((step) => !step.fulfilled);\n    if (unfulfilledSteps.length !== 1) return;\n\n    const op = unfulfilledSteps[0];\n\n    if (\n      op &&\n      op.op === StepOpCode.StepPlanned\n      // TODO We must individually check properties here that we do not want to\n      // execute on, such as retry counts. Nothing exists here that falls in to\n      // this case, but should be accounted for when we add them.\n      // && typeof op.opts === \"undefined\"\n    ) {\n      return op.hashedId;\n    }\n\n    return;\n  }\n\n  private async filterNewSteps(\n    foundSteps: FoundStep[],\n  ): Promise<[OutgoingOp, ...OutgoingOp[]] | undefined> {\n    if (this.options.requestedRunStep) {\n      return;\n    }\n\n    /**\n     * Gather any steps that aren't memoized and report them.\n     */\n    const newSteps = foundSteps.filter((step) => !step.fulfilled);\n\n    if (!newSteps.length) {\n      return;\n    }\n\n    /**\n     * Warn if we've found new steps but haven't yet seen all previous\n     * steps. This may indicate that step presence isn't determinate.\n     */\n    let knownSteps = 0;\n    for (const step of foundSteps) {\n      if (step.fulfilled) {\n        knownSteps++;\n      }\n    }\n    const foundAllCompletedSteps = this.state.stepsToFulfill === knownSteps;\n\n    if (!foundAllCompletedSteps) {\n      // TODO Tag\n      console.warn(\n        prettyError({\n          type: \"warn\",\n          whatHappened: \"Function may be indeterminate\",\n          why: \"We found new steps before seeing all previous steps, which may indicate that the function is non-deterministic.\",\n          consequences:\n            \"This may cause unexpected behaviour as Inngest executes your function.\",\n          reassurance:\n            \"This is expected if a function is updated in the middle of a run, but may indicate a bug if not.\",\n        }),\n      );\n    }\n\n    /**\n     * We're finishing up; let's trigger the last of the hooks.\n     */\n    await this.state.hooks?.afterMemoization?.();\n    await this.state.hooks?.beforeExecution?.();\n    await this.state.hooks?.afterExecution?.();\n\n    const stepList = newSteps.map<OutgoingOp>((step) => ({\n      displayName: step.displayName,\n      op: step.op,\n      id: step.hashedId,\n      name: step.name,\n      opts: step.opts,\n    })) as [OutgoingOp, ...OutgoingOp[]];\n\n    /**\n     * We also run `onSendEvent` middleware hooks against `step.invoke()` steps\n     * to ensure that their `data` is transformed correctly.\n     */\n    return await this.transformNewSteps(stepList);\n  }\n\n  /**\n   * Using middleware, transform any newly-found steps before returning them to\n   * an Inngest Server.\n   */\n  private async transformNewSteps<T extends [OutgoingOp, ...OutgoingOp[]]>(\n    steps: T,\n  ): Promise<T> {\n    return Promise.all(\n      steps.map(async (step) => {\n        if (step.op !== StepOpCode.InvokeFunction) {\n          return step;\n        }\n\n        const onSendEventHooks = await getHookStack(\n          this.options.fn[\"middleware\"],\n          \"onSendEvent\",\n          undefined,\n          {\n            transformInput: (prev, output) => {\n              return { ...prev, ...output };\n            },\n            transformOutput: (prev, output) => {\n              return {\n                result: { ...prev.result, ...output?.result },\n              };\n            },\n          },\n        );\n\n        /**\n         * For each event being sent, create a new `onSendEvent` hook stack to\n         * process it. We do this as middleware hooks are intended to run once\n         * during each lifecycle (onFunctionRun or onSendEvent) and here, a hook\n         * is run for every single event.\n         *\n         * This is done because a developer can use this hook to filter out\n         * events entirely; if we batch all of the events together, we can't\n         * tell which ones were filtered out if we're processing >1 invocation\n         * here.\n         */\n        const transformedPayload = await onSendEventHooks.transformInput?.({\n          payloads: [\n            {\n              ...(step.opts?.payload ?? {}),\n              name: internalEvents.FunctionInvoked,\n            },\n          ],\n        });\n\n        const newPayload = invokePayloadSchema.parse(\n          transformedPayload?.payloads?.[0] ?? {},\n        );\n\n        return {\n          ...step,\n          opts: {\n            ...step.opts,\n            payload: {\n              ...(step.opts?.payload ?? {}),\n              ...newPayload,\n            },\n          },\n        };\n      }),\n    ) as Promise<T>;\n  }\n\n  private async executeStep({\n    id,\n    name,\n    opts,\n    fn,\n    displayName,\n  }: FoundStep): Promise<OutgoingOp> {\n    this.timeout?.clear();\n    await this.state.hooks?.afterMemoization?.();\n    await this.state.hooks?.beforeExecution?.();\n\n    const outgoingOp: OutgoingOp = {\n      id,\n      op: StepOpCode.StepRun,\n      name,\n      opts,\n      displayName,\n    };\n    this.state.executingStep = outgoingOp;\n\n    const store = await getAsyncCtx();\n\n    if (store) {\n      store.executingStep = {\n        id,\n        name: displayName,\n      };\n    }\n\n    this.debug(`executing step \"${id}\"`);\n\n    return runAsPromise(fn)\n      .finally(async () => {\n        if (store) {\n          delete store.executingStep;\n        }\n\n        await this.state.hooks?.afterExecution?.();\n      })\n      .then<OutgoingOp>((data) => {\n        return {\n          ...outgoingOp,\n          data,\n        };\n      })\n      .catch<OutgoingOp>((error) => {\n        return {\n          ...outgoingOp,\n          op: StepOpCode.StepError,\n\n          error,\n        };\n      });\n  }\n\n  /**\n   * Starts execution of the user's function, including triggering checkpoints\n   * and middleware hooks where appropriate.\n   */\n  private async startExecution(): Promise<void> {\n    /**\n     * Mutate input as neccessary based on middleware.\n     */\n    await this.transformInput();\n\n    /**\n     * Start the timer to time out the run if needed.\n     */\n    void this.timeout?.start();\n\n    await this.state.hooks?.beforeMemoization?.();\n\n    /**\n     * If we had no state to begin with, immediately end the memoization phase.\n     */\n    if (this.state.allStateUsed()) {\n      await this.state.hooks?.afterMemoization?.();\n      await this.state.hooks?.beforeExecution?.();\n    }\n\n    /**\n     * Trigger the user's function.\n     */\n    runAsPromise(() => this.userFnToRun(this.fnArg))\n      .finally(async () => {\n        await this.state.hooks?.afterMemoization?.();\n        await this.state.hooks?.beforeExecution?.();\n        await this.state.hooks?.afterExecution?.();\n      })\n      .then((data) => {\n        this.state.setCheckpoint({ type: \"function-resolved\", data });\n      })\n      .catch((error) => {\n        this.state.setCheckpoint({ type: \"function-rejected\", error });\n      });\n  }\n\n  /**\n   * Using middleware, transform input before running.\n   */\n  private async transformInput() {\n    const inputMutations = await this.state.hooks?.transformInput?.({\n      ctx: { ...this.fnArg },\n      steps: Object.values(this.state.stepState),\n      fn: this.options.fn,\n      reqArgs: this.options.reqArgs,\n    });\n\n    if (inputMutations?.ctx) {\n      this.fnArg = inputMutations.ctx;\n    }\n\n    if (inputMutations?.steps) {\n      this.state.stepState = Object.fromEntries(\n        inputMutations.steps.map((step) => [step.id, step]),\n      );\n    }\n  }\n\n  /**\n   * Using middleware, transform output before returning.\n   */\n  private async transformOutput(\n    dataOrError: Parameters<\n      NonNullable<RunHookStack[\"transformOutput\"]>\n    >[0][\"result\"],\n  ): Promise<ExecutionResult> {\n    const output = { ...dataOrError };\n\n    /**\n     * If we've been given an error and it's one that we just threw from a step,\n     * we should return a `NonRetriableError` to stop execution.\n     */\n    if (typeof output.error !== \"undefined\") {\n      output.data = serializeError(output.error);\n    }\n\n    const isStepExecution = Boolean(this.state.executingStep);\n\n    const transformedOutput = await this.state.hooks?.transformOutput?.({\n      result: { ...output },\n      step: this.state.executingStep,\n    });\n\n    const { data, error } = { ...output, ...transformedOutput?.result };\n\n    if (!isStepExecution) {\n      await this.state.hooks?.finished?.({\n        result: { ...(typeof error !== \"undefined\" ? { error } : { data }) },\n      });\n    }\n\n    if (typeof error !== \"undefined\") {\n      /**\n       * Ensure we give middleware the chance to decide on retriable behaviour\n       * by looking at the error returned from output transformation.\n       */\n      let retriable: boolean | string = !(\n        error instanceof NonRetriableError || error instanceof StepError\n      );\n      if (retriable && error instanceof RetryAfterError) {\n        retriable = error.retryAfter;\n      }\n\n      const serializedError = minifyPrettyError(serializeError(error));\n\n      return {\n        type: \"function-rejected\",\n        ctx: this.fnArg,\n        ops: this.ops,\n        error: serializedError,\n        retriable,\n      };\n    }\n\n    return {\n      type: \"function-resolved\",\n      ctx: this.fnArg,\n      ops: this.ops,\n      data: undefinedToNull(data),\n    };\n  }\n\n  private createExecutionState(): V2ExecutionState {\n    const d = createDeferredPromiseWithStack<Checkpoint>();\n    let checkpointResolve = d.deferred.resolve;\n    const checkpointResults = d.results;\n\n    const loop: V2ExecutionState[\"loop\"] = (async function* (\n      cleanUp?: () => void,\n    ) {\n      try {\n        while (true) {\n          const res = (await checkpointResults.next()).value;\n          if (res) {\n            yield res;\n          }\n        }\n      } finally {\n        cleanUp?.();\n      }\n    })(() => {\n      this.timeout?.clear();\n      void checkpointResults.return();\n    });\n\n    const stepsToFulfill = Object.keys(this.options.stepState).length;\n\n    const state: V2ExecutionState = {\n      stepState: this.options.stepState,\n      stepsToFulfill,\n      steps: new Map(),\n      loop,\n      hasSteps: Boolean(stepsToFulfill),\n      stepCompletionOrder: [...this.options.stepCompletionOrder],\n      remainingStepsToBeSeen: new Set(this.options.stepCompletionOrder),\n      setCheckpoint: (checkpoint: Checkpoint) => {\n        ({ resolve: checkpointResolve } = checkpointResolve(checkpoint));\n      },\n      allStateUsed: () => {\n        return this.state.remainingStepsToBeSeen.size === 0;\n      },\n    };\n\n    return state;\n  }\n\n  get ops(): Record<string, MemoizedOp> {\n    return Object.fromEntries(this.state.steps);\n  }\n\n  private createFnArg(): Context.Any {\n    const step = this.createStepTools();\n\n    let fnArg = {\n      ...(this.options.data as { event: EventPayload }),\n      step,\n    } as Context.Any;\n\n    /**\n     * Handle use of the `onFailure` option by deserializing the error.\n     */\n    if (this.options.isFailureHandler) {\n      const eventData = z\n        .object({ error: jsonErrorSchema })\n        .parse(fnArg.event?.data);\n\n      (fnArg as Partial<Pick<FailureEventArgs, \"error\">>) = {\n        ...fnArg,\n        error: deserializeError(eventData.error),\n      };\n    }\n\n    return this.options.transformCtx?.(fnArg) ?? fnArg;\n  }\n\n  private createStepTools(): ReturnType<typeof createStepTools> {\n    /**\n     * A list of steps that have been found and are being rolled up before being\n     * reported to the core loop.\n     */\n    const foundStepsToReport: Map<string, FoundStep> = new Map();\n\n    /**\n     * A map of the subset of found steps to report that have not yet been\n     * handled. Used for fast access to steps that need to be handled in order.\n     */\n    const unhandledFoundStepsToReport: Map<string, FoundStep> = new Map();\n\n    /**\n     * A map of the latest sequential step indexes found for each step ID. Used\n     * to ensure that we don't index steps in parallel.\n     *\n     * Note that these must be sequential; if we've seen or assigned `a:1`,\n     * `a:2` and `a:4`, the latest sequential step index is `2`.\n     *\n     */\n    const expectedNextStepIndexes: Map<string, number> = new Map();\n\n    /**\n     * A promise that's used to ensure that step reporting cannot be run more than\n     * once in a given asynchronous time span.\n     */\n    let foundStepsReportPromise: Promise<void> | undefined;\n\n    /**\n     * A promise that's used to represent middleware hooks running before\n     * execution.\n     */\n    let beforeExecHooksPromise: Promise<void> | undefined;\n\n    /**\n     * A helper used to report steps to the core loop. Used after adding an item\n     * to `foundStepsToReport`.\n     */\n    const reportNextTick = () => {\n      // Being explicit instead of using `??=` to appease TypeScript.\n      if (foundStepsReportPromise) {\n        return;\n      }\n\n      foundStepsReportPromise = new Promise((resolve) => setImmediate(resolve))\n        /**\n         * Ensure that we wait for this promise to resolve before continuing.\n         *\n         * The groups in which steps are reported can affect how we detect some\n         * more complex determinism issues like parallel indexing. This promise\n         * can represent middleware hooks being run early, in the middle of\n         * ingesting steps to report.\n         *\n         * Because of this, it's important we wait for this middleware to resolve\n         * before continuing to report steps to ensure that all steps have a\n         * chance to be reported throughout this asynchronous action.\n         */\n        .then(() => beforeExecHooksPromise)\n        .then(() => {\n          foundStepsReportPromise = undefined;\n\n          for (const [hashedId, step] of unhandledFoundStepsToReport) {\n            if (step.handle()) {\n              unhandledFoundStepsToReport.delete(hashedId);\n              if (step.fulfilled) {\n                foundStepsToReport.delete(step.id);\n              }\n            }\n          }\n\n          if (foundStepsToReport.size) {\n            const steps = [...foundStepsToReport.values()] as [\n              FoundStep,\n              ...FoundStep[],\n            ];\n\n            foundStepsToReport.clear();\n\n            return void this.state.setCheckpoint({\n              type: \"steps-found\",\n              steps: steps,\n            });\n          }\n        });\n    };\n\n    /**\n     * A helper used to push a step to the list of steps to report.\n     */\n    const pushStepToReport = (step: FoundStep) => {\n      foundStepsToReport.set(step.id, step);\n      unhandledFoundStepsToReport.set(step.hashedId, step);\n      reportNextTick();\n    };\n\n    const stepHandler: StepHandler = async ({\n      args,\n      matchOp,\n      opts,\n    }): Promise<unknown> => {\n      await beforeExecHooksPromise;\n\n      const stepOptions = getStepOptions(args[0]);\n      const opId = matchOp(stepOptions, ...args.slice(1));\n\n      if (this.state.executingStep) {\n        /**\n         * If a step is found after asynchronous actions during another step's\n         * execution, everything is fine. The problem here is if we've found\n         * that a step nested inside another a step, which is something we don't\n         * support at the time of writing.\n         *\n         * In this case, we could use something like Async Hooks to understand\n         * how the step is being triggered, though this isn't available in all\n         * environments.\n         *\n         * Therefore, we'll only show a warning here to indicate that this is\n         * potentially an issue.\n         */\n        console.warn(\n          prettyError({\n            whatHappened: `We detected that you have nested \\`step.*\\` tooling in \\`${\n              opId.displayName ?? opId.id\n            }\\``,\n            consequences: \"Nesting `step.*` tooling is not supported.\",\n            type: \"warn\",\n            reassurance:\n              \"It's possible to see this warning if steps are separated by regular asynchronous calls, which is fine.\",\n            stack: true,\n            toFixNow:\n              \"Make sure you're not using `step.*` tooling inside of other `step.*` tooling. If you need to compose steps together, you can create a new async function and call it from within your step function, or use promise chaining.\",\n            code: ErrCode.NESTING_STEPS,\n          }),\n        );\n      }\n\n      if (this.state.steps.has(opId.id)) {\n        const originalId = opId.id;\n\n        const expectedNextIndex = expectedNextStepIndexes.get(originalId) ?? 1;\n        for (let i = expectedNextIndex; ; i++) {\n          const newId = originalId + STEP_INDEXING_SUFFIX + i;\n\n          if (!this.state.steps.has(newId)) {\n            expectedNextStepIndexes.set(originalId, i + 1);\n            opId.id = newId;\n            break;\n          }\n        }\n      }\n\n      const { promise, resolve, reject } = createDeferredPromise();\n      const hashedId = _internals.hashId(opId.id);\n      const stepState = this.state.stepState[hashedId];\n      let isFulfilled = false;\n      if (stepState) {\n        stepState.seen = true;\n        this.state.remainingStepsToBeSeen.delete(hashedId);\n\n        if (typeof stepState.input === \"undefined\") {\n          isFulfilled = true;\n        }\n      }\n\n      let extraOpts: Record<string, unknown> | undefined;\n      let fnArgs = [...args];\n\n      if (\n        typeof stepState?.input !== \"undefined\" &&\n        Array.isArray(stepState.input)\n      ) {\n        switch (opId.op) {\n          // `step.run()` has its function input affected\n          case StepOpCode.StepPlanned: {\n            fnArgs = [...args.slice(0, 2), ...stepState.input];\n\n            extraOpts = { input: [...stepState.input] };\n            break;\n          }\n\n          // `step.ai.infer()` has its body affected\n          case StepOpCode.AiGateway: {\n            extraOpts = {\n              body: {\n                ...(typeof opId.opts?.body === \"object\"\n                  ? { ...opId.opts.body }\n                  : {}),\n                ...stepState.input[0],\n              },\n            };\n            break;\n          }\n        }\n      }\n\n      const step: FoundStep = {\n        ...opId,\n        opts: { ...opId.opts, ...extraOpts },\n        rawArgs: fnArgs, // TODO What is the right value here? Should this be raw args without affected input?\n        hashedId,\n        input: stepState?.input,\n\n        fn: opts?.fn ? () => opts.fn?.(...fnArgs) : undefined,\n        promise,\n        fulfilled: isFulfilled,\n        hasStepState: Boolean(stepState),\n        displayName: opId.displayName ?? opId.id,\n        handled: false,\n        handle: () => {\n          if (step.handled) {\n            return false;\n          }\n\n          step.handled = true;\n\n          if (isFulfilled && stepState) {\n            stepState.fulfilled = true;\n\n            // For some execution scenarios such as testing, `data`, `error`,\n            // and `input` may be `Promises`. This could also be the case for\n            // future middleware applications. For this reason, we'll make sure\n            // the values are fully resolved before continuing.\n            void Promise.all([\n              stepState.data,\n              stepState.error,\n              stepState.input,\n            ]).then(() => {\n              if (typeof stepState.data !== \"undefined\") {\n                resolve(stepState.data);\n              } else {\n                this.state.recentlyRejectedStepError = new StepError(\n                  opId.id,\n                  stepState.error,\n                );\n\n                reject(this.state.recentlyRejectedStepError);\n              }\n            });\n          }\n\n          return true;\n        },\n      };\n\n      this.state.steps.set(opId.id, step);\n      this.state.hasSteps = true;\n      pushStepToReport(step);\n\n      /**\n       * If this is the last piece of state we had, we've now finished\n       * memoizing.\n       */\n      if (!beforeExecHooksPromise && this.state.allStateUsed()) {\n        // biome-ignore lint/suspicious/noAssignInExpressions: <explanation>\n        await (beforeExecHooksPromise = (async () => {\n          await this.state.hooks?.afterMemoization?.();\n          await this.state.hooks?.beforeExecution?.();\n        })());\n      }\n\n      return promise;\n    };\n\n    return createStepTools(this.options.client, this, stepHandler);\n  }\n\n  private getUserFnToRun(): Handler.Any {\n    if (!this.options.isFailureHandler) {\n      return this.options.fn[\"fn\"];\n    }\n\n    if (!this.options.fn[\"onFailureFn\"]) {\n      /**\n       * Somehow, we've ended up detecting that this is a failure handler but\n       * doesn't have an `onFailure` function. This should never happen.\n       */\n      throw new Error(\"Cannot find function `onFailure` handler\");\n    }\n\n    return this.options.fn[\"onFailureFn\"];\n  }\n\n  private initializeTimer(state: V2ExecutionState): void {\n    if (!this.options.requestedRunStep) {\n      return;\n    }\n\n    this.timeout = createTimeoutPromise(this.timeoutDuration);\n\n    void this.timeout.then(async () => {\n      await this.state.hooks?.afterMemoization?.();\n      await this.state.hooks?.beforeExecution?.();\n      await this.state.hooks?.afterExecution?.();\n\n      state.setCheckpoint({\n        type: \"step-not-found\",\n        step: {\n          id: this.options.requestedRunStep as string,\n          op: StepOpCode.StepNotFound,\n        },\n      });\n    });\n  }\n\n  private async initializeMiddleware(): Promise<RunHookStack> {\n    const ctx = this.options.data as Pick<\n      Readonly<BaseContext<Inngest.Any>>,\n      \"event\" | \"events\" | \"runId\"\n    >;\n\n    const hooks = await getHookStack(\n      this.options.fn[\"middleware\"],\n      \"onFunctionRun\",\n      {\n        ctx,\n        fn: this.options.fn,\n        steps: Object.values(this.options.stepState),\n        reqArgs: this.options.reqArgs,\n      },\n      {\n        transformInput: (prev, output) => {\n          return {\n            ctx: { ...prev.ctx, ...output?.ctx },\n            fn: this.options.fn,\n            steps: prev.steps.map((step, i) => ({\n              ...step,\n              ...output?.steps?.[i],\n            })),\n            reqArgs: prev.reqArgs,\n          };\n        },\n        transformOutput: (prev, output) => {\n          return {\n            result: { ...prev.result, ...output?.result },\n            step: prev.step,\n          };\n        },\n      },\n    );\n\n    return hooks;\n  }\n}\n\n/**\n * Types of checkpoints that can be reached during execution.\n */\nexport interface Checkpoints {\n  \"steps-found\": { steps: [FoundStep, ...FoundStep[]] };\n  \"function-rejected\": { error: unknown };\n  \"function-resolved\": { data: unknown };\n  \"step-not-found\": { step: OutgoingOp };\n}\n\ntype Checkpoint = {\n  [K in keyof Checkpoints]: Simplify<{ type: K } & Checkpoints[K]>;\n}[keyof Checkpoints];\n\ntype CheckpointHandlers = {\n  [C in Checkpoint as C[\"type\"]]: (\n    checkpoint: C,\n  ) => MaybePromise<ExecutionResult | undefined>;\n} & {\n  \"\": (checkpoint: Checkpoint) => MaybePromise<void>;\n};\n\nexport interface V2ExecutionState {\n  /**\n   * A value that indicates that we're executing this step. Can be used to\n   * ensure steps are not accidentally nested until we support this across all\n   * platforms.\n   */\n  executingStep?: Readonly<Omit<OutgoingOp, \"id\">>;\n\n  /**\n   * A map of step IDs to their data, used to fill previously-completed steps\n   * with state from the executor.\n   */\n  stepState: Record<string, MemoizedOp>;\n\n  /**\n   * The number of steps we expect to fulfil based on the state passed from the\n   * Executor.\n   */\n  stepsToFulfill: number;\n\n  /**\n   * A map of step IDs to their functions to run. The executor can request a\n   * specific step to run, so we need to store the function to run here.\n   */\n  steps: Map<string, FoundStep>;\n\n  /**\n   * A flag which represents whether or not steps are understood to be used in\n   * this function. This is used to determine whether or not we should run\n   * some steps (such as `step.sendEvent`) inline as they are found.\n   */\n  hasSteps: boolean;\n\n  /**\n   * The core loop - a generator used to take an action upon finding the next\n   * checkpoint. Manages the flow of execution and cleaning up after itself.\n   */\n  loop: AsyncGenerator<Checkpoint, void, void>;\n\n  /**\n   * A function that resolves the `Promise` returned by `waitForNextDecision`.\n   */\n  setCheckpoint: (data: Checkpoint) => void;\n\n  /**\n   * Initialized middleware hooks for this execution.\n   *\n   * Middleware hooks are cached to ensure they can only be run once, which\n   * means that these hooks can be called in many different places to ensure we\n   * handle all possible execution paths.\n   */\n  hooks?: RunHookStack;\n\n  /**\n   * Returns whether or not all state passed from the executor has been used to\n   * fulfill found steps.\n   */\n  allStateUsed: () => boolean;\n\n  /**\n   * An ordered list of step IDs that represents the order in which their\n   * execution was completed.\n   */\n  stepCompletionOrder: string[];\n\n  /**\n   * An set of step IDs that have yet to be seen in this execution. Used to\n   * decide when to trigger middleware based on the current state.\n   */\n  remainingStepsToBeSeen: Set<string>;\n\n  /**\n   * If defined, this is the error that purposefully thrown when memoizing step\n   * state in order to support per-step errors.\n   *\n   * We use this so that if the function itself rejects with the same error, we\n   * know that it was entirely uncaught (or at the very least rethrown), so we\n   * should send a `NonRetriableError` to stop needless execution of a function\n   * that will continue to fail.\n   *\n   * TODO This is imperfect, as this state is currently kept around for longer\n   * than it needs to be. It should disappear as soon as we've seen that the\n   * error did not immediately throw. It may need to be refactored to work a\n   * little more smoothly with the core loop.\n   */\n  recentlyRejectedStepError?: StepError;\n}\n\nconst hashId = (id: string): string => {\n  return sha1().update(id).digest(\"hex\");\n};\n\nconst hashOp = (op: OutgoingOp): OutgoingOp => {\n  return {\n    ...op,\n    id: hashId(op.id),\n  };\n};\n\n/**\n * Exported for testing.\n */\nexport const _internals = { hashOp, hashId };\n"],"names":["createV2InngestExecution: InngestExecutionFactory","step","outgoingOp: OutgoingOp","retriable: boolean | string","loop: V2ExecutionState[\"loop\"]","foundStepsToReport: Map<string, FoundStep>","unhandledFoundStepsToReport: Map<string, FoundStep>","expectedNextStepIndexes: Map<string, number>","foundStepsReportPromise: Promise<void> | undefined","beforeExecHooksPromise: Promise<void> | undefined","stepHandler: StepHandler","extraOpts: Record<string, unknown> | undefined","step: FoundStep"],"mappings":"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","debugId":null}},
    {"offset": {"line": 6330, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/inngest/components/InngestFunction.js","sources":["file:///Users/harshitgangwar/Desktop/SkillForge/node_modules/src/components/InngestFunction.ts"],"sourcesContent":["import {\n  ExecutionVersion,\n  internalEvents,\n  queryKeys,\n} from \"../helpers/consts.ts\";\nimport { timeStr } from \"../helpers/strings.ts\";\nimport type { RecursiveTuple, StrictUnion } from \"../helpers/types.ts\";\nimport type {\n  Cancellation,\n  ConcurrencyOption,\n  FunctionConfig,\n  Handler,\n  TimeStr,\n  TimeStrBatch,\n  TriggersFromClient,\n} from \"../types.ts\";\nimport type {\n  IInngestExecution,\n  InngestExecutionOptions,\n} from \"./execution/InngestExecution.ts\";\nimport { createV0InngestExecution } from \"./execution/v0.ts\";\nimport { createV1InngestExecution } from \"./execution/v1.ts\";\nimport { createV2InngestExecution } from \"./execution/v2.ts\";\nimport type { GetEvents, Inngest } from \"./Inngest.ts\";\nimport type {\n  InngestMiddleware,\n  MiddlewareRegisterReturn,\n} from \"./InngestMiddleware.ts\";\n\n/**\n * A stateless Inngest function, wrapping up function configuration and any\n * in-memory steps to run when triggered.\n *\n * This function can be \"registered\" to create a handler that Inngest can\n * trigger remotely.\n *\n * @public\n */\nexport class InngestFunction<\n  TFnOpts extends InngestFunction.Options<\n    TClient,\n    TMiddleware,\n    TTriggers,\n    TFailureHandler\n  >,\n  THandler extends Handler.Any,\n  TFailureHandler extends Handler.Any,\n  TClient extends Inngest.Any = Inngest.Any,\n  TMiddleware extends InngestMiddleware.Stack = InngestMiddleware.Stack,\n  TTriggers extends InngestFunction.Trigger<\n    TriggersFromClient<TClient>\n  >[] = InngestFunction.Trigger<TriggersFromClient<TClient>>[],\n> implements InngestFunction.Like\n{\n  static stepId = \"step\";\n  static failureSuffix = \"-failure\";\n\n  get [Symbol.toStringTag](): typeof InngestFunction.Tag {\n    return InngestFunction.Tag;\n  }\n\n  public readonly opts: TFnOpts;\n  // biome-ignore lint/correctness/noUnusedPrivateClassMembers: used internally\n  private readonly fn: THandler;\n  private readonly onFailureFn?: TFailureHandler;\n  protected readonly client: TClient;\n  private readonly middleware: Promise<MiddlewareRegisterReturn[]>;\n\n  /**\n   * A stateless Inngest function, wrapping up function configuration and any\n   * in-memory steps to run when triggered.\n   *\n   * This function can be \"registered\" to create a handler that Inngest can\n   * trigger remotely.\n   */\n  constructor(\n    client: TClient,\n\n    /**\n     * Options\n     */\n    opts: TFnOpts,\n    fn: THandler,\n  ) {\n    this.client = client;\n    this.opts = opts;\n    this.fn = fn;\n    this.onFailureFn = this.opts.onFailure;\n\n    this.middleware = this.client[\"initializeMiddleware\"](\n      this.opts.middleware,\n      { registerInput: { fn: this }, prefixStack: this.client[\"middleware\"] },\n    );\n  }\n\n  /**\n   * The generated or given ID for this function.\n   */\n  public id(prefix?: string): string {\n    return [prefix, this.opts.id].filter(Boolean).join(\"-\");\n  }\n\n  /**\n   * The generated or given ID for this function, prefixed with the app ID. This\n   * is used for routing invokes and identifying the function across apps.\n   */\n  protected get absoluteId(): string {\n    return this.id(this.client.id);\n  }\n\n  /**\n   * The name of this function as it will appear in the Inngest Cloud UI.\n   */\n  public get name(): string {\n    return this.opts.name || this.id();\n  }\n\n  /**\n   * The description of this function.\n   */\n  public get description(): string | undefined {\n    return this.opts.description;\n  }\n\n  /**\n   * Retrieve the Inngest config for this function.\n   */\n\n  // biome-ignore lint/correctness/noUnusedPrivateClassMembers: used within the SDK\n  private getConfig({\n    baseUrl,\n    appPrefix,\n    isConnect,\n  }: {\n    /**\n     * Must be provided a URL that will be used to access the function and step.\n     * This function can't be expected to know how it will be accessed, so\n     * relies on an outside method providing context.\n     */\n    baseUrl: URL;\n\n    /**\n     * The prefix for the app that this function is part of.\n     */\n    appPrefix: string;\n\n    /**\n     * Whether this function is being used in a Connect handler.\n     */\n    isConnect?: boolean;\n  }): FunctionConfig[] {\n    const fnId = this.id(appPrefix);\n    const stepUrl = new URL(baseUrl.href);\n    stepUrl.searchParams.set(queryKeys.FnId, fnId);\n    stepUrl.searchParams.set(queryKeys.StepId, InngestFunction.stepId);\n\n    const {\n      retries: attempts,\n      cancelOn,\n      idempotency,\n      batchEvents,\n      rateLimit,\n      throttle,\n      concurrency,\n      debounce,\n      timeouts,\n      priority,\n      singleton,\n    } = this.opts;\n\n    /**\n     * Convert retries into the format required when defining function\n     * configuration.\n     */\n    const retries = typeof attempts === \"undefined\" ? undefined : { attempts };\n\n    const fn: FunctionConfig = {\n      id: fnId,\n      name: this.name,\n      triggers: (this.opts.triggers ?? []).map((trigger) => {\n        if (\"event\" in trigger) {\n          return {\n            event: trigger.event as string,\n            expression: trigger.if,\n          };\n        }\n\n        return {\n          cron: trigger.cron,\n        };\n      }),\n      steps: {\n        [InngestFunction.stepId]: {\n          id: InngestFunction.stepId,\n          name: InngestFunction.stepId,\n          runtime: {\n            type: isConnect ? \"ws\" : \"http\",\n            url: stepUrl.href,\n          },\n          retries,\n        },\n      },\n      idempotency,\n      batchEvents,\n      rateLimit,\n      throttle,\n      concurrency,\n      debounce,\n      priority,\n      timeouts,\n      singleton,\n    };\n\n    if (cancelOn) {\n      fn.cancel = cancelOn.map(({ event, timeout, if: ifStr, match }) => {\n        const ret: NonNullable<FunctionConfig[\"cancel\"]>[number] = {\n          event,\n        };\n\n        if (timeout) {\n          ret.timeout = timeStr(timeout);\n        }\n\n        if (match) {\n          ret.if = `event.${match} == async.${match}`;\n        } else if (ifStr) {\n          ret.if = ifStr;\n        }\n\n        return ret;\n      }, []);\n    }\n\n    const config: FunctionConfig[] = [fn];\n\n    if (this.onFailureFn) {\n      const id = `${fn.id}${InngestFunction.failureSuffix}`;\n      const name = `${fn.name ?? fn.id} (failure)`;\n\n      const failureStepUrl = new URL(stepUrl.href);\n      failureStepUrl.searchParams.set(queryKeys.FnId, id);\n\n      config.push({\n        id,\n        name,\n        triggers: [\n          {\n            event: internalEvents.FunctionFailed,\n            expression: `event.data.function_id == '${fnId}'`,\n          },\n        ],\n        steps: {\n          [InngestFunction.stepId]: {\n            id: InngestFunction.stepId,\n            name: InngestFunction.stepId,\n            runtime: {\n              type: \"http\",\n              url: failureStepUrl.href,\n            },\n            retries: { attempts: 1 },\n          },\n        },\n      });\n    }\n\n    return config;\n  }\n\n  protected createExecution(opts: CreateExecutionOptions): IInngestExecution {\n    const options: InngestExecutionOptions = {\n      fn: this,\n      ...opts.partialOptions,\n    };\n\n    const versionHandlers = {\n      [ExecutionVersion.V2]: () => createV2InngestExecution(options),\n      [ExecutionVersion.V1]: () => createV1InngestExecution(options),\n      [ExecutionVersion.V0]: () => createV0InngestExecution(options),\n    } satisfies Record<ExecutionVersion, () => IInngestExecution>;\n\n    return versionHandlers[opts.version]();\n  }\n\n  // biome-ignore lint/correctness/noUnusedPrivateClassMembers: used within the SDK\n  private shouldOptimizeParallelism(): boolean {\n    // TODO We should check the commhandler's client instead of this one?\n    return (\n      this.opts.optimizeParallelism ??\n      this.client[\"options\"].optimizeParallelism ??\n      false\n    );\n  }\n}\n\n/**\n * A stateless Inngest function, wrapping up function configuration and any\n * in-memory steps to run when triggered.\n *\n * This function can be \"registered\" to create a handler that Inngest can\n * trigger remotely.\n *\n * @public\n */\nexport namespace InngestFunction {\n  export const Tag = \"Inngest.Function\" as const;\n\n  /**\n   * Represents any `InngestFunction` instance, regardless of generics and\n   * inference.\n   */\n  export type Any = InngestFunction<\n    // biome-ignore lint/suspicious/noExplicitAny: <explanation>\n    any,\n    Handler.Any,\n    Handler.Any,\n    // biome-ignore lint/suspicious/noExplicitAny: <explanation>\n    any,\n    // biome-ignore lint/suspicious/noExplicitAny: <explanation>\n    any,\n    // biome-ignore lint/suspicious/noExplicitAny: <explanation>\n    any\n  >;\n\n  export interface Like {\n    readonly [Symbol.toStringTag]: typeof InngestFunction.Tag;\n  }\n\n  /**\n   * A user-friendly method of specifying a trigger for an Inngest function.\n   *\n   * @public\n   */\n  export type Trigger<T extends string> = StrictUnion<\n    | {\n        event: T;\n        if?: string;\n      }\n    | {\n        cron: string;\n      }\n  >;\n\n  export type GetOptions<T extends InngestFunction.Any> =\n    // biome-ignore lint/suspicious/noExplicitAny: <explanation>\n    T extends InngestFunction<infer O, any, any, any, any, any> ? O : never;\n\n  /**\n   * A set of options for configuring an Inngest function.\n   *\n   * @public\n   */\n  export interface Options<\n    TClient extends Inngest.Any = Inngest.Any,\n    TMiddleware extends InngestMiddleware.Stack = InngestMiddleware.Stack,\n    TTriggers extends InngestFunction.Trigger<\n      TriggersFromClient<TClient>\n    >[] = InngestFunction.Trigger<TriggersFromClient<TClient>>[],\n    TFailureHandler extends Handler.Any = Handler.Any,\n  > {\n    triggers?: TTriggers;\n\n    /**\n     * An unique ID used to identify the function. This is used internally for\n     * versioning and referring to your function, so should not change between\n     * deployments.\n     *\n     * If you'd like to set a prettier name for your function, use the `name`\n     * option.\n     */\n    id: string;\n\n    /**\n     * A name for the function as it will appear in the Inngest Cloud UI.\n     */\n    name?: string;\n\n    /**\n     * A description of the function.\n     */\n    description?: string;\n\n    /**\n     * Concurrency specifies a limit on the total number of concurrent steps that\n     * can occur across all runs of the function.  A value of 0 (or undefined) means\n     * use the maximum available concurrency.\n     *\n     * Specifying just a number means specifying only the concurrency limit. A\n     * maximum of two concurrency options can be specified.\n     */\n    concurrency?:\n      | number\n      | ConcurrencyOption\n      | RecursiveTuple<ConcurrencyOption, 2>;\n\n    /**\n     * batchEvents specifies the batch configuration on when this function\n     * should be invoked when one of the requirements are fulfilled.\n     */\n    batchEvents?: {\n      /**\n       * The maximum number of events to be consumed in one batch.\n       * Check the pricing page to verify the limit for each plan.\n       */\n      maxSize: number;\n\n      /**\n       * How long to wait before invoking the function with a list of events.\n       * If timeout is reached, the function will be invoked with a batch\n       * even if it's not filled up to `maxSize`.\n       *\n       * Expects 1s to 60s.\n       */\n      timeout: TimeStrBatch;\n\n      /**\n       * An optional key to use for batching.\n       *\n       * See [batch documentation](https://innge.st/batching) for more\n       * information on how to use `key` expressions.\n       */\n      key?: string;\n\n      /**\n       * An optional boolean expression to determine an event's eligibility for batching\n       *\n       * See [batch documentation](https://innge.st/batching) for more\n       * information on how to use `if` expressions.\n       */\n      if?: string;\n    };\n\n    /**\n     * Allow the specification of an idempotency key using event data. If\n     * specified, this overrides the `rateLimit` object.\n     */\n    idempotency?: string;\n\n    /**\n     * Rate limit function runs, only running them a given number of times (limit) per\n     * period.  Note that rate limit is a lossy, hard limit.  Once the limit is hit,\n     * new runs will be skipped.  To enqueue work when a rate limit is hit, use the\n     * {@link throttle} parameter.\n     */\n    rateLimit?: {\n      /**\n       * An optional key to use for rate limiting, similar to idempotency.\n       */\n      key?: string;\n\n      /**\n       * The number of times to allow the function to run per the given `period`.\n       */\n      limit: number;\n\n      /**\n       * The period of time to allow the function to run `limit` times.\n       */\n      period: TimeStr;\n    };\n\n    /**\n     * Throttles function runs, only running them a given number of times (limit) per\n     * period.  Once the limit is hit, new runs will be enqueued and will start when there's\n     * capacity.  This may lead to a large backlog.  For hard rate limiting, use the\n     * {@link rateLimit} parameter.\n     */\n    throttle?: {\n      /**\n       *  An optional expression which returns a throttling key for controlling throttling.\n       *  Every unique key is its own throttle limit.  Event data may be used within this\n       *  expression, eg \"event.data.user_id\".\n       */\n      key?: string;\n\n      /**\n       * The total number of runs allowed to start within the given `period`.  The limit is\n       * applied evenly over the period.\n       */\n      limit: number;\n\n      /**\n       * The period of time for the rate limit.  Run starts are evenly spaced through\n       * the given period.  The minimum granularity is 1 second.\n       */\n      period: TimeStr;\n\n      /**\n       * The number of runs allowed to start in the given window in a single burst.\n       * A burst > 1 bypasses smoothing for the burst and allows many runs to start\n       * at once, if desired.  Defaults to 1, which disables bursting.\n       */\n      burst?: number;\n    };\n\n    /**\n     * Debounce delays functions for the `period` specified. If an event is sent,\n     * the function will not run until at least `period` has elapsed.\n     *\n     * If any new events are received that match the same debounce `key`, the\n     * function is rescheduled for another `period` delay, and the triggering\n     * event is replaced with the latest event received.\n     *\n     * See the [Debounce documentation](https://innge.st/debounce) for more\n     * information.\n     */\n    debounce?: {\n      /**\n       * An optional key to use for debouncing.\n       *\n       * See [Debounce documentation](https://innge.st/debounce) for more\n       * information on how to use `key` expressions.\n       */\n      key?: string;\n\n      /**\n       * The period of time to delay after receiving the last trigger to run the\n       * function.\n       *\n       * See [Debounce documentation](https://innge.st/debounce) for more\n       * information.\n       */\n      period: TimeStr;\n\n      /**\n       * The maximum time that a debounce can be extended before running.\n       * If events are continually received within the given period, a function\n       * will always run after the given timeout period.\n       *\n       * See [Debounce documentation](https://innge.st/debounce) for more\n       * information.\n       */\n      timeout?: TimeStr;\n    };\n\n    /**\n     * Configure how the priority of a function run is decided when multiple\n     * functions are triggered at the same time.\n     *\n     * See the [Priority documentation](https://innge.st/priority) for more\n     * information.\n     */\n    priority?: {\n      /**\n       * An expression to use to determine the priority of a function run. The\n       * expression can return a number between `-600` and `600`, where `600`\n       * declares that this run should be executed before any others enqueued in\n       * the last 600 seconds (10 minutes), and `-600` declares that this run\n       * should be executed after any others enqueued in the last 600 seconds.\n       *\n       * See the [Priority documentation](https://innge.st/priority) for more\n       * information.\n       */\n      run?: string;\n    };\n\n    /**\n     * Configure timeouts for the function.  If any of the timeouts are hit, the\n     * function run will be cancelled.\n     */\n    timeouts?: {\n      /**\n       * Start represents the timeout for starting a function.  If the time\n       * between scheduling and starting a function exceeds this value, the\n       * function will be cancelled.\n       *\n       * This is, essentially, the amount of time that a function sits in the\n       * queue before starting.\n       *\n       * A function may exceed this duration because of concurrency limits,\n       * throttling, etc.\n       */\n      start?: TimeStr;\n\n      /**\n       * Finish represents the time between a function starting and the function\n       * finishing. If a function takes longer than this time to finish, the\n       * function is marked as cancelled.\n       *\n       * The start time is taken from the time that the first successful\n       * function request begins, and does not include the time spent in the\n       * queue before the function starts.\n       *\n       * Note that if the final request to a function begins before this\n       * timeout, and completes after this timeout, the function will succeed.\n       */\n      finish?: TimeStr;\n    };\n\n    /**\n     * Ensures that only one run of the function is active at a time for a given key.\n     * If a new run is triggered while another is still in progress with the same key,\n     * the new run will either be skipped or replace the active one, depending on the mode.\n     *\n     * This is useful for deduplication or enforcing exclusive execution.\n     */\n    singleton?: {\n      /**\n       * An optional key expression used to scope singleton execution.\n       * Each unique key has its own singleton lock. Event data can be referenced,\n       * e.g. \"event.data.user_id\".\n       */\n      key?: string;\n\n      /**\n       * Determines how to handle new runs when one is already active for the same key.\n       * - `\"skip\"` skips the new run.\n       * - `\"cancel\"` cancels the existing run and starts the new one.\n       */\n      mode: \"skip\" | \"cancel\";\n    };\n\n    cancelOn?: Cancellation<GetEvents<TClient, true>>[];\n\n    /**\n     * Specifies the maximum number of retries for all steps across this function.\n     *\n     * Can be a number from `0` to `20`. Defaults to `3`.\n     */\n    retries?:\n      | 0\n      | 1\n      | 2\n      | 3\n      | 4\n      | 5\n      | 6\n      | 7\n      | 8\n      | 9\n      | 10\n      | 11\n      | 12\n      | 13\n      | 14\n      | 15\n      | 16\n      | 17\n      | 18\n      | 19\n      | 20;\n\n    /**\n     * Provide a function to be called if your function fails, meaning\n     * that it ran out of retries and was unable to complete successfully.\n     *\n     * This is useful for sending warning notifications or cleaning up\n     * after a failure and supports all the same functionality as a\n     * regular handler.\n     */\n    onFailure?: TFailureHandler;\n\n    /**\n     * Define a set of middleware that can be registered to hook into\n     * various lifecycles of the SDK and affect input and output of\n     * Inngest functionality.\n     *\n     * See {@link https://innge.st/middleware}\n     *\n     * @example\n     *\n     * ```ts\n     * export const inngest = new Inngest({\n     *   middleware: [\n     *     new InngestMiddleware({\n     *       name: \"My Middleware\",\n     *       init: () => {\n     *         // ...\n     *       }\n     *     })\n     *   ]\n     * });\n     * ```\n     */\n    middleware?: TMiddleware;\n\n    /**\n     * If `true`, parallel steps within this function are optimized to reduce\n     * traffic during `Promise` resolution, which can hugely reduce the time\n     * taken and number of requests for each run.\n     *\n     * Note that this will be the default behaviour in v4 and in its current\n     * form will cause `Promise.*()` to wait for all promises to settle before\n     * resolving.\n     *\n     * Providing this value here will overwrite the same value given on the\n     * client.\n     *\n     * @default false\n     */\n    optimizeParallelism?: boolean;\n  }\n}\n\nexport type CreateExecutionOptions = {\n  version: ExecutionVersion;\n  partialOptions: Omit<InngestExecutionOptions, \"fn\">;\n};\n"],"names":["fn: FunctionConfig","ret: NonNullable<FunctionConfig[\"cancel\"]>[number]","config: FunctionConfig[]","options: InngestExecutionOptions"],"mappings":"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","debugId":null}},
    {"offset": {"line": 6520, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/inngest/api/api.js","sources":["file:///Users/harshitgangwar/Desktop/SkillForge/node_modules/src/api/api.ts"],"sourcesContent":["import type { fetch } from \"cross-fetch\";\nimport { z } from \"zod/v3\";\nimport {\n  defaultDevServerHost,\n  defaultInngestApiBaseUrl,\n  type ExecutionVersion,\n} from \"../helpers/consts.ts\";\nimport { devServerAvailable } from \"../helpers/devserver.ts\";\nimport type { Mode } from \"../helpers/env.ts\";\nimport { getErrorMessage } from \"../helpers/errors.ts\";\nimport { fetchWithAuthFallback } from \"../helpers/net.ts\";\nimport { hashSigningKey } from \"../helpers/strings.ts\";\nimport { err, ok, type Result } from \"../types.ts\";\nimport {\n  type BatchResponse,\n  batchSchema,\n  type ErrorResponse,\n  errorSchema,\n  type StepsResponse,\n  stepsSchemas,\n} from \"./schema.ts\";\n\ntype FetchT = typeof fetch;\n\nconst realtimeSubscriptionTokenSchema = z.object({\n  jwt: z.string(),\n});\n\nconst sendSignalSuccessResponseSchema = z.object({\n  data: z.object({\n    run_id: z.string().min(1),\n  }),\n});\n\nexport namespace InngestApi {\n  export interface Options {\n    baseUrl?: string;\n    signingKey: string;\n    signingKeyFallback: string | undefined;\n    fetch: FetchT;\n    mode: Mode;\n  }\n\n  export interface Subscription {\n    topics: string[];\n    channel: string;\n  }\n\n  export interface PublishOptions extends Subscription {\n    runId?: string;\n  }\n\n  export interface SendSignalOptions {\n    signal: string;\n    data?: unknown;\n  }\n\n  export interface SendSignalResponse {\n    /**\n     * The ID of the run that was signaled.\n     *\n     * If this is undefined, the signal could not be matched to a run.\n     */\n    runId: string | undefined;\n  }\n}\n\nexport class InngestApi {\n  public apiBaseUrl?: string;\n  private signingKey: string;\n  private signingKeyFallback: string | undefined;\n  private readonly fetch: FetchT;\n  private mode: Mode;\n\n  constructor({\n    baseUrl,\n    signingKey,\n    signingKeyFallback,\n    fetch,\n    mode,\n  }: InngestApi.Options) {\n    this.apiBaseUrl = baseUrl;\n    this.signingKey = signingKey;\n    this.signingKeyFallback = signingKeyFallback;\n    this.fetch = fetch;\n    this.mode = mode;\n  }\n\n  private get hashedKey(): string {\n    return hashSigningKey(this.signingKey);\n  }\n\n  private get hashedFallbackKey(): string | undefined {\n    if (!this.signingKeyFallback) {\n      return;\n    }\n\n    return hashSigningKey(this.signingKeyFallback);\n  }\n\n  // set the signing key in case it was not instantiated previously\n  setSigningKey(key: string | undefined) {\n    if (typeof key === \"string\" && this.signingKey === \"\") {\n      this.signingKey = key;\n    }\n  }\n\n  setSigningKeyFallback(key: string | undefined) {\n    if (typeof key === \"string\" && !this.signingKeyFallback) {\n      this.signingKeyFallback = key;\n    }\n  }\n\n  private async getTargetUrl(path: string): Promise<URL> {\n    if (this.apiBaseUrl) {\n      return new URL(path, this.apiBaseUrl);\n    }\n\n    let url = new URL(path, defaultInngestApiBaseUrl);\n\n    if (this.mode.isDev && this.mode.isInferred && !this.apiBaseUrl) {\n      const devAvailable = await devServerAvailable(\n        defaultDevServerHost,\n        this.fetch,\n      );\n\n      if (devAvailable) {\n        url = new URL(path, defaultDevServerHost);\n      }\n    }\n\n    return url;\n  }\n\n  async getRunSteps(\n    runId: string,\n    version: ExecutionVersion,\n  ): Promise<Result<StepsResponse, ErrorResponse>> {\n    return fetchWithAuthFallback({\n      authToken: this.hashedKey,\n      authTokenFallback: this.hashedFallbackKey,\n      fetch: this.fetch,\n      url: await this.getTargetUrl(`/v0/runs/${runId}/actions`),\n    })\n      .then(async (resp) => {\n        const data: unknown = await resp.json();\n\n        if (resp.ok) {\n          return ok(stepsSchemas[version].parse(data));\n        } else {\n          return err(errorSchema.parse(data));\n        }\n      })\n      .catch((error) => {\n        return err({\n          error: getErrorMessage(error, \"Unknown error retrieving step data\"),\n          status: 500,\n        });\n      });\n  }\n\n  async getRunBatch(\n    runId: string,\n  ): Promise<Result<BatchResponse, ErrorResponse>> {\n    return fetchWithAuthFallback({\n      authToken: this.hashedKey,\n      authTokenFallback: this.hashedFallbackKey,\n      fetch: this.fetch,\n      url: await this.getTargetUrl(`/v0/runs/${runId}/batch`),\n    })\n      .then(async (resp) => {\n        const data: unknown = await resp.json();\n\n        if (resp.ok) {\n          return ok(batchSchema.parse(data));\n        } else {\n          return err(errorSchema.parse(data));\n        }\n      })\n      .catch((error) => {\n        return err({\n          error: getErrorMessage(error, \"Unknown error retrieving event batch\"),\n          status: 500,\n        });\n      });\n  }\n\n  async publish(\n    publishOptions: InngestApi.PublishOptions,\n    // biome-ignore lint/suspicious/noExplicitAny: <explanation>\n    data: any,\n  ): Promise<Result<void, ErrorResponse>> {\n    // todo it may not be a \"text/stream\"\n    const isStream = data instanceof ReadableStream;\n    const url = await this.getTargetUrl(\"/v1/realtime/publish\");\n\n    url.searchParams.set(\"channel\", publishOptions.channel || \"\");\n\n    if (publishOptions.runId) {\n      url.searchParams.set(\"run_id\", publishOptions.runId);\n    }\n\n    // biome-ignore lint/complexity/noForEach: <explanation>\n    publishOptions.topics.forEach((topic) => {\n      url.searchParams.append(\"topic\", topic);\n    });\n\n    return fetchWithAuthFallback({\n      authToken: this.hashedKey,\n      authTokenFallback: this.hashedFallbackKey,\n      fetch: this.fetch,\n      url,\n      options: {\n        method: \"POST\",\n        body: isStream\n          ? data\n          : typeof data === \"string\"\n            ? data\n            : JSON.stringify(data),\n        headers: {\n          \"Content-Type\": isStream ? \"text/stream\" : \"application/json\",\n        },\n        ...(isStream ? { duplex: \"half\" } : {}),\n      },\n    })\n      .then((res) => {\n        if (!res.ok) {\n          throw new Error(\n            `Failed to publish event: ${res.status} ${res.statusText}`,\n          );\n        }\n\n        return ok<void>(undefined);\n      })\n      .catch((error) => {\n        return err({\n          error: getErrorMessage(error, \"Unknown error publishing event\"),\n          status: 500,\n        });\n      });\n  }\n\n  async sendSignal(\n    signalOptions: InngestApi.SendSignalOptions,\n    options?: {\n      headers?: Record<string, string>;\n    },\n  ): Promise<Result<InngestApi.SendSignalResponse, ErrorResponse>> {\n    const url = await this.getTargetUrl(\"/v1/signals\");\n\n    const body = {\n      signal: signalOptions.signal,\n      data: signalOptions.data,\n    };\n\n    return fetchWithAuthFallback({\n      authToken: this.hashedKey,\n      authTokenFallback: this.hashedFallbackKey,\n      fetch: this.fetch,\n      url,\n      options: {\n        method: \"POST\",\n        body: JSON.stringify(body),\n        headers: {\n          \"Content-Type\": \"application/json\",\n          ...options?.headers,\n        },\n      },\n    })\n      .then(async (res) => {\n        // A 404 is valid if the signal was not found.\n        if (res.status === 404) {\n          return ok<InngestApi.SendSignalResponse>({\n            runId: undefined,\n          });\n        }\n\n        // Save a clone of the response we can use to get the text of if we fail\n        // to parse the JSON.\n        const resClone = res.clone();\n\n        // JSON!\n        let json: unknown;\n        try {\n          json = await res.json();\n        } catch {\n          // res.json() failed so not a valid JSON response\n          return err({\n            error: `Failed to send signal: ${res.status} ${\n              res.statusText\n            } - ${await resClone.text()}`,\n            status: res.status,\n          });\n        }\n\n        // If we're not 2xx, something went wrong.\n        if (!res.ok) {\n          try {\n            return err(errorSchema.parse(json));\n          } catch {\n            // schema parse failed\n            return err({\n              error: `Failed to send signal: ${res.status} ${\n                res.statusText\n              } - ${await res.text()}`,\n              status: res.status,\n            });\n          }\n        }\n\n        // If we are 2xx, we should have a run_id.\n        const parseRes = sendSignalSuccessResponseSchema.safeParse(json);\n        if (!parseRes.success) {\n          return err({\n            error: `Successfully sent signal, but response parsing failed: ${\n              res.status\n            } ${res.statusText} - ${await resClone.text()}`,\n            status: res.status,\n          });\n        }\n\n        return ok({\n          runId: parseRes.data.data.run_id,\n        });\n      })\n      .catch((error) => {\n        // Catch-all if various things go wrong\n        return err({\n          error: getErrorMessage(error, \"Unknown error sending signal\"),\n          status: 500,\n        });\n      });\n  }\n\n  async getSubscriptionToken(\n    channel: string,\n    topics: string[],\n  ): Promise<string> {\n    const url = await this.getTargetUrl(\"/v1/realtime/token\");\n\n    const body = topics.map((topic) => ({\n      channel,\n      name: topic,\n      kind: \"run\",\n    }));\n\n    return fetchWithAuthFallback({\n      authToken: this.hashedKey,\n      authTokenFallback: this.hashedFallbackKey,\n      fetch: this.fetch,\n      url,\n      options: {\n        method: \"POST\",\n        body: JSON.stringify(body),\n        headers: {\n          \"Content-Type\": \"application/json\",\n        },\n      },\n    })\n      .then(async (res) => {\n        if (!res.ok) {\n          throw new Error(\n            `Failed to get subscription token: ${res.status} ${\n              res.statusText\n            } - ${await res.text()}`,\n          );\n        }\n\n        const data = realtimeSubscriptionTokenSchema.parse(await res.json());\n\n        return data.jwt;\n      })\n      .catch((error) => {\n        throw new Error(\n          getErrorMessage(error, \"Unknown error getting subscription token\"),\n        );\n      });\n  }\n}\n"],"names":["data: unknown","json: unknown"],"mappings":"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","debugId":null}},
    {"offset": {"line": 6740, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/inngest/helpers/crypto.js","sources":["file:///Users/harshitgangwar/Desktop/SkillForge/node_modules/src/helpers/crypto.ts"],"sourcesContent":["/**\n * Create a cryptographically secure random value.\n *\n * @throws {Error} If the crypto module is not available.\n */\nexport function createEntropy(byteLength: number): Uint8Array {\n  const bytes = new Uint8Array(byteLength);\n\n  // https://developer.mozilla.org/en-US/docs/Web/API/Crypto#browser_compatibility\n  const { crypto } = globalThis;\n  if (!crypto) {\n    // This should only happen in Node <19.\n    throw new Error(\"missing crypto module\");\n  }\n  if (!crypto.getRandomValues) {\n    throw new Error(\"missing crypto.getRandomValues\");\n  }\n\n  crypto.getRandomValues(bytes);\n  return bytes;\n}\n"],"names":[],"mappings":";;;;;;;;;AAKA,SAAgB,cAAc,UAAA,EAAgC;IAC5D,MAAM,QAAQ,IAAI,WAAW,WAAW;IAGxC,MAAM,EAAE,MAAA,EAAA,GAAW;IACnB,IAAI,CAAC,OAEH,CAAA,MAAM,IAAI,MAAM,wBAAwB;IAE1C,IAAI,CAAC,OAAO,eAAA,CACV,CAAA,MAAM,IAAI,MAAM,iCAAiC;IAGnD,OAAO,eAAA,CAAgB,MAAM;IAC7B,OAAO","debugId":null}},
    {"offset": {"line": 6763, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/inngest/middleware/logger.js","sources":["file:///Users/harshitgangwar/Desktop/SkillForge/node_modules/src/middleware/logger.ts"],"sourcesContent":["/**\n * All kinds of arguments can come through\n *\n * Examples seen are\n * - string\n * - object / hash\n * - values used for string interpolation, basically anything\n *\n * See https://linear.app/inngest/issue/INN-1342/flush-logs-on-function-exitreturns for more details\n *\n * @public\n */\nexport type LogArg = unknown;\n\n/**\n * Based on https://datatracker.ietf.org/doc/html/rfc5424#autoid-11\n * it's pretty reasonable to expect a logger to have the following interfaces\n * available.\n */\nexport interface Logger {\n  info(...args: LogArg[]): void;\n  warn(...args: LogArg[]): void;\n  error(...args: LogArg[]): void;\n  debug(...args: LogArg[]): void;\n}\n\nexport class DefaultLogger implements Logger {\n  info(...args: LogArg[]) {\n    console.info(...args);\n  }\n\n  warn(...args: LogArg[]) {\n    console.warn(...args);\n  }\n\n  error(...args: LogArg[]) {\n    console.error(...args);\n  }\n\n  debug(...args: LogArg[]) {\n    console.debug(...args);\n  }\n}\n\n/**\n * ProxyLogger aims to provide a thin wrapper on user's provided logger.\n * It's expected to be turned on and off based on the function execution\n * context, so it doesn't result in duplicated logging.\n *\n * And also attempt to allow enough time for the logger to flush all logs.\n *\n * @public\n */\nexport class ProxyLogger implements Logger {\n  private readonly logger: Logger;\n  private enabled = false;\n\n  constructor(logger: Logger) {\n    this.logger = logger;\n\n    // Return a Proxy to forward arbitrary property access to the underlying\n    // logger. For example, if the user provides a logger that has a `foo`\n    // method, they can call `foo` on the ProxyLogger and it will call the\n    // underlying logger's `foo` method.\n    return new Proxy(this, {\n      get(target, prop, receiver): unknown {\n        // Handle ProxyLogger's own methods/properties.\n        if (prop in target) {\n          return Reflect.get(target, prop, receiver);\n        }\n\n        // Forward property access to the underlying logger.\n        return Reflect.get(target.logger, prop, receiver);\n      },\n    }) as ProxyLogger;\n  }\n\n  info(...args: LogArg[]) {\n    if (!this.enabled) return;\n    this.logger.info(...args);\n  }\n\n  warn(...args: LogArg[]) {\n    if (!this.enabled) return;\n    this.logger.warn(...args);\n  }\n\n  error(...args: LogArg[]) {\n    if (!this.enabled) return;\n    this.logger.error(...args);\n  }\n\n  debug(...args: LogArg[]) {\n    // there are loggers that don't implement \"debug\" by default\n    if (!this.enabled || !(typeof this.logger.debug === \"function\")) return;\n    this.logger.debug(...args);\n  }\n\n  enable() {\n    this.enabled = true;\n  }\n\n  disable() {\n    this.enabled = false;\n  }\n\n  async flush() {\n    // Allow 1s for the provided logger to handle flushing since the ones that do\n    // flushing usually has some kind of timeout of up to 1s.\n    //\n    // TODO:\n    // This should only happen when using a serverless environment because it's very\n    // costly from the compute perspective.\n    // server runtimes should just let the logger do their thing since most of them\n    // should have already figured what to do in those environments, be it threading or\n    // something else.\n    if (this.logger.constructor.name !== DefaultLogger.name) {\n      await new Promise((resolve) => {\n        setTimeout(() => resolve(null), 1000);\n      });\n    }\n  }\n}\n"],"names":[],"mappings":";;;;;;;AA0BA,IAAa,gBAAb,MAA6C;IAC3C,KAAK,GAAG,IAAA,EAAgB;QACtB,QAAQ,IAAA,CAAK,GAAG,KAAK;;IAGvB,KAAK,GAAG,IAAA,EAAgB;QACtB,QAAQ,IAAA,CAAK,GAAG,KAAK;;IAGvB,MAAM,GAAG,IAAA,EAAgB;QACvB,QAAQ,KAAA,CAAM,GAAG,KAAK;;IAGxB,MAAM,GAAG,IAAA,EAAgB;QACvB,QAAQ,KAAA,CAAM,GAAG,KAAK;;;;;;;;;;;GAa1B,IAAa,cAAb,MAA2C;IACxB,OAAA;IACT,UAAU,MAAA;IAElB,YAAY,MAAA,CAAgB;QAC1B,IAAA,CAAK,MAAA,GAAS;QAMd,OAAO,IAAI,MAAM,IAAA,EAAM;YACrB,KAAI,MAAA,EAAQ,IAAA,EAAM,QAAA,EAAmB;gBAEnC,IAAI,QAAQ,OACV,CAAA,OAAO,QAAQ,GAAA,CAAI,QAAQ,MAAM,SAAS;gBAI5C,OAAO,QAAQ,GAAA,CAAI,OAAO,MAAA,EAAQ,MAAM,SAAS;;SAEpD,CAAC;;IAGJ,KAAK,GAAG,IAAA,EAAgB;QACtB,IAAI,CAAC,IAAA,CAAK,OAAA,CAAS,CAAA;QACnB,IAAA,CAAK,MAAA,CAAO,IAAA,CAAK,GAAG,KAAK;;IAG3B,KAAK,GAAG,IAAA,EAAgB;QACtB,IAAI,CAAC,IAAA,CAAK,OAAA,CAAS,CAAA;QACnB,IAAA,CAAK,MAAA,CAAO,IAAA,CAAK,GAAG,KAAK;;IAG3B,MAAM,GAAG,IAAA,EAAgB;QACvB,IAAI,CAAC,IAAA,CAAK,OAAA,CAAS,CAAA;QACnB,IAAA,CAAK,MAAA,CAAO,KAAA,CAAM,GAAG,KAAK;;IAG5B,MAAM,GAAG,IAAA,EAAgB;QAEvB,IAAI,CAAC,IAAA,CAAK,OAAA,IAAW,CAAA,CAAE,OAAO,IAAA,CAAK,MAAA,CAAO,KAAA,KAAU,UAAA,EAAa,CAAA;QACjE,IAAA,CAAK,MAAA,CAAO,KAAA,CAAM,GAAG,KAAK;;IAG5B,SAAS;QACP,IAAA,CAAK,OAAA,GAAU;;IAGjB,UAAU;QACR,IAAA,CAAK,OAAA,GAAU;;IAGjB,MAAM,QAAQ;QAUZ,IAAI,IAAA,CAAK,MAAA,CAAO,WAAA,CAAY,IAAA,KAAS,cAAc,IAAA,CACjD,CAAA,MAAM,IAAI,QAAA,CAAS,YAAY;YAC7B,WAAA,IAAiB,QAAQ,KAAK,EAAE,IAAK;UACrC","debugId":null}},
    {"offset": {"line": 6838, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/inngest/components/Inngest.js","sources":["file:///Users/harshitgangwar/Desktop/SkillForge/node_modules/src/components/Inngest.ts"],"sourcesContent":["import { InngestApi } from \"../api/api.ts\";\nimport {\n  defaultDevServerHost,\n  defaultInngestApiBaseUrl,\n  defaultInngestEventBaseUrl,\n  dummyEventKey,\n  envKeys,\n  headerKeys,\n  logPrefix,\n} from \"../helpers/consts.ts\";\nimport { createEntropy } from \"../helpers/crypto.ts\";\nimport { devServerAvailable, devServerUrl } from \"../helpers/devserver.ts\";\nimport {\n  allProcessEnv,\n  getFetch,\n  getMode,\n  inngestHeaders,\n  type Mode,\n  processEnv,\n} from \"../helpers/env.ts\";\nimport { fixEventKeyMissingSteps, prettyError } from \"../helpers/errors.ts\";\nimport type { Jsonify } from \"../helpers/jsonify.ts\";\nimport { retryWithBackoff } from \"../helpers/promises.ts\";\nimport { stringify } from \"../helpers/strings.ts\";\nimport type {\n  AsArray,\n  IsNever,\n  SendEventPayload,\n  SimplifyDeep,\n  SingleOrArray,\n  WithoutInternal,\n} from \"../helpers/types.ts\";\nimport {\n  DefaultLogger,\n  type Logger,\n  ProxyLogger,\n} from \"../middleware/logger.ts\";\nimport {\n  type ClientOptions,\n  type EventNameFromTrigger,\n  type EventPayload,\n  type FailureEventArgs,\n  type Handler,\n  type InvokeTargetFunctionDefinition,\n  type SendEventOutput,\n  type SendEventResponse,\n  sendEventResponseSchema,\n  type TriggersFromClient,\n} from \"../types.ts\";\nimport type { EventSchemas } from \"./EventSchemas.ts\";\nimport { InngestFunction } from \"./InngestFunction.ts\";\nimport type { InngestFunctionReference } from \"./InngestFunctionReference.ts\";\nimport {\n  type ExtendWithMiddleware,\n  getHookStack,\n  InngestMiddleware,\n  type MiddlewareRegisterFn,\n  type MiddlewareRegisterReturn,\n  type SendEventHookStack,\n} from \"./InngestMiddleware.ts\";\n\n/**\n * Capturing the global type of fetch so that we can reliably access it below.\n */\ntype FetchT = typeof fetch;\n\n/**\n * Given a set of client options for Inngest, return the event types that can\n * be sent or received.\n *\n * @public\n */\nexport type EventsFromOpts<TOpts extends ClientOptions> =\n  TOpts[\"schemas\"] extends EventSchemas<infer U>\n    ? U\n    : Record<string, EventPayload>;\n\n/**\n * A client used to interact with the Inngest API by sending or reacting to\n * events.\n *\n * To provide event typing, see {@link EventSchemas}.\n *\n * ```ts\n * const inngest = new Inngest({ id: \"my-app\" });\n *\n * // or to provide event typing too\n * const inngest = new Inngest({\n *   id: \"my-app\",\n *   schemas: new EventSchemas().fromRecord<{\n *     \"app/user.created\": {\n *       data: { userId: string };\n *     };\n *   }>(),\n * });\n * ```\n *\n * @public\n */\nexport class Inngest<TClientOpts extends ClientOptions = ClientOptions>\n  implements Inngest.Like\n{\n  get [Symbol.toStringTag](): typeof Inngest.Tag {\n    return Inngest.Tag;\n  }\n\n  /**\n   * The ID of this instance, most commonly a reference to the application it\n   * resides in.\n   *\n   * The ID of your client should remain the same for its lifetime; if you'd\n   * like to change the name of your client as it appears in the Inngest UI,\n   * change the `name` property instead.\n   */\n  public readonly id: string;\n\n  /**\n   * Stores the options so we can remember explicit settings the user has\n   * provided.\n   */\n  private readonly options: TClientOpts;\n\n  /**\n   * Inngest event key, used to send events to Inngest Cloud.\n   */\n  private eventKey = \"\";\n\n  private _apiBaseUrl: string | undefined;\n  private _eventBaseUrl: string | undefined;\n\n  private readonly inngestApi: InngestApi;\n\n  /**\n   * The absolute URL of the Inngest Cloud API.\n   */\n  private sendEventUrl: URL = new URL(\n    `e/${this.eventKey}`,\n    defaultInngestEventBaseUrl,\n  );\n\n  private headers!: Record<string, string>;\n\n  private readonly fetch: FetchT;\n\n  // biome-ignore lint/correctness/noUnusedPrivateClassMembers: used in the SDK\n  private readonly logger: Logger;\n\n  private localFns: InngestFunction.Any[] = [];\n\n  /**\n   * A promise that resolves when the middleware stack has been initialized and\n   * the client is ready to be used.\n   */\n  private readonly middleware: Promise<MiddlewareRegisterReturn[]>;\n\n  /**\n   * Whether the client is running in a production environment. This can\n   * sometimes be `undefined` if the client has expressed no preference or\n   * perhaps environment variables are only available at a later stage in the\n   * runtime, for example when receiving a request.\n   *\n   * An {@link InngestCommHandler} should prioritize this value over all other\n   * settings, but should still check for the presence of an environment\n   * variable if it is not set.\n   */\n  private _mode!: Mode;\n\n  protected readonly schemas?: NonNullable<TClientOpts[\"schemas\"]>;\n\n  private _appVersion: string | undefined;\n\n  get apiBaseUrl(): string | undefined {\n    return this._apiBaseUrl;\n  }\n\n  get eventBaseUrl(): string | undefined {\n    return this._eventBaseUrl;\n  }\n\n  get env(): string | null {\n    return this.headers[headerKeys.Environment] ?? null;\n  }\n\n  get appVersion(): string | undefined {\n    return this._appVersion;\n  }\n\n  /**\n   * A client used to interact with the Inngest API by sending or reacting to\n   * events.\n   *\n   * To provide event typing, see {@link EventSchemas}.\n   *\n   * ```ts\n   * const inngest = new Inngest({ name: \"My App\" });\n   *\n   * // or to provide event typing too\n   * const inngest = new Inngest({\n   *   name: \"My App\",\n   *   schemas: new EventSchemas().fromRecord<{\n   *     \"app/user.created\": {\n   *       data: { userId: string };\n   *     };\n   *   }>(),\n   * });\n   * ```\n   */\n  constructor(options: TClientOpts) {\n    this.options = options;\n\n    const {\n      id,\n      fetch,\n      logger = new DefaultLogger(),\n      middleware,\n      isDev,\n      schemas,\n      appVersion,\n    } = this.options;\n\n    if (!id) {\n      // TODO PrettyError\n      throw new Error(\"An `id` must be passed to create an Inngest instance.\");\n    }\n\n    this.id = id;\n\n    this._mode = getMode({\n      explicitMode:\n        typeof isDev === \"boolean\" ? (isDev ? \"dev\" : \"cloud\") : undefined,\n    });\n\n    this.fetch = getFetch(fetch);\n\n    this.inngestApi = new InngestApi({\n      baseUrl: this.apiBaseUrl,\n      signingKey: processEnv(envKeys.InngestSigningKey) || \"\",\n      signingKeyFallback: processEnv(envKeys.InngestSigningKeyFallback),\n      fetch: this.fetch,\n      mode: this.mode,\n    });\n\n    this.schemas = schemas;\n    this.loadModeEnvVars();\n\n    this.logger = logger;\n\n    this.middleware = this.initializeMiddleware([\n      ...builtInMiddleware,\n      ...(middleware || []),\n    ]);\n\n    this._appVersion = appVersion;\n  }\n\n  /**\n   * Returns a `Promise` that resolves when the app is ready and all middleware\n   * has been initialized.\n   */\n  public get ready(): Promise<void> {\n    return this.middleware.then(() => {});\n  }\n\n  /**\n   * Set the environment variables for this client. This is useful if you are\n   * passed environment variables at runtime instead of as globals and need to\n   * update the client with those values as requests come in.\n   */\n  public setEnvVars(\n    env: Record<string, string | undefined> = allProcessEnv(),\n  ): this {\n    this.mode = getMode({ env, client: this });\n\n    return this;\n  }\n\n  private loadModeEnvVars(): void {\n    this._apiBaseUrl =\n      this.options.baseUrl ||\n      this.mode[\"env\"][envKeys.InngestApiBaseUrl] ||\n      this.mode[\"env\"][envKeys.InngestBaseUrl] ||\n      this.mode.getExplicitUrl(defaultInngestApiBaseUrl);\n\n    this._eventBaseUrl =\n      this.options.baseUrl ||\n      this.mode[\"env\"][envKeys.InngestEventApiBaseUrl] ||\n      this.mode[\"env\"][envKeys.InngestBaseUrl] ||\n      this.mode.getExplicitUrl(defaultInngestEventBaseUrl);\n\n    this.setEventKey(\n      this.options.eventKey || this.mode[\"env\"][envKeys.InngestEventKey] || \"\",\n    );\n\n    this.headers = inngestHeaders({\n      inngestEnv: this.options.env,\n      env: this.mode[\"env\"],\n    });\n\n    this.inngestApi[\"mode\"] = this.mode;\n    this.inngestApi[\"apiBaseUrl\"] = this._apiBaseUrl;\n  }\n\n  /**\n   * Initialize all passed middleware, running the `register` function on each\n   * in sequence and returning the requested hook registrations.\n   */\n  private async initializeMiddleware(\n    middleware: InngestMiddleware.Like[] = [],\n    opts?: {\n      registerInput?: Omit<Parameters<MiddlewareRegisterFn>[0], \"client\">;\n      prefixStack?: Promise<MiddlewareRegisterReturn[]>;\n    },\n  ): Promise<MiddlewareRegisterReturn[]> {\n    /**\n     * Wait for the prefix stack to run first; do not trigger ours before this\n     * is complete.\n     */\n    const prefix = await (opts?.prefixStack ?? []);\n\n    const stack = middleware.reduce<Promise<MiddlewareRegisterReturn[]>>(\n      async (acc, m) => {\n        // Be explicit about waiting for the previous middleware to finish\n        const prev = await acc;\n        const next = await (m as InngestMiddleware.Any).init({\n          client: this,\n          ...opts?.registerInput,\n        });\n\n        return [...prev, next];\n      },\n      Promise.resolve([]),\n    );\n\n    return [...prefix, ...(await stack)];\n  }\n\n  private get mode(): Mode {\n    return this._mode;\n  }\n\n  private set mode(m) {\n    this._mode = m;\n    this.loadModeEnvVars();\n  }\n\n  /**\n   * Given a response from Inngest, relay the error to the caller.\n   */\n  private async getResponseError(\n    response: globalThis.Response,\n    rawBody: unknown,\n    foundErr = \"Unknown error\",\n  ): Promise<Error> {\n    let errorMessage = foundErr;\n\n    if (errorMessage === \"Unknown error\") {\n      switch (response.status) {\n        case 401:\n          errorMessage = \"Event key Not Found\";\n          break;\n        case 400:\n          errorMessage = \"Cannot process event payload\";\n          break;\n        case 403:\n          errorMessage = \"Forbidden\";\n          break;\n        case 404:\n          errorMessage = \"Event key not found\";\n          break;\n        case 406:\n          errorMessage = `${JSON.stringify(await rawBody)}`;\n          break;\n        case 409:\n        case 412:\n          errorMessage = \"Event transformation failed\";\n          break;\n        case 413:\n          errorMessage = \"Event payload too large\";\n          break;\n        case 500:\n          errorMessage = \"Internal server error\";\n          break;\n        default:\n          try {\n            errorMessage = await response.text();\n          } catch (_err) {\n            errorMessage = `${JSON.stringify(await rawBody)}`;\n          }\n          break;\n      }\n    }\n\n    return new Error(`Inngest API Error: ${response.status} ${errorMessage}`);\n  }\n\n  /**\n   * Set the event key for this instance of Inngest. This is useful if for some\n   * reason the key is not available at time of instantiation or present in the\n   * `INNGEST_EVENT_KEY` environment variable.\n   */\n  public setEventKey(\n    /**\n     * Inngest event key, used to send events to Inngest Cloud. Use this is your\n     * key is for some reason not available at time of instantiation or present\n     * in the `INNGEST_EVENT_KEY` environment variable.\n     */\n    eventKey: string,\n  ): void {\n    this.eventKey = eventKey || dummyEventKey;\n\n    this.sendEventUrl = new URL(\n      `e/${this.eventKey}`,\n      this.eventBaseUrl || defaultInngestEventBaseUrl,\n    );\n  }\n\n  private eventKeySet(): boolean {\n    return Boolean(this.eventKey) && this.eventKey !== dummyEventKey;\n  }\n\n  /**\n   * EXPERIMENTAL: This API is not yet stable and may change in the future\n   * without a major version bump.\n   *\n   * Send a Signal to Inngest.\n   */\n  public async sendSignal({\n    signal,\n    data,\n    env,\n  }: {\n    /**\n     * The signal to send.\n     */\n    signal: string;\n\n    /**\n     * The data to send with the signal.\n     */\n    data?: unknown;\n\n    /**\n     * The Inngest environment to send the signal to. Defaults to whichever\n     * environment this client's key is associated with.\n     *\n     * It's like you never need to change this unless you're trying to sync\n     * multiple systems together using branch names.\n     */\n    env?: string;\n  }): Promise<InngestApi.SendSignalResponse> {\n    const headers: Record<string, string> = {\n      ...(env ? { [headerKeys.Environment]: env } : {}),\n    };\n\n    return this._sendSignal({ signal, data, headers });\n  }\n\n  private async _sendSignal({\n    signal,\n    data,\n    headers,\n  }: {\n    signal: string;\n    data?: unknown;\n    headers?: Record<string, string>;\n  }): Promise<InngestApi.SendSignalResponse> {\n    const res = await this.inngestApi.sendSignal(\n      { signal, data },\n      { ...this.headers, ...headers },\n    );\n    if (res.ok) {\n      return res.value;\n    }\n\n    throw new Error(\n      `Failed to send signal: ${res.error?.error || \"Unknown error\"}`,\n    );\n  }\n\n  /**\n   * Send one or many events to Inngest. Takes an entire payload (including\n   * name) as each input.\n   *\n   * ```ts\n   * await inngest.send({ name: \"app/user.created\", data: { id: 123 } });\n   * ```\n   *\n   * Returns a promise that will resolve if the event(s) were sent successfully,\n   * else throws with an error explaining what went wrong.\n   *\n   * If you wish to send an event with custom types (i.e. one that hasn't been\n   * generated), make sure to add it when creating your Inngest instance, like\n   * so:\n   *\n   * ```ts\n   * const inngest = new Inngest({\n   *   name: \"My App\",\n   *   schemas: new EventSchemas().fromRecord<{\n   *     \"my/event\": {\n   *       name: \"my/event\";\n   *       data: { bar: string };\n   *     };\n   *   }>(),\n   * });\n   * ```\n   */\n  public async send<Payload extends SendEventPayload<GetEvents<this>>>(\n    payload: Payload,\n    options?: {\n      /**\n       * The Inngest environment to send events to. Defaults to whichever\n       * environment this client's event key is associated with.\n       *\n       * It's likely you never need to change this unless you're trying to sync\n       * multiple systems together using branch names.\n       */\n      env?: string;\n    },\n  ): Promise<SendEventOutput<TClientOpts>> {\n    const headers: Record<string, string> = {\n      ...(options?.env ? { [headerKeys.Environment]: options.env } : {}),\n    };\n\n    return this._send({ payload, headers });\n  }\n\n  /**\n   * Internal method for sending an event, used to allow Inngest internals to\n   * further customize the request sent to an Inngest Server.\n   */\n  private async _send<Payload extends SendEventPayload<GetEvents<this>>>({\n    payload,\n    headers,\n  }: {\n    payload: Payload;\n    headers?: Record<string, string>;\n  }): Promise<SendEventOutput<TClientOpts>> {\n    const nowMillis = new Date().getTime();\n\n    let maxAttempts = 5;\n\n    // Attempt to set the event ID seed header. If it fails then disable retries\n    // (but we still want to send the event).\n    try {\n      const entropy = createEntropy(10);\n      const entropyBase64 = Buffer.from(entropy).toString(\"base64\");\n      headers = {\n        ...headers,\n        [headerKeys.EventIdSeed]: `${nowMillis},${entropyBase64}`,\n      };\n    } catch (err) {\n      let message = \"Event-sending retries disabled\";\n      if (err instanceof Error) {\n        message += `: ${err.message}`;\n      }\n\n      console.debug(message);\n\n      // Disable retries.\n      maxAttempts = 1;\n    }\n\n    const hooks = await getHookStack(\n      this.middleware,\n      \"onSendEvent\",\n      undefined,\n      {\n        transformInput: (prev, output) => {\n          return { ...prev, ...output };\n        },\n        transformOutput(prev, output) {\n          return {\n            result: { ...prev.result, ...output?.result },\n          };\n        },\n      },\n    );\n\n    let payloads: EventPayload[] = Array.isArray(payload)\n      ? (payload as EventPayload[])\n      : payload\n        ? ([payload] as [EventPayload])\n        : [];\n\n    const inputChanges = await hooks.transformInput?.({\n      payloads: [...payloads],\n    });\n    if (inputChanges?.payloads) {\n      payloads = [...inputChanges.payloads];\n    }\n\n    // Ensure that we always add \"ts\" and \"data\" fields to events. \"ts\" is auto-\n    // filled by the event server so is safe, and adding here fixes Next.js\n    // server action cache issues.\n    payloads = payloads.map((p) => {\n      return {\n        ...p,\n        // Always generate an idempotency ID for an event for retries\n        id: p.id,\n        ts: p.ts || nowMillis,\n        data: p.data || {},\n      };\n    });\n\n    const applyHookToOutput = async (\n      arg: Parameters<NonNullable<SendEventHookStack[\"transformOutput\"]>>[0],\n    ): Promise<SendEventOutput<TClientOpts>> => {\n      const hookOutput = await hooks.transformOutput?.(arg);\n      return {\n        ...arg.result,\n        ...hookOutput?.result,\n        // 🤮\n      } as unknown as SendEventOutput<TClientOpts>;\n    };\n\n    /**\n     * It can be valid for a user to send an empty list of events; if this\n     * happens, show a warning that this may not be intended, but don't throw.\n     */\n    if (!payloads.length) {\n      console.warn(\n        prettyError({\n          type: \"warn\",\n          whatHappened: \"`inngest.send()` called with no events\",\n          reassurance:\n            \"This is not an error, but you may not have intended to do this.\",\n          consequences:\n            \"The returned promise will resolve, but no events have been sent to Inngest.\",\n          stack: true,\n        }),\n      );\n\n      return await applyHookToOutput({ result: { ids: [] } });\n    }\n\n    // When sending events, check if the dev server is available.  If so, use the\n    // dev server.\n    let url = this.sendEventUrl.href;\n\n    /**\n     * If in prod mode and key is not present, fail now.\n     */\n    if (this.mode.isCloud && !this.eventKeySet()) {\n      throw new Error(\n        prettyError({\n          whatHappened: \"Failed to send event\",\n          consequences: \"Your event or events were not sent to Inngest.\",\n          why: \"We couldn't find an event key to use to send events to Inngest.\",\n          toFixNow: fixEventKeyMissingSteps,\n        }),\n      );\n    }\n\n    /**\n     * If dev mode has been inferred, try to hit the dev server first to see if\n     * it exists. If it does, use it, otherwise fall back to whatever server we\n     * have configured.\n     *\n     * `INNGEST_BASE_URL` is used to set both dev server and prod URLs, so if a\n     * user has set this it means they have already chosen a URL to hit.\n     */\n    if (this.mode.isDev && this.mode.isInferred && !this.eventBaseUrl) {\n      const devAvailable = await devServerAvailable(\n        defaultDevServerHost,\n        this.fetch,\n      );\n\n      if (devAvailable) {\n        url = devServerUrl(defaultDevServerHost, `e/${this.eventKey}`).href;\n      }\n    }\n\n    const body = await retryWithBackoff(\n      async () => {\n        let rawBody: unknown;\n        let body: SendEventResponse | undefined;\n\n        // We don't need to do fallback auth here because this uses event keys and\n        // not signing keys\n        const response = await this.fetch(url, {\n          method: \"POST\",\n          body: stringify(payloads),\n          headers: { ...this.headers, ...headers },\n        });\n\n        try {\n          rawBody = await response.json();\n          body = await sendEventResponseSchema.parseAsync(rawBody);\n        } catch (_err) {\n          throw await this.getResponseError(response, rawBody);\n        }\n\n        if (body.status !== 200 || body.error) {\n          throw await this.getResponseError(response, rawBody, body.error);\n        }\n\n        return body;\n      },\n      {\n        maxAttempts,\n        baseDelay: 100,\n      },\n    );\n\n    return await applyHookToOutput({ result: { ids: body.ids } });\n  }\n\n  public createFunction: Inngest.CreateFunction<this> = (\n    rawOptions,\n    rawTrigger,\n    handler,\n  ) => {\n    const fn = this._createFunction(rawOptions, rawTrigger, handler);\n\n    this.localFns.push(fn);\n\n    return fn;\n  };\n\n  public get funcs() {\n    return this.localFns;\n  }\n\n  private _createFunction: Inngest.CreateFunction<this> = (\n    rawOptions,\n    rawTrigger,\n    handler,\n  ) => {\n    const options = this.sanitizeOptions(rawOptions);\n    const triggers = this.sanitizeTriggers(rawTrigger);\n\n    return new InngestFunction(\n      this,\n      {\n        ...options,\n        triggers,\n      },\n      handler,\n    );\n  };\n\n  /**\n   * Runtime-only validation.\n   */\n  private sanitizeOptions<T extends InngestFunction.Options>(options: T): T {\n    if (Object.hasOwn(options, \"fns\")) {\n      // v2 -> v3 migration warning\n      console.warn(\n        `${logPrefix} InngestFunction: \\`fns\\` option has been deprecated in v3; use \\`middleware\\` instead. See https://www.inngest.com/docs/sdk/migration`,\n      );\n    }\n\n    if (typeof options === \"string\") {\n      // v2 -> v3 runtime migraton warning\n      console.warn(\n        `${logPrefix} InngestFunction: Creating a function with a string as the first argument has been deprecated in v3; pass an object instead. See https://www.inngest.com/docs/sdk/migration`,\n      );\n\n      return { id: options as string } as T;\n    }\n\n    return options;\n  }\n\n  /**\n   * Runtime-only validation.\n   */\n  private sanitizeTriggers<\n    T extends SingleOrArray<InngestFunction.Trigger<string>>,\n  >(triggers: T): AsArray<T> {\n    if (typeof triggers === \"string\") {\n      // v2 -> v3 migration warning\n      console.warn(\n        `${logPrefix} InngestFunction: Creating a function with a string as the second argument has been deprecated in v3; pass an object instead. See https://www.inngest.com/docs/sdk/migration`,\n      );\n\n      return [{ event: triggers as string }] as AsArray<T>;\n    }\n\n    if (!Array.isArray(triggers)) {\n      return [triggers] as AsArray<T>;\n    }\n\n    return triggers as AsArray<T>;\n  }\n}\n\n/**\n * Default middleware that is included in every client, placed after the user's\n * middleware on the client but before function-level middleware.\n *\n * It is defined here to ensure that comments are included in the generated TS\n * definitions. Without this, we infer the stack of built-in middleware without\n * comments, losing a lot of value.\n *\n * If this is moved, please ensure that using this package in another project\n * can correctly access comments on mutated input and output.\n *\n * This return pattern mimics the output of a `satisfies` suffix; it's used as\n * we support versions of TypeScript prior to the introduction of `satisfies`.\n */\nexport const builtInMiddleware = (<T extends InngestMiddleware.Stack>(\n  m: T,\n): T => m)([\n  new InngestMiddleware({\n    name: \"Inngest: Logger\",\n    init({ client }) {\n      return {\n        onFunctionRun(arg) {\n          const { ctx } = arg;\n\n          const metadata = {\n            runID: ctx.runId,\n            eventName: ctx.event.name,\n            functionName: arg.fn.name,\n          };\n\n          let providedLogger: Logger = client[\"logger\"];\n          // create a child logger if the provided logger has child logger implementation\n          try {\n            if (\"child\" in providedLogger) {\n              type ChildLoggerFn = (\n                metadata: Record<string, unknown>,\n              ) => Logger;\n              providedLogger = (providedLogger.child as ChildLoggerFn)(\n                metadata,\n              );\n            }\n          } catch (err) {\n            console.error('failed to create \"childLogger\" with error: ', err);\n            // no-op\n          }\n          const logger = new ProxyLogger(providedLogger);\n\n          return {\n            transformInput() {\n              return {\n                ctx: {\n                  /**\n                   * The passed in logger from the user.\n                   * Defaults to a console logger if not provided.\n                   */\n                  logger: logger as Logger,\n                },\n              };\n            },\n            beforeExecution() {\n              logger.enable();\n            },\n            transformOutput({ result: { error } }) {\n              if (error) {\n                logger.error(error);\n              }\n            },\n            async beforeResponse() {\n              await logger.flush();\n            },\n          };\n        },\n      };\n    },\n  }),\n]);\n\n/**\n * A client used to interact with the Inngest API by sending or reacting to\n * events.\n *\n * To provide event typing, see {@link EventSchemas}.\n *\n * ```ts\n * const inngest = new Inngest({ name: \"My App\" });\n *\n * // or to provide event typing too\n * const inngest = new Inngest({\n *   name: \"My App\",\n *   schemas: new EventSchemas().fromRecord<{\n *     \"app/user.created\": {\n *       data: { userId: string };\n *     };\n *   }>(),\n * });\n * ```\n *\n * @public\n */\nexport namespace Inngest {\n  export const Tag = \"Inngest.App\" as const;\n\n  /**\n   * Represents any `Inngest` instance, regardless of generics and inference.\n   *\n   * Prefer use of `Inngest.Like` where possible to ensure compatibility with\n   * multiple versions.\n   */\n  export type Any = Inngest;\n\n  /**\n   * References any `Inngest` instance across library versions, useful for use\n   * in public APIs to ensure compatibility with multiple versions.\n   *\n   * Prefer use of `Inngest.Any` internally and `Inngest.Like` for public APIs.\n   */\n  export interface Like {\n    readonly [Symbol.toStringTag]: typeof Inngest.Tag;\n  }\n\n  export type CreateFunction<TClient extends Inngest.Any> = <\n    TMiddleware extends InngestMiddleware.Stack,\n    TTrigger extends SingleOrArray<\n      InngestFunction.Trigger<TriggersFromClient<TClient>>\n    >,\n    THandler extends Handler.Any = Handler<\n      TClient,\n      EventNameFromTrigger<GetEvents<TClient, true>, AsArray<TTrigger>[number]>,\n      ExtendWithMiddleware<\n        [\n          typeof builtInMiddleware,\n          NonNullable<ClientOptionsFromInngest<TClient>[\"middleware\"]>,\n          TMiddleware,\n        ]\n      >\n    >,\n    TFailureHandler extends Handler.Any = Handler<\n      TClient,\n      EventNameFromTrigger<GetEvents<TClient, true>, AsArray<TTrigger>[number]>,\n      ExtendWithMiddleware<\n        [\n          typeof builtInMiddleware,\n          NonNullable<ClientOptionsFromInngest<TClient>[\"middleware\"]>,\n          TMiddleware,\n        ],\n        FailureEventArgs<\n          GetEvents<TClient, true>[EventNameFromTrigger<\n            GetEvents<TClient, true>,\n            AsArray<TTrigger>[number]\n          >]\n        >\n      >\n    >,\n  >(\n    options: Omit<\n      InngestFunction.Options<\n        TClient,\n        TMiddleware,\n        AsArray<TTrigger>,\n        TFailureHandler\n      >,\n      \"triggers\"\n    >,\n    trigger: TTrigger,\n    handler: THandler,\n  ) => InngestFunction<\n    Omit<\n      InngestFunction.Options<\n        TClient,\n        TMiddleware,\n        AsArray<TTrigger>,\n        TFailureHandler\n      >,\n      \"triggers\"\n    >,\n    THandler,\n    TFailureHandler,\n    TClient,\n    TMiddleware,\n    AsArray<TTrigger>\n  >;\n}\n\n/**\n * A helper type to extract the type of a set of event tooling from a given\n * Inngest instance and optionally a trigger.\n *\n * @example Get generic step tools for an Inngest instance.\n * ```ts\n * type StepTools = GetStepTools<typeof inngest>;\n * ```\n *\n * @example Get step tools with a trigger, ensuring tools like `waitForEvent` are typed.\n * ```ts\n * type StepTools = GetStepTools<typeof Inngest, \"github/pull_request\">;\n * ```\n *\n * @public\n */\nexport type GetStepTools<\n  TInngest extends Inngest.Any,\n  TTrigger extends keyof GetEvents<TInngest> &\n    string = keyof GetEvents<TInngest> & string,\n> = GetFunctionInput<TInngest, TTrigger> extends { step: infer TStep }\n  ? TStep\n  : never;\n\n/**\n * A helper type to extract the type of the input to a function from a given\n * Inngest instance and optionally a trigger.\n *\n * @example Get generic function input for an Inngest instance.\n * ```ts\n * type Input = GetFunctionInput<typeof inngest>;\n * ```\n *\n * @example Get function input with a trigger, ensuring tools like `waitForEvent` are typed.\n * ```ts\n * type Input = GetFunctionInput<typeof Inngest, \"github/pull_request\">;\n * ```\n *\n * @public\n */\nexport type GetFunctionInput<\n  TClient extends Inngest.Any,\n  TTrigger extends TriggersFromClient<TClient> = TriggersFromClient<TClient>,\n> = Parameters<\n  // Handler<\n  //   ClientOptionsFromInngest<TInngest>,\n  //   GetEvents<TInngest, true>,\n  //   TTrigger,\n  //   ExtendWithMiddleware<\n  //     [\n  //       typeof builtInMiddleware,\n  //       NonNullable<ClientOptionsFromInngest<TInngest>[\"middleware\"]>,\n  //     ]\n  //   >\n  // >\n  Handler<\n    TClient,\n    TTrigger,\n    ExtendWithMiddleware<\n      [\n        typeof builtInMiddleware,\n        NonNullable<ClientOptionsFromInngest<TClient>[\"middleware\"]>,\n      ]\n    >\n  >\n>[0];\n\n/**\n * A helper type to extract the type of the output of an Inngest function.\n *\n * @example Get a function's output\n * ```ts\n * type Output = GetFunctionOutput<typeof myFunction>;\n * ```\n *\n * @public\n */\nexport type GetFunctionOutput<\n  TFunction extends InvokeTargetFunctionDefinition,\n> = TFunction extends InngestFunction.Any\n  ? GetFunctionOutputFromInngestFunction<TFunction>\n  : TFunction extends InngestFunctionReference.Any\n    ? GetFunctionOutputFromReferenceInngestFunction<TFunction>\n    : unknown;\n\n/**\n * A helper type to extract the type of the output of an Inngest function.\n *\n * Used internally for {@link GetFunctionOutput}. Code outside of this package\n * should use {@link GetFunctionOutput} instead.\n *\n * @internal\n */\nexport type GetFunctionOutputFromInngestFunction<\n  TFunction extends InngestFunction.Any,\n  // biome-ignore lint/suspicious/noExplicitAny: <explanation>\n> = TFunction extends InngestFunction<any, infer IHandler, any, any, any, any>\n  ? IsNever<SimplifyDeep<Jsonify<Awaited<ReturnType<IHandler>>>>> extends true\n    ? null\n    : SimplifyDeep<Jsonify<Awaited<ReturnType<IHandler>>>>\n  : unknown;\n\n/**\n * A helper type to extract the type of the output of a referenced Inngest\n * function.\n *\n * Used internally for {@link GetFunctionOutput}. Code outside of this package\n * should use {@link GetFunctionOutput} instead.\n *\n * @internal\n */\nexport type GetFunctionOutputFromReferenceInngestFunction<\n  TFunction extends InngestFunctionReference.Any,\n  // biome-ignore lint/suspicious/noExplicitAny: <explanation>\n> = TFunction extends InngestFunctionReference<any, infer IOutput>\n  ? IsNever<SimplifyDeep<Jsonify<IOutput>>> extends true\n    ? null\n    : SimplifyDeep<Jsonify<IOutput>>\n  : unknown;\n\n/**\n * When passed an Inngest client, will return all event types for that client.\n *\n * It's recommended to use this instead of directly reusing your event types, as\n * Inngest will add extra properties and internal events such as `ts` and\n * `inngest/function.finished`.\n *\n * @example\n * ```ts\n * import { EventSchemas, Inngest, type GetEvents } from \"inngest\";\n *\n * export const inngest = new Inngest({\n *   id: \"example-app\",\n *   schemas: new EventSchemas().fromRecord<{\n *     \"app/user.created\": { data: { userId: string } };\n *   }>(),\n * });\n *\n * type Events = GetEvents<typeof inngest>;\n * type AppUserCreated = Events[\"app/user.created\"];\n *\n * ```\n *\n * @public\n */\nexport type GetEvents<\n  TInngest extends Inngest.Any,\n  TWithInternal extends boolean = false,\n> = TWithInternal extends true\n  ? EventsFromOpts<ClientOptionsFromInngest<TInngest>>\n  : WithoutInternal<EventsFromOpts<ClientOptionsFromInngest<TInngest>>>;\n\n/**\n * A helper type to extract the inferred options from a given Inngest instance.\n *\n * @example\n * ```ts\n * type Options = ClientOptionsFromInngest<typeof inngest>;\n * ```\n *\n * @public\n */\n\nexport type ClientOptionsFromInngest<TInngest extends Inngest.Any> =\n  TInngest extends Inngest<infer U> ? U : ClientOptions;\n"],"names":["headers: Record<string, string>","payloads: EventPayload[]","rawBody: unknown","body: SendEventResponse | undefined","body","providedLogger: Logger"],"mappings":"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","debugId":null}}]
}