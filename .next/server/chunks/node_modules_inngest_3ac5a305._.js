module.exports = [
"[project]/node_modules/inngest/helpers/promises.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __await = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__await || function(v) {
    return this instanceof __await ? (this.v = v, this) : new __await(v);
};
var __asyncGenerator = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__asyncGenerator || function(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = Object.create((typeof AsyncIterator === "function" ? AsyncIterator : Object).prototype), verb("next"), verb("throw"), verb("return", awaitReturn), i[Symbol.asyncIterator] = function() {
        return this;
    }, i;
    //TURBOPACK unreachable
    ;
    function awaitReturn(f) {
        return function(v) {
            return Promise.resolve(v).then(f, reject);
        };
    }
    function verb(n, f) {
        if (g[n]) {
            i[n] = function(v) {
                return new Promise(function(a, b) {
                    q.push([
                        n,
                        v,
                        a,
                        b
                    ]) > 1 || resume(n, v);
                });
            };
            if (f) i[n] = f(i[n]);
        }
    }
    function resume(n, v) {
        try {
            step(g[n](v));
        } catch (e) {
            settle(q[0][3], e);
        }
    }
    function step(r) {
        r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
    }
    function fulfill(value) {
        resume("next", value);
    }
    function reject(value) {
        resume("throw", value);
    }
    function settle(f, v) {
        if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);
    }
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.retryWithBackoff = exports.resolveNextTick = exports.runAsPromise = exports.createTimeoutPromise = exports.createDeferredPromiseWithStack = exports.createDeferredPromise = exports.resolveAfterPending = exports.createFrozenPromise = void 0;
/**
 * Some environments don't allow access to the global queueMicrotask(). While we
 * had assumed this was only true for those powered by earlier versions of Node
 * (<14) that we don't officially support, Vercel's Edge Functions also obscure
 * the function in dev, even though the platform it's based on (Cloudflare
 * Workers) appropriately exposes it. Even worse, production Vercel Edge
 * Functions can see the function, but it immediately blows up the function when
 * used.
 *
 * Therefore, we can fall back to a reasonable alternative of
 * `Promise.resolve().then(fn)` instead. This _may_ be slightly slower in modern
 * environments, but at least we can still work in these environments.
 */ const shimQueueMicrotask = (callback)=>{
    void Promise.resolve().then(callback);
};
/**
 * A helper function to create a `Promise` that will never settle.
 *
 * It purposefully creates no references to `resolve` or `reject` so that the
 * returned `Promise` will remain unsettled until it falls out of scope and is
 * garbage collected.
 *
 * This should be used within transient closures to fake asynchronous action, so
 * long as it's guaranteed that they will fall out of scope.
 */ const createFrozenPromise = ()=>{
    return new Promise(()=>undefined);
};
exports.createFrozenPromise = createFrozenPromise;
/**
 * Returns a Promise that resolves after the current event loop's microtasks
 * have finished, but before the next event loop tick.
 */ const resolveAfterPending = (count = 100)=>{
    /**
     * This uses a brute force implementation that will continue to enqueue
     * microtasks 10 times before resolving. This is to ensure that the microtask
     * queue is drained, even if the microtask queue is being manipulated by other
     * code.
     *
     * While this still doesn't guarantee that the microtask queue is drained,
     * it's our best bet for giving other non-controlled promises a chance to
     * resolve before we continue without resorting to falling in to the next
     * tick.
     */ return new Promise((resolve)=>{
        let i = 0;
        const iterate = ()=>{
            shimQueueMicrotask(()=>{
                if (i++ > count) {
                    return resolve();
                }
                iterate();
            });
        };
        iterate();
    });
};
exports.resolveAfterPending = resolveAfterPending;
/**
 * Creates and returns Promise that can be resolved or rejected with the
 * returned `resolve` and `reject` functions.
 *
 * Resolving or rejecting the function will return a new set of Promise control
 * functions. These can be ignored if the original Promise is all that's needed.
 */ const createDeferredPromise = ()=>{
    let resolve;
    let reject;
    const promise = new Promise((_resolve, _reject)=>{
        resolve = (value)=>{
            _resolve(value);
            return (0, exports.createDeferredPromise)();
        };
        reject = (reason)=>{
            _reject(reason);
            return (0, exports.createDeferredPromise)();
        };
    });
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    return {
        promise,
        resolve: resolve,
        reject: reject
    };
};
exports.createDeferredPromise = createDeferredPromise;
/**
 * Creates and returns a deferred Promise that can be resolved or rejected with
 * the returned `resolve` and `reject` functions.
 *
 * For each Promise resolved or rejected this way, this will also keep a stack
 * of all unhandled Promises, resolved or rejected.
 *
 * Once a Promise is read, it is removed from the stack.
 */ const createDeferredPromiseWithStack = ()=>{
    const settledPromises = [];
    let rotateQueue = ()=>{};
    const results = function() {
        return __asyncGenerator(this, arguments, function*() {
            while(true){
                const next = settledPromises.shift();
                if (next) {
                    yield yield __await(next);
                } else {
                    yield __await(new Promise((resolve)=>{
                        rotateQueue = resolve;
                    }));
                }
            }
        });
    }();
    const shimDeferredPromise = (deferred)=>{
        const originalResolve = deferred.resolve;
        const originalReject = deferred.reject;
        deferred.resolve = (value)=>{
            settledPromises.push(deferred.promise);
            rotateQueue();
            return shimDeferredPromise(originalResolve(value));
        };
        deferred.reject = (reason)=>{
            settledPromises.push(deferred.promise);
            rotateQueue();
            return shimDeferredPromise(originalReject(reason));
        };
        return deferred;
    };
    const deferred = shimDeferredPromise((0, exports.createDeferredPromise)());
    return {
        deferred,
        results
    };
};
exports.createDeferredPromiseWithStack = createDeferredPromiseWithStack;
/**
 * Creates a Promise that will resolve after the given duration, along with
 * methods to start, clear, and reset the timeout.
 */ const createTimeoutPromise = (duration)=>{
    const { promise, resolve } = (0, exports.createDeferredPromise)();
    let timeout;
    // eslint-disable-next-line prefer-const
    let ret;
    const start = ()=>{
        if (timeout) return ret;
        timeout = setTimeout(()=>{
            resolve();
        }, duration);
        return ret;
    };
    const clear = ()=>{
        clearTimeout(timeout);
        timeout = undefined;
    };
    const reset = ()=>{
        clear();
        return start();
    };
    ret = Object.assign(promise, {
        start,
        clear,
        reset
    });
    return ret;
};
exports.createTimeoutPromise = createTimeoutPromise;
/**
 * Take any function and safely promisify such that both synchronous and
 * asynchronous errors are caught and returned as a rejected Promise.
 *
 * The passed `fn` can be undefined to support functions that may conditionally
 * be defined.
 */ // eslint-disable-next-line @typescript-eslint/no-explicit-any
const runAsPromise = (fn)=>{
    // eslint-disable-next-line @typescript-eslint/no-unsafe-return
    return Promise.resolve().then(fn);
};
exports.runAsPromise = runAsPromise;
/**
 * Returns a Promise that resolve after the current event loop tick.
 */ const resolveNextTick = ()=>{
    return new Promise((resolve)=>setTimeout(resolve));
};
exports.resolveNextTick = resolveNextTick;
const retryWithBackoff = async (fn, opts)=>{
    var _a;
    const maxAttempts = (opts === null || opts === void 0 ? void 0 : opts.maxAttempts) || 5;
    const baseDelay = (_a = opts === null || opts === void 0 ? void 0 : opts.baseDelay) !== null && _a !== void 0 ? _a : 100;
    for(let attempt = 1; attempt <= maxAttempts; attempt++){
        try {
            return await fn();
        } catch (err) {
            if (attempt >= maxAttempts) {
                throw err;
            }
            const jitter = Math.random() * baseDelay;
            const delay = baseDelay * Math.pow(2, attempt - 1) + jitter;
            await new Promise((resolve)=>setTimeout(resolve, delay));
        }
    }
    throw new Error("Max retries reached; this should be unreachable.");
};
exports.retryWithBackoff = retryWithBackoff; //# sourceMappingURL=promises.js.map
}),
"[project]/node_modules/inngest/helpers/ServerTiming.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ServerTiming = void 0;
const promises_js_1 = __turbopack_context__.r("[project]/node_modules/inngest/helpers/promises.js [app-route] (ecmascript)");
/**
 * A class to manage timing functions and arbitrary periods of time before
 * generating a `Server-Timing` header for use in HTTP responses.
 *
 * This is a very simple implementation that does not support nested timings or
 * fractions of a millisecond.
 */ class ServerTiming {
    constructor(){
        this.timings = {};
    }
    /**
     * Start a timing. Returns a function that, when called, will stop the timing
     * and add it to the header.
     */ start(name, description) {
        if (!this.timings[name]) {
            this.timings[name] = {
                description: description !== null && description !== void 0 ? description : "",
                timers: []
            };
        }
        const index = this.timings[name].timers.push({
            start: Date.now()
        }) - 1;
        return ()=>{
            const target = this.timings[name];
            if (!target) {
                return console.warn(`Timing "${name}" does not exist`);
            }
            const timer = target.timers[index];
            if (!timer) {
                return console.warn(`Timer ${index} for timing "${name}" does not exist`);
            }
            timer.end = Date.now();
        };
    }
    /**
     * Add a piece of arbitrary, untimed information to the header. Common use
     * cases would be cache misses.
     *
     * @example
     * ```
     * timer.append("cache", "miss");
     * ```
     */ append(key, value) {
        this.timings[key] = {
            description: value,
            timers: []
        };
    }
    /**
     * Wrap a function in a timing. The timing will be stopped and added to the
     * header when the function resolves or rejects.
     *
     * The return value of the function will be returned from this function.
     */ async wrap(name, fn, description) {
        const stop = this.start(name, description);
        try {
            return await (0, promises_js_1.runAsPromise)(fn);
        } finally{
            stop();
        }
    }
    /**
     * Generate the `Server-Timing` header.
     */ getHeader() {
        const entries = Object.entries(this.timings).reduce((acc, [name, { description, timers }])=>{
            /**
             * Ignore timers that had no end.
             */ const hasTimersWithEnd = timers.some((timer)=>timer.end);
            if (!hasTimersWithEnd) {
                return acc;
            }
            const dur = timers.reduce((acc, { start, end })=>{
                if (!start || !end) return acc;
                return acc + (end - start);
            }, 0);
            const entry = [
                name,
                description ? `desc="${description}"` : "",
                dur ? `dur=${dur}` : ""
            ].filter(Boolean).join(";");
            return [
                ...acc,
                entry
            ];
        }, []);
        return entries.join(", ");
    }
}
exports.ServerTiming = ServerTiming; //# sourceMappingURL=ServerTiming.js.map
}),
"[project]/node_modules/inngest/helpers/consts.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __importDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.syncKind = exports.serverKind = exports.dummyEventKey = exports.debugPrefix = exports.logPrefix = exports.internalEvents = exports.defaultDevServerHost = exports.defaultInngestEventBaseUrl = exports.defaultInngestApiBaseUrl = exports.headerKeys = exports.envKeys = exports.probe = exports.queryKeys = void 0;
const chalk_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/chalk/source/index.js [app-route] (ecmascript)"));
/**
 * Keys for accessing query parameters included in requests from Inngest to run
 * functions.
 *
 * Used internally to create handlers using `InngestCommHandler`, but can be
 * imported to be used if creating a custom handler outside of the package.
 *
 * @public
 */ var queryKeys;
(function(queryKeys) {
    queryKeys["DeployId"] = "deployId";
    queryKeys["FnId"] = "fnId";
    queryKeys["Probe"] = "probe";
    queryKeys["StepId"] = "stepId";
})(queryKeys || (exports.queryKeys = queryKeys = {}));
var probe;
(function(probe) {
    probe["Trust"] = "trust";
})(probe || (exports.probe = probe = {}));
var envKeys;
(function(envKeys) {
    envKeys["InngestSigningKey"] = "INNGEST_SIGNING_KEY";
    envKeys["InngestSigningKeyFallback"] = "INNGEST_SIGNING_KEY_FALLBACK";
    envKeys["InngestEventKey"] = "INNGEST_EVENT_KEY";
    /**
     * @deprecated Removed in v3. Use {@link InngestBaseUrl} instead.
     */ envKeys["InngestDevServerUrl"] = "INNGEST_DEVSERVER_URL";
    envKeys["InngestEnvironment"] = "INNGEST_ENV";
    envKeys["InngestBaseUrl"] = "INNGEST_BASE_URL";
    envKeys["InngestEventApiBaseUrl"] = "INNGEST_EVENT_API_BASE_URL";
    envKeys["InngestApiBaseUrl"] = "INNGEST_API_BASE_URL";
    envKeys["InngestServeHost"] = "INNGEST_SERVE_HOST";
    envKeys["InngestServePath"] = "INNGEST_SERVE_PATH";
    envKeys["InngestLogLevel"] = "INNGEST_LOG_LEVEL";
    envKeys["InngestStreaming"] = "INNGEST_STREAMING";
    envKeys["InngestDevMode"] = "INNGEST_DEV";
    envKeys["InngestAllowInBandSync"] = "INNGEST_ALLOW_IN_BAND_SYNC";
    /**
     * @deprecated It's unknown what this env var was used for, but we do not
     * provide explicit support for it. Prefer using `INNGEST_ENV` instead.
     */ envKeys["BranchName"] = "BRANCH_NAME";
    /**
     * The git branch of the commit the deployment was triggered by. Example:
     * `improve-about-page`.
     *
     * {@link https://vercel.com/docs/concepts/projects/environment-variables/system-environment-variables#system-environment-variables}
     */ envKeys["VercelBranch"] = "VERCEL_GIT_COMMIT_REF";
    /**
     * Expected to be `"1"` if defined.
     */ envKeys["IsVercel"] = "VERCEL";
    /**
     * The branch name of the current deployment. May only be accessible at build
     * time, but included here just in case.
     *
     * {@link https://developers.cloudflare.com/pages/platform/build-configuration/#environment-variables}
     */ envKeys["CloudflarePagesBranch"] = "CF_PAGES_BRANCH";
    /**
     * Expected to be `"1"` if defined.
     */ envKeys["IsCloudflarePages"] = "CF_PAGES";
    /**
     * The branch name of the deployment from Git to Netlify, if available.
     *
     * {@link https://docs.netlify.com/configure-builds/environment-variables/#git-metadata}
     */ envKeys["NetlifyBranch"] = "BRANCH";
    /**
     * Expected to be `"true"` if defined.
     */ envKeys["IsNetlify"] = "NETLIFY";
    /**
     * The Git branch for a service or deploy.
     *
     * {@link https://render.com/docs/environment-variables#all-services}
     */ envKeys["RenderBranch"] = "RENDER_GIT_BRANCH";
    /**
     * Expected to be `"true"` if defined.
     */ envKeys["IsRender"] = "RENDER";
    /**
     * The branch that triggered the deployment. Example: `main`
     *
     * {@link https://docs.railway.app/develop/variables#railway-provided-variables}
     */ envKeys["RailwayBranch"] = "RAILWAY_GIT_BRANCH";
    /**
     * The railway environment for the deployment. Example: `production`
     *
     * {@link https://docs.railway.app/develop/variables#railway-provided-variables}
     */ envKeys["RailwayEnvironment"] = "RAILWAY_ENVIRONMENT";
    envKeys["VercelEnvKey"] = "VERCEL_ENV";
    envKeys["OpenAiApiKey"] = "OPENAI_API_KEY";
    envKeys["GeminiApiKey"] = "GEMINI_API_KEY";
    envKeys["AnthropicApiKey"] = "ANTHROPIC_API_KEY";
})(envKeys || (exports.envKeys = envKeys = {}));
/**
 * Keys for accessing headers included in requests from Inngest to run
 * functions.
 *
 * Used internally to create handlers using `InngestCommHandler`, but can be
 * imported to be used if creating a custom handler outside of the package.
 *
 * @public
 */ var headerKeys;
(function(headerKeys) {
    headerKeys["ContentLength"] = "content-length";
    headerKeys["Signature"] = "x-inngest-signature";
    headerKeys["SdkVersion"] = "x-inngest-sdk";
    headerKeys["Environment"] = "x-inngest-env";
    headerKeys["Platform"] = "x-inngest-platform";
    headerKeys["Framework"] = "x-inngest-framework";
    headerKeys["NoRetry"] = "x-inngest-no-retry";
    headerKeys["RequestVersion"] = "x-inngest-req-version";
    headerKeys["RetryAfter"] = "retry-after";
    headerKeys["InngestServerKind"] = "x-inngest-server-kind";
    headerKeys["InngestExpectedServerKind"] = "x-inngest-expected-server-kind";
    headerKeys["InngestSyncKind"] = "x-inngest-sync-kind";
    headerKeys["EventIdSeed"] = "x-inngest-event-id-seed";
    headerKeys["TraceParent"] = "traceparent";
    headerKeys["TraceState"] = "tracestate";
})(headerKeys || (exports.headerKeys = headerKeys = {}));
exports.defaultInngestApiBaseUrl = "https://api.inngest.com/";
exports.defaultInngestEventBaseUrl = "https://inn.gs/";
exports.defaultDevServerHost = "http://localhost:8288/";
/**
 * Events that Inngest may send internally that can be used to trigger
 * functions.
 *
 * @public
 */ var internalEvents;
(function(internalEvents) {
    /**
     * A function has failed after exhausting all available retries. This event
     * will contain the original event and the error that caused the failure.
     */ internalEvents["FunctionFailed"] = "inngest/function.failed";
    internalEvents["FunctionInvoked"] = "inngest/function.invoked";
    internalEvents["FunctionFinished"] = "inngest/function.finished";
    internalEvents["FunctionCancelled"] = "inngest/function.cancelled";
    internalEvents["ScheduledTimer"] = "inngest/scheduled.timer";
})(internalEvents || (exports.internalEvents = internalEvents = {}));
exports.logPrefix = chalk_1.default.magenta.bold("[Inngest]");
exports.debugPrefix = "inngest";
exports.dummyEventKey = "NO_EVENT_KEY_SET";
var serverKind;
(function(serverKind) {
    serverKind["Dev"] = "dev";
    serverKind["Cloud"] = "cloud";
})(serverKind || (exports.serverKind = serverKind = {}));
var syncKind;
(function(syncKind) {
    syncKind["InBand"] = "in_band";
    syncKind["OutOfBand"] = "out_of_band";
})(syncKind || (exports.syncKind = syncKind = {})); //# sourceMappingURL=consts.js.map
}),
"[project]/node_modules/inngest/version.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.version = void 0;
// Generated by genversion.
exports.version = "3.40.3"; //# sourceMappingURL=version.js.map
}),
"[project]/node_modules/inngest/helpers/strings.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __importDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.hashSigningKey = exports.hashEventKey = exports.stringifyUnknown = exports.timeStr = exports.slugify = exports.stringify = void 0;
const hash_js_1 = __turbopack_context__.r("[project]/node_modules/hash.js/lib/hash.js [app-route] (ecmascript)");
const json_stringify_safe_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/json-stringify-safe/stringify.js [app-route] (ecmascript)"));
const ms_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/ms/index.js [app-route] (ecmascript)"));
/**
 * Safely `JSON.stringify()` an `input`, handling circular refernences and
 * removing `BigInt` values.
 */ // eslint-disable-next-line @typescript-eslint/no-explicit-any
const stringify = (input)=>{
    return (0, json_stringify_safe_1.default)(input, (key, value)=>{
        if (typeof value !== "bigint") {
            // eslint-disable-next-line @typescript-eslint/no-unsafe-return
            return value;
        }
    });
};
exports.stringify = stringify;
/**
 * Returns a slugified string used to generate consistent IDs.
 *
 * This can be used to generate a consistent ID for a function when migrating
 * from v2 to v3 of the SDK.
 *
 * @public
 */ const slugify = (str)=>{
    const join = "-";
    return str.toLowerCase().replace(/[^a-z0-9-]+/g, join).replace(/-+/g, join).split(join).filter(Boolean).join(join);
};
exports.slugify = slugify;
const millisecond = 1;
const second = millisecond * 1000;
const minute = second * 60;
const hour = minute * 60;
const day = hour * 24;
const week = day * 7;
/**
 * A collection of periods in milliseconds and their suffixes used when creating
 * time strings.
 */ const periods = [
    [
        "w",
        week
    ],
    [
        "d",
        day
    ],
    [
        "h",
        hour
    ],
    [
        "m",
        minute
    ],
    [
        "s",
        second
    ]
];
/**
 * Convert a given `Date`, `number`, or `ms`-compatible `string` to a
 * Inngest sleep-compatible time string (e.g. `"1d"` or `"2h3010s"`).
 *
 * Can optionally provide a `now` date to use as the base for the calculation,
 * otherwise a new date will be created on invocation.
 */ const timeStr = (/**
 * The future date to use to convert to a time string.
 */ input)=>{
    if (input instanceof Date) {
        return input.toISOString();
    }
    const milliseconds = typeof input === "string" ? (0, ms_1.default)(input) : input;
    const [, timeStr] = periods.reduce(([num, str], [suffix, period])=>{
        const numPeriods = Math.floor(num / period);
        if (numPeriods > 0) {
            return [
                num % period,
                `${str}${numPeriods}${suffix}`
            ];
        }
        return [
            num,
            str
        ];
    }, [
        milliseconds,
        ""
    ]);
    return timeStr;
};
exports.timeStr = timeStr;
/**
 * Given an unknown input, stringify it if it's a boolean, a number, or a
 * string, else return `undefined`.
 */ const stringifyUnknown = (input)=>{
    if (typeof input === "boolean" || typeof input === "number" || typeof input === "string") {
        return input.toString();
    }
};
exports.stringifyUnknown = stringifyUnknown;
const hashEventKey = (eventKey)=>{
    return (0, hash_js_1.sha256)().update(eventKey).digest("hex");
};
exports.hashEventKey = hashEventKey;
const hashSigningKey = (signingKey)=>{
    var _a;
    if (!signingKey) {
        return "";
    }
    const prefix = ((_a = signingKey.match(/^signkey-[\w]+-/)) === null || _a === void 0 ? void 0 : _a.shift()) || "";
    const key = signingKey.replace(/^signkey-[\w]+-/, "");
    // Decode the key from its hex representation into a bytestream
    return `${prefix}${(0, hash_js_1.sha256)().update(key, "hex").digest("hex")}`;
};
exports.hashSigningKey = hashSigningKey; //# sourceMappingURL=strings.js.map
}),
"[project]/node_modules/inngest/helpers/env.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// This file exists to help normalize process.env amongst the backend
// and frontend.  Many frontends (eg. Next, CRA) utilize webpack's DefinePlugin
// along with prefixes, meaning we have to explicitly use the full `process.env.FOO`
// string in order to read variables.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.parseAsBoolean = exports.getResponse = exports.getFetch = exports.platformSupportsStreaming = exports.getPlatformName = exports.inngestHeaders = exports.allProcessEnv = exports.processEnv = exports.getEnvironmentName = exports.getMode = exports.Mode = exports.devServerHost = void 0;
const version_js_1 = __turbopack_context__.r("[project]/node_modules/inngest/version.js [app-route] (ecmascript)");
const consts_js_1 = __turbopack_context__.r("[project]/node_modules/inngest/helpers/consts.js [app-route] (ecmascript)");
const strings_js_1 = __turbopack_context__.r("[project]/node_modules/inngest/helpers/strings.js [app-route] (ecmascript)");
/**
 * devServerHost returns the dev server host by searching for the INNGEST_DEVSERVER_URL
 * environment variable (plus project prefixces for eg. react, such as REACT_APP_INNGEST_DEVSERVER_URL).
 *
 * If not found this returns undefined, indicating that the env var has not been set.
 *
 * @example devServerHost()
 */ const devServerHost = (env = (0, exports.allProcessEnv)())=>{
    // devServerKeys are the env keys we search for to discover the dev server
    // URL.  This includes the standard key first, then includes prefixed keys
    // for use within common frameworks (eg. CRA, next).
    //
    // We have to fully write these using process.env as they're typically
    // processed using webpack's DefinePlugin, which is dumb and does a straight
    // text replacement instead of actually understanding the AST, despite webpack
    // being fully capable of understanding the AST.
    const prefixes = [
        "REACT_APP_",
        "NEXT_PUBLIC_"
    ];
    const keys = [
        consts_js_1.envKeys.InngestBaseUrl,
        consts_js_1.envKeys.InngestDevMode
    ];
    const values = keys.flatMap((key)=>{
        return prefixes.map((prefix)=>{
            return env[prefix + key];
        });
    });
    return values.find((v)=>{
        if (!v) {
            return;
        }
        try {
            return Boolean(new URL(v));
        } catch (_a) {
        // no-op
        }
    });
};
exports.devServerHost = devServerHost;
const checkFns = ((checks)=>checks)({
    equals: (actual, expected)=>actual === expected,
    "starts with": (actual, expected)=>{
        var _a;
        return expected ? (_a = actual === null || actual === void 0 ? void 0 : actual.startsWith(expected)) !== null && _a !== void 0 ? _a : false : false;
    },
    "is truthy": (actual)=>Boolean(actual),
    "is truthy but not": (actual, expected)=>Boolean(actual) && actual !== expected
});
const prodChecks = [
    [
        "CF_PAGES",
        "equals",
        "1"
    ],
    [
        "CONTEXT",
        "starts with",
        "prod"
    ],
    [
        "ENVIRONMENT",
        "starts with",
        "prod"
    ],
    [
        "NODE_ENV",
        "starts with",
        "prod"
    ],
    [
        "VERCEL_ENV",
        "starts with",
        "prod"
    ],
    [
        "DENO_DEPLOYMENT_ID",
        "is truthy"
    ],
    [
        consts_js_1.envKeys.VercelEnvKey,
        "is truthy but not",
        "development"
    ],
    [
        consts_js_1.envKeys.IsNetlify,
        "is truthy"
    ],
    [
        consts_js_1.envKeys.IsRender,
        "is truthy"
    ],
    [
        consts_js_1.envKeys.RailwayBranch,
        "is truthy"
    ],
    [
        consts_js_1.envKeys.IsCloudflarePages,
        "is truthy"
    ]
];
class Mode {
    constructor({ type, isExplicit, explicitDevUrl, env = (0, exports.allProcessEnv)() }){
        this.env = env;
        this.type = type;
        this.isExplicit = isExplicit || Boolean(explicitDevUrl);
        this.explicitDevUrl = explicitDevUrl;
    }
    get isDev() {
        return this.type === "dev";
    }
    get isCloud() {
        return this.type === "cloud";
    }
    get isInferred() {
        return !this.isExplicit;
    }
    /**
     * If we are explicitly in a particular mode, retrieve the URL that we are
     * sure we should be using, not considering any environment variables or other
     * influences.
     */ getExplicitUrl(defaultCloudUrl) {
        if (!this.isExplicit) {
            return undefined;
        }
        if (this.explicitDevUrl) {
            return this.explicitDevUrl.href;
        }
        if (this.isCloud) {
            return defaultCloudUrl;
        }
        if (this.isDev) {
            return consts_js_1.defaultDevServerHost;
        }
        return undefined;
    }
}
exports.Mode = Mode;
/**
 * Returns the mode of the current environment, based off of either passed
 * environment variables or `process.env`, or explicit settings.
 */ const getMode = ({ env = (0, exports.allProcessEnv)(), client, explicitMode } = {})=>{
    if (explicitMode) {
        return new Mode({
            type: explicitMode,
            isExplicit: true,
            env
        });
    }
    if (client === null || client === void 0 ? void 0 : client["mode"].isExplicit) {
        return client["mode"];
    }
    if (consts_js_1.envKeys.InngestDevMode in env) {
        if (typeof env[consts_js_1.envKeys.InngestDevMode] === "string") {
            try {
                const explicitDevUrl = new URL(env[consts_js_1.envKeys.InngestDevMode]);
                return new Mode({
                    type: "dev",
                    isExplicit: true,
                    explicitDevUrl,
                    env
                });
            } catch (_a) {
            // no-op
            }
        }
        const envIsDev = (0, exports.parseAsBoolean)(env[consts_js_1.envKeys.InngestDevMode]);
        if (typeof envIsDev === "boolean") {
            return new Mode({
                type: envIsDev ? "dev" : "cloud",
                isExplicit: true,
                env
            });
        }
    }
    const isProd = prodChecks.some(([key, checkKey, expected])=>{
        return checkFns[checkKey]((0, strings_js_1.stringifyUnknown)(env[key]), expected);
    });
    return new Mode({
        type: isProd ? "cloud" : "dev",
        isExplicit: false,
        env
    });
};
exports.getMode = getMode;
/**
 * getEnvironmentName returns the suspected branch name for this environment by
 * searching through a set of common environment variables.
 *
 * This could be used to determine if we're on a branch deploy or not, though it
 * should be noted that we don't know if this is the default branch or not.
 */ const getEnvironmentName = (env = (0, exports.allProcessEnv)())=>{
    /**
     * Order is important; more than one of these env vars may be set, so ensure
     * that we check the most specific, most reliable env vars first.
     */ return env[consts_js_1.envKeys.InngestEnvironment] || env[consts_js_1.envKeys.BranchName] || env[consts_js_1.envKeys.VercelBranch] || env[consts_js_1.envKeys.NetlifyBranch] || env[consts_js_1.envKeys.CloudflarePagesBranch] || env[consts_js_1.envKeys.RenderBranch] || env[consts_js_1.envKeys.RailwayBranch];
};
exports.getEnvironmentName = getEnvironmentName;
const processEnv = (key)=>{
    return (0, exports.allProcessEnv)()[key];
};
exports.processEnv = processEnv;
/**
 * allProcessEnv returns the current process environment variables, or an empty
 * object if they cannot be read, making sure we support environments other than
 * Node such as Deno, too.
 *
 * Using this ensures we don't dangerously access `process.env` in environments
 * where it may not be defined, such as Deno or the browser.
 */ const allProcessEnv = ()=>{
    // Node, or Node-like environments
    try {
        // eslint-disable-next-line @inngest/internal/process-warn
        if ("TURBOPACK compile-time truthy", 1) {
            // eslint-disable-next-line @inngest/internal/process-warn
            return process.env;
        }
    } catch (_err) {
    // noop
    }
    // Deno
    try {
        const env = Deno.env.toObject();
        if (env) {
            return env;
        }
    } catch (_err) {
    // noop
    }
    // Netlify
    try {
        const env = Netlify.env.toObject();
        if (env) {
            return env;
        }
    } catch (_err) {
    // noop
    }
    return {};
};
exports.allProcessEnv = allProcessEnv;
/**
 * Generate a standardised set of headers based on input and environment
 * variables.
 *
 *
 */ const inngestHeaders = (opts)=>{
    var _a;
    const sdkVersion = `inngest-js:v${version_js_1.version}`;
    const headers = {
        "Content-Type": "application/json",
        "User-Agent": sdkVersion,
        [consts_js_1.headerKeys.SdkVersion]: sdkVersion
    };
    if (opts === null || opts === void 0 ? void 0 : opts.framework) {
        headers[consts_js_1.headerKeys.Framework] = opts.framework;
    }
    if (opts === null || opts === void 0 ? void 0 : opts.expectedServerKind) {
        headers[consts_js_1.headerKeys.InngestExpectedServerKind] = opts.expectedServerKind;
    }
    const env = Object.assign(Object.assign({}, (0, exports.allProcessEnv)()), opts === null || opts === void 0 ? void 0 : opts.env);
    const inngestEnv = (opts === null || opts === void 0 ? void 0 : opts.inngestEnv) || (0, exports.getEnvironmentName)(env);
    if (inngestEnv) {
        headers[consts_js_1.headerKeys.Environment] = inngestEnv;
    }
    const platform = (0, exports.getPlatformName)(env);
    if (platform) {
        headers[consts_js_1.headerKeys.Platform] = platform;
    }
    return Object.assign(Object.assign(Object.assign({}, headers), (_a = opts === null || opts === void 0 ? void 0 : opts.client) === null || _a === void 0 ? void 0 : _a["headers"]), opts === null || opts === void 0 ? void 0 : opts.extras);
};
exports.inngestHeaders = inngestHeaders;
/**
 * A set of checks that, given an environment, will return `true` if the current
 * environment is running on the platform with the given name.
 */ const platformChecks = {
    /**
     * Vercel Edge Functions don't have access to environment variables unless
     * they are explicitly referenced in the top level code, but they do have a
     * global `EdgeRuntime` variable set that we can use to detect this.
     */ vercel: (env)=>env[consts_js_1.envKeys.IsVercel] === "1" || typeof EdgeRuntime === "string",
    netlify: (env)=>env[consts_js_1.envKeys.IsNetlify] === "true",
    "cloudflare-pages": (env)=>env[consts_js_1.envKeys.IsCloudflarePages] === "1",
    render: (env)=>env[consts_js_1.envKeys.IsRender] === "true",
    railway: (env)=>Boolean(env[consts_js_1.envKeys.RailwayEnvironment])
};
/**
 * A set of checks that, given an environment, will return `true` if the current
 * environment and platform supports streaming responses back to Inngest.
 *
 * Streaming capability is both framework and platform-based. Frameworks are
 * supported in serve handlers, and platforms are checked here.
 *
 * As such, this record declares which platforms we explicitly support for
 * streaming and is used by {@link platformSupportsStreaming}.
 */ const streamingChecks = {
    /**
     * "Vercel supports streaming for Serverless Functions, Edge Functions, and
     * React Server Components in Next.js projects."
     *
     * In practice, however, there are many reports of streaming not working as
     * expected on Serverless Functions, so we resort to only allowing streaming
     * for Edge Functions here.
     *
     * See {@link https://vercel.com/docs/frameworks/nextjs#streaming}
     */ vercel: (_framework, _env)=>typeof EdgeRuntime === "string",
    "cloudflare-pages": ()=>true
};
const getPlatformName = (env)=>{
    return Object.keys(platformChecks).find((key)=>{
        return platformChecks[key](env);
    });
};
exports.getPlatformName = getPlatformName;
/**
 * Returns `true` if we believe the current environment supports streaming
 * responses back to Inngest.
 *
 * We run a check directly related to the platform we believe we're running on,
 * usually based on environment variables.
 */ const platformSupportsStreaming = (framework, env = (0, exports.allProcessEnv)())=>{
    var _a, _b;
    return (_b = (_a = streamingChecks[(0, exports.getPlatformName)(env)]) === null || _a === void 0 ? void 0 : _a.call(streamingChecks, framework, env)) !== null && _b !== void 0 ? _b : false;
};
exports.platformSupportsStreaming = platformSupportsStreaming;
/**
 * A unique symbol used to mark a custom fetch implementation. We wrap the
 * implementations to provide some extra control when handling errors.
 */ const CUSTOM_FETCH_MARKER = Symbol("Custom fetch implementation");
/**
 * Given a potential fetch function, return the fetch function to use based on
 * this and the environment.
 */ const getFetch = (givenFetch)=>{
    /**
     * If we've explicitly been given a fetch function, use that.
     */ if (givenFetch) {
        if (CUSTOM_FETCH_MARKER in givenFetch) {
            return givenFetch;
        }
        /**
         * We wrap the given fetch function to provide some extra control when
         * handling errors.
         */ const customFetch = async (...args)=>{
            var _a;
            try {
                return await givenFetch(...args);
            } catch (err) {
                /**
                 * Capture warnings that are not simple fetch failures and highlight
                 * them for the user.
                 *
                 * We also use this opportunity to log the causing error, as code higher
                 * up the stack will likely abstract this.
                 */ if (!(err instanceof Error) || !((_a = err.message) === null || _a === void 0 ? void 0 : _a.startsWith("fetch failed"))) {
                    console.warn("A request failed when using a custom fetch implementation; this may be a misconfiguration. Make sure that your fetch client is correctly bound to the global scope.");
                    console.error(err);
                }
                throw err;
            }
        };
        /**
         * Mark the custom fetch implementation so that we can identify it later, in
         * addition to adding some runtime properties to it to make it seem as much
         * like the original fetch as possible.
         */ Object.defineProperties(customFetch, {
            [CUSTOM_FETCH_MARKER]: {},
            name: {
                value: givenFetch.name
            },
            length: {
                value: givenFetch.length
            }
        });
        return customFetch;
    }
    /**
     * Browser or Node 18+
     */ try {
        if (typeof globalThis !== "undefined" && "fetch" in globalThis) {
            return fetch.bind(globalThis);
        }
    } catch (err) {
    // no-op
    }
    /**
     * Existing polyfilled fetch
     */ if (typeof fetch !== "undefined") {
        return fetch;
    }
    /**
     * Environments where fetch cannot be found and must be polyfilled
     */ // eslint-disable-next-line @typescript-eslint/no-var-requires
    return __turbopack_context__.r("[project]/node_modules/cross-fetch/dist/node-ponyfill.js [app-route] (ecmascript)");
};
exports.getFetch = getFetch;
/**
 * If `Response` isn't included in this environment, it's probably an earlier
 * Node env that isn't already polyfilling. This function returns either the
 * native `Response` or a polyfilled one.
 */ const getResponse = ()=>{
    if (typeof Response !== "undefined") {
        return Response;
    }
    // eslint-disable-next-line @typescript-eslint/no-unsafe-return, @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-var-requires
    return __turbopack_context__.r("[project]/node_modules/cross-fetch/dist/node-ponyfill.js [app-route] (ecmascript)").Response;
};
exports.getResponse = getResponse;
/**
 * Given an unknown value, try to parse it as a `boolean`. Useful for parsing
 * environment variables that could be a selection of different values such as
 * `"true"`, `"1"`.
 *
 * If the value could not be confidently parsed as a `boolean` or was seen to be
 * `undefined`, this function returns `undefined`.
 */ const parseAsBoolean = (value)=>{
    if (typeof value === "boolean") {
        return value;
    }
    if (typeof value === "number") {
        return Boolean(value);
    }
    if (typeof value === "string") {
        const trimmed = value.trim().toLowerCase();
        if (trimmed === "undefined") {
            return undefined;
        }
        if ([
            "true",
            "1"
        ].includes(trimmed)) {
            return true;
        }
        return false;
    }
    return undefined;
};
exports.parseAsBoolean = parseAsBoolean; //# sourceMappingURL=env.js.map
}),
"[project]/node_modules/inngest/helpers/devserver.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.devServerHost = exports.devServerUrl = exports.devServerAvailable = void 0;
const consts_js_1 = __turbopack_context__.r("[project]/node_modules/inngest/helpers/consts.js [app-route] (ecmascript)");
const env_js_1 = __turbopack_context__.r("[project]/node_modules/inngest/helpers/env.js [app-route] (ecmascript)");
/**
 * Attempts to contact the dev server, returning a boolean indicating whether or
 * not it was successful.
 *
 * @example devServerUrl(process.env[envKeys.DevServerUrl], "/your-path")
 */ const devServerAvailable = async (/**
 * The host of the dev server. You should pass in an environment variable as
 * this parameter.
 */ host = consts_js_1.defaultDevServerHost, /**
 * The fetch implementation to use to communicate with the dev server.
 */ fetch)=>{
    try {
        const url = (0, exports.devServerUrl)(host, "/dev");
        const result = await fetch(url.toString());
        await result.json();
        return true;
    } catch (e) {
        return false;
    }
};
exports.devServerAvailable = devServerAvailable;
/**
 * devServerUrl returns a full URL for the given path name.
 *
 * Because Cloudflare/V8 platforms don't allow process.env, you are expected
 * to pass in the host from the dev server env key:
 *
 * @example devServerUrl(processEnv(envKeys.DevServerUrl), "/your-path")
 * @example devServerUrl("http://localhost:8288/", "/your-path")
 */ const devServerUrl = (host = (0, exports.devServerHost)(), pathname = "")=>{
    return new URL(pathname, host.includes("://") ? host : `http://${host}`);
};
exports.devServerUrl = devServerUrl;
/**
 * devServerHost exports the development server's domain by inspecting env
 * variables, or returns the default development server URL.
 *
 * This guarantees a specific URL as a string, as opposed to the env export
 * which only returns a value of the env var is set.
 */ const devServerHost = ()=>(0, env_js_1.devServerHost)() || consts_js_1.defaultDevServerHost;
exports.devServerHost = devServerHost; //# sourceMappingURL=devserver.js.map
}),
"[project]/node_modules/inngest/helpers/enum.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.enumFromValue = void 0;
/**
 * Returns the value of an enum from a string value.
 *
 * If the value given is not a value from the enum, `undefined` is returned.
 */ const enumFromValue = (enumType, value)=>{
    if (Object.values(enumType).includes(value)) {
        return value;
    }
};
exports.enumFromValue = enumFromValue; //# sourceMappingURL=enum.js.map
}),
"[project]/node_modules/inngest/components/NonRetriableError.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.NonRetriableError = void 0;
/**
 * An error that, when thrown, indicates to Inngest that the function should
 * cease all execution and not retry.
 *
 * A `message` must be provided, and an optional `cause` can be provided to
 * provide more context to the error.
 *
 * @public
 */ class NonRetriableError extends Error {
    constructor(message, options){
        super(message);
        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
        this.cause = options === null || options === void 0 ? void 0 : options.cause;
        this.name = "NonRetriableError";
    }
}
exports.NonRetriableError = NonRetriableError; //# sourceMappingURL=NonRetriableError.js.map
}),
"[project]/node_modules/inngest/helpers/errors.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __importDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.functionStoppedRunningErr = exports.rethrowError = exports.OutgoingResultError = exports.fixEventKeyMissingSteps = exports.prettyError = exports.getErrorMessage = exports.minifyPrettyError = exports.prettyErrorSplitter = exports.ErrCode = exports.deserializeError = exports.isSerializedError = exports.serializeError = void 0;
const chalk_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/chalk/source/index.js [app-route] (ecmascript)"));
const json_stringify_safe_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/json-stringify-safe/stringify.js [app-route] (ecmascript)"));
const serialize_error_cjs_1 = __turbopack_context__.r("[project]/node_modules/serialize-error-cjs/dist/index.js [app-route] (ecmascript)");
const strip_ansi_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/strip-ansi/index.js [app-route] (ecmascript)"));
const zod_1 = __turbopack_context__.r("[project]/node_modules/zod/lib/index.js [app-route] (ecmascript)");
const NonRetriableError_js_1 = __turbopack_context__.r("[project]/node_modules/inngest/components/NonRetriableError.js [app-route] (ecmascript)");
const SERIALIZED_KEY = "__serialized";
const SERIALIZED_VALUE = true;
/**
 * Add first-class support for certain errors that we control, in addition to
 * built-in errors such as `TypeError`.
 *
 * Adding these allows these non-standard errors to be correctly serialized,
 * sent to Inngest, then deserialized back into the correct error type for users
 * to react to correctly.
 *
 * Note that these errors only support `message?: string | undefined` as the
 * input; more custom errors are not supported with this current strategy.
 */ serialize_error_cjs_1.errorConstructors.set("NonRetriableError", NonRetriableError_js_1.NonRetriableError);
/**
 * Serialise an error to a serialized JSON string.
 *
 * Errors do not serialise nicely to JSON, so we use this function to convert
 * them to a serialized JSON string. Doing this is also non-trivial for some
 * errors, so we use the `serialize-error` package to do it for us.
 *
 * See {@link https://www.npmjs.com/package/serialize-error}
 *
 * This function is a small wrapper around that package to also add a `type`
 * property to the serialised error, so that we can distinguish between
 * serialised errors and other objects.
 *
 * Will not reserialise existing serialised errors.
 */ const serializeError = (/**
 * The suspected error to serialize.
 */ subject, /**
 * If `true` and the error is not serializable, will return the original value
 * as `unknown` instead of coercing it to a serialized error.
 */ allowUnknown = false)=>{
    try {
        // Try to understand if this is already done.
        // Will handle stringified errors.
        const existingSerializedError = (0, exports.isSerializedError)(subject);
        if (existingSerializedError) {
            return existingSerializedError;
        }
        if (typeof subject === "object" && subject !== null) {
            // Is an object, so let's try and serialize it.
            const serializedErr = (0, serialize_error_cjs_1.serializeError)(subject);
            // Not a proper error was caught, so give us a chance to return `unknown`.
            if (!serializedErr.name && allowUnknown) {
                return subject;
            }
            // Serialization can succeed but assign no name or message, so we'll
            // map over the result here to ensure we have everything.
            // We'll just stringify the entire subject for the message, as this at
            // least provides some context for the user.
            const ret = Object.assign(Object.assign({}, serializedErr), {
                name: serializedErr.name || "Error",
                message: serializedErr.message || (0, json_stringify_safe_1.default)(subject) || "Unknown error; error serialization could not find a message.",
                stack: serializedErr.stack || "",
                [SERIALIZED_KEY]: SERIALIZED_VALUE
            });
            // If we have a cause, make sure we recursively serialize them too. We are
            // lighter with causes though; attempt to recursively serialize them, but
            // stop if we find something that doesn't work and just return `unknown`.
            let target = ret;
            const maxDepth = 5;
            for(let i = 0; i < maxDepth; i++){
                if (typeof target === "object" && target !== null && "cause" in target && target.cause) {
                    target = target.cause = (0, exports.serializeError)(target.cause, true);
                    continue;
                }
                break;
            }
            return ret;
        }
        // If it's not an object, it's hard to parse this as an Error. In this case,
        // we'll throw an error to start attempting backup strategies.
        throw new Error("Error is not an object; strange throw value.");
    } catch (err) {
        if (allowUnknown) {
            // If we are allowed to return unknown, we'll just return the original
            // value.
            return subject;
        }
        try {
            // If serialization fails, fall back to a regular Error and use the
            // original object as the message for an Error. We don't know what this
            // object looks like, so we can't do anything else with it.
            return Object.assign(Object.assign({}, (0, exports.serializeError)(new Error(typeof subject === "string" ? subject : (0, json_stringify_safe_1.default)(subject)), false)), {
                // Remove the stack; it's not relevant here
                stack: "",
                [SERIALIZED_KEY]: SERIALIZED_VALUE
            });
        } catch (err) {
            // If this failed, then stringifying the object also failed, so we'll just
            // return a completely generic error.
            // Failing to stringify the object is very unlikely.
            return {
                name: "Could not serialize source error",
                message: "Serializing the source error failed.",
                stack: "",
                [SERIALIZED_KEY]: SERIALIZED_VALUE
            };
        }
    }
};
exports.serializeError = serializeError;
/**
 * Check if an object or a string is a serialised error created by
 * {@link serializeError}.
 */ const isSerializedError = (value)=>{
    try {
        if (typeof value === "string") {
            const parsed = zod_1.z.object({
                [SERIALIZED_KEY]: zod_1.z.literal(SERIALIZED_VALUE),
                name: zod_1.z.enum([
                    ...Array.from(serialize_error_cjs_1.errorConstructors.keys())
                ]),
                message: zod_1.z.string(),
                stack: zod_1.z.string()
            }).passthrough().safeParse(JSON.parse(value));
            if (parsed.success) {
                return parsed.data;
            }
        }
        if (typeof value === "object" && value !== null) {
            const objIsSerializedErr = Object.prototype.hasOwnProperty.call(value, SERIALIZED_KEY) && // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
            value[SERIALIZED_KEY] === SERIALIZED_VALUE;
            if (objIsSerializedErr) {
                return value;
            }
        }
    } catch (_a) {
    // no-op; we'll return undefined if parsing failed, as it isn't a serialized
    // error
    }
};
exports.isSerializedError = isSerializedError;
/**
 * Deserialise an error created by {@link serializeError}.
 *
 * Ensures we only deserialise errors that meet a minimum level of
 * applicability, inclusive of error handling to ensure that badly serialized
 * errors are still handled.
 */ const deserializeError = (subject, allowUnknown = false)=>{
    const requiredFields = [
        "name",
        "message"
    ];
    try {
        const hasRequiredFields = requiredFields.every((field)=>{
            return Object.prototype.hasOwnProperty.call(subject, field);
        });
        if (!hasRequiredFields) {
            throw new Error();
        }
        const deserializedErr = (0, serialize_error_cjs_1.deserializeError)(subject);
        if ("cause" in deserializedErr) {
            deserializedErr.cause = (0, exports.deserializeError)(deserializedErr.cause, true);
        }
        return deserializedErr;
    } catch (_a) {
        if (allowUnknown) {
            // If we are allowed to return unknown, we'll just return the original
            // value.
            return subject;
        }
        const err = new Error("Unknown error; could not reserialize");
        /**
         * Remove the stack so that it's not misleadingly shown as the Inngest
         * internals.
         */ err.stack = undefined;
        return err;
    }
};
exports.deserializeError = deserializeError;
var ErrCode;
(function(ErrCode) {
    ErrCode["NESTING_STEPS"] = "NESTING_STEPS";
    /**
     * Legacy v0 execution error code for when a function has changed and no
     * longer matches its in-progress state.
     *
     * @deprecated Not for use in latest execution method.
     */ ErrCode["NON_DETERMINISTIC_FUNCTION"] = "NON_DETERMINISTIC_FUNCTION";
    /**
     * Legacy v0 execution error code for when a function is found to be using
     * async actions after memoziation has occurred, which v0 doesn't support.
     *
     * @deprecated Not for use in latest execution method.
     */ ErrCode["ASYNC_DETECTED_AFTER_MEMOIZATION"] = "ASYNC_DETECTED_AFTER_MEMOIZATION";
    /**
     * Legacy v0 execution error code for when a function is found to be using
     * steps after a non-step async action has occurred.
     *
     * @deprecated Not for use in latest execution method.
     */ ErrCode["STEP_USED_AFTER_ASYNC"] = "STEP_USED_AFTER_ASYNC";
    ErrCode["AUTOMATIC_PARALLEL_INDEXING"] = "AUTOMATIC_PARALLEL_INDEXING";
})(ErrCode || (exports.ErrCode = ErrCode = {}));
exports.prettyErrorSplitter = "=================================================";
/**
 * Given an unknown `err`, mutate it to minify any pretty errors that it
 * contains.
 */ const minifyPrettyError = (err)=>{
    var _a, _b, _c, _d;
    try {
        if (!isError(err)) {
            return err;
        }
        const isPrettyError = err.message.includes(exports.prettyErrorSplitter);
        if (!isPrettyError) {
            return err;
        }
        const sanitizedMessage = (0, strip_ansi_1.default)(err.message);
        const message = ((_b = (_a = sanitizedMessage.split("  ")[1]) === null || _a === void 0 ? void 0 : _a.split("\n")[0]) === null || _b === void 0 ? void 0 : _b.trim()) || err.message;
        const code = ((_d = (_c = sanitizedMessage.split("\n\nCode: ")[1]) === null || _c === void 0 ? void 0 : _c.split("\n\n")[0]) === null || _d === void 0 ? void 0 : _d.trim()) || undefined;
        err.message = [
            code,
            message
        ].filter(Boolean).join(" - ");
        if (err.stack) {
            const sanitizedStack = (0, strip_ansi_1.default)(err.stack);
            const stackRest = sanitizedStack.split(`${exports.prettyErrorSplitter}\n`).slice(2).join("\n");
            err.stack = `${err.name}: ${err.message}\n${stackRest}`;
        }
        return err;
    } catch (noopErr) {
        return err;
    }
};
exports.minifyPrettyError = minifyPrettyError;
/**
 * Given an `err`, return a boolean representing whether it is in the shape of
 * an `Error` or not.
 */ const isError = (err)=>{
    try {
        if (err instanceof Error) {
            return true;
        }
        const hasName = Object.prototype.hasOwnProperty.call(err, "name");
        const hasMessage = Object.prototype.hasOwnProperty.call(err, "message");
        return hasName && hasMessage;
    } catch (noopErr) {
        return false;
    }
};
/**
 * Given an `unknown` object, retrieve the `message` property from it, or fall
 * back to the `fallback` string if it doesn't exist or is empty.
 */ const getErrorMessage = (err, fallback)=>{
    const { message } = zod_1.z.object({
        message: zod_1.z.string().min(1)
    }).catch({
        message: fallback
    }).parse(err);
    return message;
};
exports.getErrorMessage = getErrorMessage;
/**
 * Given a {@link PrettyError}, return a nicely-formatted string ready to log
 * or throw.
 *
 * Useful for ensuring that errors are logged in a consistent, helpful format
 * across the SDK by prompting for key pieces of information.
 */ const prettyError = ({ type = "error", whatHappened, otherwise, reassurance, toFixNow, why, consequences, stack, code })=>{
    var _a, _b;
    const { icon, colorFn } = {
        error: {
            icon: "❌",
            colorFn: chalk_1.default.red
        },
        warn: {
            icon: "⚠️",
            colorFn: chalk_1.default.yellow
        }
    }[type];
    let header = `${icon}  ${chalk_1.default.bold.underline(whatHappened.trim())}`;
    if (stack) {
        header += "\n" + [
            ...((_a = new Error().stack) === null || _a === void 0 ? void 0 : _a.split("\n").slice(1).filter(Boolean)) || []
        ].join("\n");
    }
    let toFixNowStr = (_b = Array.isArray(toFixNow) ? toFixNow.map((s)=>s.trim()).filter(Boolean).map((s, i)=>`\t${i + 1}. ${s}`).join("\n") : toFixNow === null || toFixNow === void 0 ? void 0 : toFixNow.trim()) !== null && _b !== void 0 ? _b : "";
    if (Array.isArray(toFixNow) && toFixNowStr) {
        toFixNowStr = `To fix this, you can take one of the following courses of action:\n\n${toFixNowStr}`;
    }
    let body = [
        reassurance === null || reassurance === void 0 ? void 0 : reassurance.trim(),
        why === null || why === void 0 ? void 0 : why.trim(),
        consequences === null || consequences === void 0 ? void 0 : consequences.trim()
    ].filter(Boolean).join(" ");
    body += body ? `\n\n${toFixNowStr}` : toFixNowStr;
    const trailer = [
        otherwise === null || otherwise === void 0 ? void 0 : otherwise.trim()
    ].filter(Boolean).join(" ");
    const message = [
        exports.prettyErrorSplitter,
        header,
        body,
        trailer,
        code ? `Code: ${code}` : "",
        exports.prettyErrorSplitter
    ].filter(Boolean).join("\n\n");
    return colorFn(message);
};
exports.prettyError = prettyError;
exports.fixEventKeyMissingSteps = [
    "Set the `INNGEST_EVENT_KEY` environment variable",
    `Pass a key to the \`new Inngest()\` constructor using the \`${"eventKey"}\` option`,
    `Use \`inngest.${"setEventKey"}()\` at runtime`
];
/**
 * An error that, when thrown, indicates internally that an outgoing operation
 * contains an error.
 *
 * We use this because serialized `data` sent back to Inngest may differ from
 * the error instance itself due to middleware.
 *
 * @internal
 */ class OutgoingResultError extends Error {
    constructor(result){
        super("OutgoingOpError");
        this.result = result;
    }
}
exports.OutgoingResultError = OutgoingResultError;
/**
 * Create a function that will rethrow an error with a prefix added to the
 * message.
 *
 * Useful for adding context to errors that are rethrown.
 *
 * @example
 * ```ts
 * await doSomeAction().catch(rethrowError("Failed to do some action"));
 * ```
 */ // eslint-disable-next-line @typescript-eslint/no-explicit-any
const rethrowError = (prefix)=>{
    return (err)=>{
        try {
            // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/restrict-template-expressions
            err.message && (err.message = `${prefix}; ${err.message}`);
        } catch (noopErr) {
        // no-op
        } finally{
            // eslint-disable-next-line no-unsafe-finally
            throw err;
        }
    };
};
exports.rethrowError = rethrowError;
/**
 * Legacy v0 execution error for functions that don't support mixing steps and
 * regular async actions.
 */ const functionStoppedRunningErr = (code)=>{
    return (0, exports.prettyError)({
        whatHappened: "Your function was stopped from running",
        why: "We detected a mix of asynchronous logic, some using step tooling and some not.",
        consequences: "This can cause unexpected behaviour when a function is paused and resumed and is therefore strongly discouraged; we stopped your function to ensure nothing unexpected happened!",
        stack: true,
        toFixNow: "Ensure that your function is either entirely step-based or entirely non-step-based, by either wrapping all asynchronous logic in `step.run()` calls or by removing all `step.*()` calls.",
        otherwise: "For more information on why step functions work in this manner, see https://www.inngest.com/docs/functions/multi-step#gotchas",
        code
    });
};
exports.functionStoppedRunningErr = functionStoppedRunningErr; //# sourceMappingURL=errors.js.map
}),
"[project]/node_modules/inngest/components/execution/InngestExecution.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __importDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.InngestExecution = exports.PREFERRED_EXECUTION_VERSION = exports.ExecutionVersion = void 0;
const debug_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/debug/src/index.js [app-route] (ecmascript)"));
const consts_js_1 = __turbopack_context__.r("[project]/node_modules/inngest/helpers/consts.js [app-route] (ecmascript)");
/**
 * The execution models the SDK is aware of.
 *
 * This is used in a number of places to ensure all execution versions are
 * accounted for for a given operation.
 */ var ExecutionVersion;
(function(ExecutionVersion) {
    ExecutionVersion[ExecutionVersion["V0"] = 0] = "V0";
    ExecutionVersion[ExecutionVersion["V1"] = 1] = "V1";
    ExecutionVersion[ExecutionVersion["V2"] = 2] = "V2";
})(ExecutionVersion || (exports.ExecutionVersion = ExecutionVersion = {}));
/**
 * The preferred execution version that will be used by the SDK when handling
 * brand new runs where the Executor is allowing us to choose.
 *
 * Changing this should not ever be a breaking change, as this will only change
 * new runs, not existing ones.
 */ exports.PREFERRED_EXECUTION_VERSION = ExecutionVersion.V1;
class InngestExecution {
    constructor(options){
        this.options = options;
        this.debug = (0, debug_1.default)(`${consts_js_1.debugPrefix}:${this.options.runId}`);
    }
}
exports.InngestExecution = InngestExecution; //# sourceMappingURL=InngestExecution.js.map
}),
"[project]/node_modules/inngest/types.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/**
 * Internal types and schemas used throughout the Inngest SDK.
 *
 * Note that types intended to be imported and utilized in userland code will be
 * exported from the main entrypoint of the SDK, `inngest`; importing types
 * directly from this file may result in breaking changes in non-major bumps as
 * only those exported from `inngest` are considered stable.
 *
 * @module
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.inBandSyncRequestBodySchema = exports.err = exports.ok = exports.functionConfigSchema = exports.logLevels = exports.sendEventResponseSchema = exports.incomingOpSchema = exports.StepOpCode = exports.jsonErrorSchema = void 0;
const zod_1 = __turbopack_context__.r("[project]/node_modules/zod/lib/index.js [app-route] (ecmascript)");
const baseJsonErrorSchema = zod_1.z.object({
    name: zod_1.z.string().trim().optional(),
    error: zod_1.z.string().trim().optional(),
    message: zod_1.z.string().trim().optional(),
    stack: zod_1.z.string().trim().optional()
});
const maybeJsonErrorSchema = zod_1.z.lazy(()=>zod_1.z.object({
        name: zod_1.z.string().trim(),
        message: zod_1.z.string().trim(),
        stack: zod_1.z.string().trim().optional(),
        cause: zod_1.z.union([
            maybeJsonErrorSchema,
            zod_1.z.unknown()
        ]).optional()
    }));
exports.jsonErrorSchema = baseJsonErrorSchema.extend({
    cause: zod_1.z.union([
        maybeJsonErrorSchema,
        zod_1.z.unknown()
    ]).optional()
}).passthrough().catch({}).transform((val)=>{
    return Object.assign(Object.assign({}, val), {
        name: val.name || "Error",
        message: val.message || val.error || "Unknown error",
        stack: val.stack
    });
});
/**
 * Unique codes for the different types of operation that can be sent to Inngest
 * from SDK step functions.
 */ var StepOpCode;
(function(StepOpCode) {
    StepOpCode["WaitForSignal"] = "WaitForSignal";
    StepOpCode["WaitForEvent"] = "WaitForEvent";
    /**
     * Legacy equivalent to `"StepRun"`. Has mixed data wrapping (e.g. `data` or
     * `data.data` depending on SDK version), so this is phased out in favour of
     * `"StepRun"`, which never wraps.
     *
     * Note that it is still used for v0 executions for backwards compatibility.
     *
     * @deprecated Only used for v0 executions; use `"StepRun"` instead.
     */ StepOpCode["Step"] = "Step";
    StepOpCode["StepRun"] = "StepRun";
    StepOpCode["StepError"] = "StepError";
    StepOpCode["StepPlanned"] = "StepPlanned";
    StepOpCode["Sleep"] = "Sleep";
    /**
     * Used to signify that the executor has requested that a step run, but we
     * could not find that step.
     *
     * This is likely indicative that a step was renamed or removed from the
     * function.
     */ StepOpCode["StepNotFound"] = "StepNotFound";
    StepOpCode["InvokeFunction"] = "InvokeFunction";
    StepOpCode["AiGateway"] = "AIGateway";
    StepOpCode["Gateway"] = "Gateway";
})(StepOpCode || (exports.StepOpCode = StepOpCode = {}));
exports.incomingOpSchema = zod_1.z.object({
    id: zod_1.z.string().min(1),
    data: zod_1.z.any().optional(),
    error: zod_1.z.any().optional(),
    input: zod_1.z.any().optional()
});
exports.sendEventResponseSchema = zod_1.z.object({
    /**
     * Event IDs
     */ ids: zod_1.z.array(zod_1.z.string()).default([]),
    /**
     * HTTP Status Code. Will be undefined if no request was sent.
     */ status: zod_1.z.number().default(0),
    /**
     * Error message. Will be undefined if no error occurred.
     */ error: zod_1.z.string().optional()
});
/**
 * A set of log levels that can be used to control the amount of logging output
 * from various parts of the Inngest library.
 *
 * @public
 */ exports.logLevels = [
    "fatal",
    "error",
    "warn",
    "info",
    "debug",
    "silent"
];
/**
 * This schema is used internally to share the shape of a concurrency option
 * when validating config. We cannot add comments to Zod fields, so we just use
 * an extra type check to ensure it matches our exported expectations.
 */ const concurrencyOptionSchema = zod_1.z.strictObject({
    limit: zod_1.z.number(),
    key: zod_1.z.string().optional(),
    scope: zod_1.z.enum([
        "fn",
        "env",
        "account"
    ]).optional()
});
const _checkConcurrencySchemaAligns = true;
/**
 * The schema used to represent an individual function being synced with
 * Inngest.
 *
 * Note that this should only be used to validate the shape of a config object
 * and not used for feature compatibility, such as feature X being exclusive
 * with feature Y; these should be handled on the Inngest side.
 */ exports.functionConfigSchema = zod_1.z.strictObject({
    name: zod_1.z.string().optional(),
    id: zod_1.z.string(),
    triggers: zod_1.z.array(zod_1.z.union([
        zod_1.z.strictObject({
            event: zod_1.z.string(),
            expression: zod_1.z.string().optional()
        }),
        zod_1.z.strictObject({
            cron: zod_1.z.string()
        })
    ])),
    steps: zod_1.z.record(zod_1.z.strictObject({
        id: zod_1.z.string(),
        name: zod_1.z.string(),
        runtime: zod_1.z.strictObject({
            type: zod_1.z.union([
                zod_1.z.literal("http"),
                zod_1.z.literal("ws")
            ]),
            url: zod_1.z.string()
        }),
        retries: zod_1.z.strictObject({
            attempts: zod_1.z.number().optional()
        }).optional()
    })),
    idempotency: zod_1.z.string().optional(),
    batchEvents: zod_1.z.strictObject({
        maxSize: zod_1.z.number(),
        timeout: zod_1.z.string(),
        key: zod_1.z.string().optional(),
        if: zod_1.z.string().optional()
    }).optional(),
    rateLimit: zod_1.z.strictObject({
        key: zod_1.z.string().optional(),
        limit: zod_1.z.number(),
        period: zod_1.z.string().transform((x)=>x)
    }).optional(),
    throttle: zod_1.z.strictObject({
        key: zod_1.z.string().optional(),
        limit: zod_1.z.number(),
        period: zod_1.z.string().transform((x)=>x),
        burst: zod_1.z.number().optional()
    }).optional(),
    singleton: zod_1.z.strictObject({
        key: zod_1.z.string().optional(),
        mode: zod_1.z.enum([
            "skip",
            "cancel"
        ])
    }).optional(),
    cancel: zod_1.z.array(zod_1.z.strictObject({
        event: zod_1.z.string(),
        if: zod_1.z.string().optional(),
        timeout: zod_1.z.string().optional()
    })).optional(),
    debounce: zod_1.z.strictObject({
        key: zod_1.z.string().optional(),
        period: zod_1.z.string().transform((x)=>x),
        timeout: zod_1.z.string().transform((x)=>x).optional()
    }).optional(),
    timeouts: zod_1.z.strictObject({
        start: zod_1.z.string().transform((x)=>x).optional(),
        finish: zod_1.z.string().transform((x)=>x).optional()
    }).optional(),
    priority: zod_1.z.strictObject({
        run: zod_1.z.string().optional()
    }).optional(),
    concurrency: zod_1.z.union([
        zod_1.z.number(),
        concurrencyOptionSchema.transform((x)=>x),
        zod_1.z.array(concurrencyOptionSchema.transform((x)=>x)).min(1).max(2)
    ]).optional()
});
const ok = (data)=>{
    return {
        ok: true,
        value: data
    };
};
exports.ok = ok;
const err = (error)=>{
    return {
        ok: false,
        error
    };
};
exports.err = err;
exports.inBandSyncRequestBodySchema = zod_1.z.strictObject({
    url: zod_1.z.string()
}); //# sourceMappingURL=types.js.map
}),
"[project]/node_modules/inngest/api/schema.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.batchSchema = exports.stepsSchemas = exports.errorSchema = void 0;
const zod_1 = __turbopack_context__.r("[project]/node_modules/zod/lib/index.js [app-route] (ecmascript)");
const InngestExecution_js_1 = __turbopack_context__.r("[project]/node_modules/inngest/components/execution/InngestExecution.js [app-route] (ecmascript)");
const types_js_1 = __turbopack_context__.r("[project]/node_modules/inngest/types.js [app-route] (ecmascript)");
exports.errorSchema = zod_1.z.object({
    error: zod_1.z.string(),
    status: zod_1.z.number()
});
const v0StepSchema = zod_1.z.record(zod_1.z.any().refine((v)=>typeof v !== "undefined", {
    message: "Values in steps must be defined"
})).optional().nullable();
const v1StepSchema = zod_1.z.record(zod_1.z.object({
    type: zod_1.z.literal("data").optional().default("data"),
    data: zod_1.z.any().refine((v)=>typeof v !== "undefined", {
        message: "Data in steps must be defined"
    })
}).strict().or(zod_1.z.object({
    type: zod_1.z.literal("error").optional().default("error"),
    error: types_js_1.jsonErrorSchema
}).strict()).or(zod_1.z.object({
    type: zod_1.z.literal("input").optional().default("input"),
    input: zod_1.z.any().refine((v)=>typeof v !== "undefined", {
        message: "If input is present it must not be `undefined`"
    })
}).strict())/**
     * If the result isn't a distcint `data` or `error` object, then it's
     * likely that the executor has set this directly to a value, for example
     * in the case of `sleep` or `waitForEvent`.
     *
     * In this case, pull the entire value through as data.
     */ // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
.or(zod_1.z.any().transform((v)=>({
        type: "data",
        data: v
    })))).default({});
const v2StepSchema = v1StepSchema;
exports.stepsSchemas = {
    [InngestExecution_js_1.ExecutionVersion.V0]: v0StepSchema,
    [InngestExecution_js_1.ExecutionVersion.V1]: v1StepSchema,
    [InngestExecution_js_1.ExecutionVersion.V2]: v2StepSchema
};
exports.batchSchema = zod_1.z.array(zod_1.z.record(zod_1.z.any()).transform((v)=>v)); //# sourceMappingURL=schema.js.map
}),
"[project]/node_modules/inngest/helpers/functions.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.fetchAllFnData = exports.parseFnData = exports.undefinedToNull = exports.waterfall = exports.cacheFn = void 0;
const zod_1 = __turbopack_context__.r("[project]/node_modules/zod/lib/index.js [app-route] (ecmascript)");
const schema_js_1 = __turbopack_context__.r("[project]/node_modules/inngest/api/schema.js [app-route] (ecmascript)");
const InngestExecution_js_1 = __turbopack_context__.r("[project]/node_modules/inngest/components/execution/InngestExecution.js [app-route] (ecmascript)");
const types_js_1 = __turbopack_context__.r("[project]/node_modules/inngest/types.js [app-route] (ecmascript)");
const errors_js_1 = __turbopack_context__.r("[project]/node_modules/inngest/helpers/errors.js [app-route] (ecmascript)");
/**
 * Wraps a function with a cache. When the returned function is run, it will
 * cache the result and return it on subsequent calls.
 */ // eslint-disable-next-line @typescript-eslint/no-explicit-any
const cacheFn = (fn)=>{
    const key = "value";
    const cache = new Map();
    return (...args)=>{
        if (!cache.has(key)) {
            // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
            cache.set(key, fn(...args));
        }
        return cache.get(key);
    };
};
exports.cacheFn = cacheFn;
/**
 * Given an array of functions, return a new function that will run each
 * function in series and return the result of the final function. Regardless of
 * if the functions are synchronous or asynchronous, they'll be made into an
 * async promise chain.
 *
 * If an error is thrown, the waterfall will stop and return the error.
 *
 * Because this needs to support both sync and async functions, it only allows
 * functions that accept a single argument.
 */ // eslint-disable-next-line @typescript-eslint/no-explicit-any
const waterfall = (fns, /**
 * A function that transforms the result of each function in the waterfall,
 * ready for the next function.
 *
 * Will not be called on the final function.
 */ // eslint-disable-next-line @typescript-eslint/no-explicit-any
transform)=>{
    return (...args)=>{
        const chain = fns.reduce(async (acc, fn)=>{
            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
            const prev = await acc;
            const output = await fn(prev);
            if (transform) {
                // eslint-disable-next-line @typescript-eslint/no-unsafe-return
                return await transform(prev, output);
            }
            if (typeof output === "undefined") {
                // eslint-disable-next-line @typescript-eslint/no-unsafe-return
                return prev;
            }
            return output;
        }, Promise.resolve(args[0]));
        return chain;
    };
};
exports.waterfall = waterfall;
/**
 * Given a value `v`, return `v` if it's not undefined, otherwise return `null`.
 */ const undefinedToNull = (v)=>{
    const isUndefined = typeof v === "undefined";
    return isUndefined ? null : v;
};
exports.undefinedToNull = undefinedToNull;
const fnDataVersionSchema = zod_1.z.object({
    version: zod_1.z.literal(-1).or(zod_1.z.literal(0)).or(zod_1.z.literal(1)).or(zod_1.z.literal(2)).optional().transform((v)=>{
        if (typeof v === "undefined") {
            console.debug(`No request version specified by executor; defaulting to v${InngestExecution_js_1.PREFERRED_EXECUTION_VERSION}`);
            return InngestExecution_js_1.PREFERRED_EXECUTION_VERSION;
        }
        return v === -1 ? InngestExecution_js_1.PREFERRED_EXECUTION_VERSION : v;
    })
});
const parseFnData = (data)=>{
    let version;
    try {
        ({ version } = fnDataVersionSchema.parse(data));
        const versionHandlers = {
            [InngestExecution_js_1.ExecutionVersion.V0]: ()=>Object.assign({
                    version: InngestExecution_js_1.ExecutionVersion.V0
                }, zod_1.z.object({
                    event: zod_1.z.record(zod_1.z.any()),
                    events: zod_1.z.array(zod_1.z.record(zod_1.z.any())).default([]),
                    steps: schema_js_1.stepsSchemas[InngestExecution_js_1.ExecutionVersion.V0],
                    ctx: zod_1.z.object({
                        run_id: zod_1.z.string(),
                        attempt: zod_1.z.number().default(0),
                        stack: zod_1.z.object({
                            stack: zod_1.z.array(zod_1.z.string()).nullable().transform((v)=>Array.isArray(v) ? v : []),
                            current: zod_1.z.number()
                        }).passthrough().optional().nullable()
                    }).optional().nullable(),
                    use_api: zod_1.z.boolean().default(false)
                }).parse(data)),
            [InngestExecution_js_1.ExecutionVersion.V1]: ()=>Object.assign({
                    version: InngestExecution_js_1.ExecutionVersion.V1
                }, zod_1.z.object({
                    event: zod_1.z.record(zod_1.z.any()),
                    events: zod_1.z.array(zod_1.z.record(zod_1.z.any())).default([]),
                    steps: schema_js_1.stepsSchemas[InngestExecution_js_1.ExecutionVersion.V1],
                    ctx: zod_1.z.object({
                        run_id: zod_1.z.string(),
                        attempt: zod_1.z.number().default(0),
                        disable_immediate_execution: zod_1.z.boolean().default(false),
                        use_api: zod_1.z.boolean().default(false),
                        stack: zod_1.z.object({
                            stack: zod_1.z.array(zod_1.z.string()).nullable().transform((v)=>Array.isArray(v) ? v : []),
                            current: zod_1.z.number()
                        }).passthrough().optional().nullable()
                    }).optional().nullable()
                }).parse(data)),
            [InngestExecution_js_1.ExecutionVersion.V2]: ()=>Object.assign({
                    version: InngestExecution_js_1.ExecutionVersion.V2
                }, zod_1.z.object({
                    event: zod_1.z.record(zod_1.z.any()),
                    events: zod_1.z.array(zod_1.z.record(zod_1.z.any())).default([]),
                    steps: schema_js_1.stepsSchemas[InngestExecution_js_1.ExecutionVersion.V2],
                    ctx: zod_1.z.object({
                        run_id: zod_1.z.string(),
                        attempt: zod_1.z.number().default(0),
                        disable_immediate_execution: zod_1.z.boolean().default(false),
                        use_api: zod_1.z.boolean().default(false),
                        stack: zod_1.z.object({
                            stack: zod_1.z.array(zod_1.z.string()).nullable().transform((v)=>Array.isArray(v) ? v : []),
                            current: zod_1.z.number()
                        }).passthrough().optional().nullable()
                    }).optional().nullable()
                }).parse(data))
        };
        return versionHandlers[version]();
    } catch (err) {
        throw new Error(parseFailureErr(err));
    }
};
exports.parseFnData = parseFnData;
const fetchAllFnData = async ({ data, api, version })=>{
    var _a, _b, _c, _d;
    const result = Object.assign({}, data);
    try {
        if (result.version === InngestExecution_js_1.ExecutionVersion.V0 && result.use_api || result.version === InngestExecution_js_1.ExecutionVersion.V1 && ((_a = result.ctx) === null || _a === void 0 ? void 0 : _a.use_api)) {
            if (!((_b = result.ctx) === null || _b === void 0 ? void 0 : _b.run_id)) {
                return (0, types_js_1.err)((0, errors_js_1.prettyError)({
                    whatHappened: "failed to attempt retrieving data from API",
                    consequences: "function execution can't continue",
                    why: "run_id is missing from context",
                    stack: true
                }));
            }
            const [evtResp, stepResp] = await Promise.all([
                api.getRunBatch(result.ctx.run_id),
                api.getRunSteps(result.ctx.run_id, version)
            ]);
            if (evtResp.ok) {
                result.events = evtResp.value;
            } else {
                return (0, types_js_1.err)((0, errors_js_1.prettyError)({
                    whatHappened: "failed to retrieve list of events",
                    consequences: "function execution can't continue",
                    why: (_c = evtResp.error) === null || _c === void 0 ? void 0 : _c.error,
                    stack: true
                }));
            }
            if (stepResp.ok) {
                result.steps = stepResp.value;
            } else {
                return (0, types_js_1.err)((0, errors_js_1.prettyError)({
                    whatHappened: "failed to retrieve steps for function run",
                    consequences: "function execution can't continue",
                    why: (_d = stepResp.error) === null || _d === void 0 ? void 0 : _d.error,
                    stack: true
                }));
            }
        }
        return (0, types_js_1.ok)(result);
    } catch (error) {
        // print it out for now.
        // move to something like protobuf so we don't have to deal with this
        console.error(error);
        return (0, types_js_1.err)(parseFailureErr(error));
    }
};
exports.fetchAllFnData = fetchAllFnData;
const parseFailureErr = (err)=>{
    let why;
    if (err instanceof zod_1.ZodError) {
        why = err.toString();
    }
    return (0, errors_js_1.prettyError)({
        whatHappened: "Failed to parse data from executor.",
        consequences: "Function execution can't continue.",
        toFixNow: "Make sure that your API is set up to parse incoming request bodies as JSON, like body-parser for Express (https://expressjs.com/en/resources/middleware/body-parser.html).",
        stack: true,
        why
    });
}; //# sourceMappingURL=functions.js.map
}),
"[project]/node_modules/inngest/helpers/net.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __importDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.fetchWithAuthFallback = fetchWithAuthFallback;
exports.signDataWithKey = signDataWithKey;
const canonicalize_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/canonicalize/lib/canonicalize.js [app-route] (ecmascript)"));
const hash_js_1 = __turbopack_context__.r("[project]/node_modules/hash.js/lib/hash.js [app-route] (ecmascript)");
/**
 * Send an HTTP request with the given signing key. If the response is a 401 or
 * 403, then try again with the fallback signing key
 */ async function fetchWithAuthFallback({ authToken, authTokenFallback, fetch, options, url }) {
    let res = await fetch(url, Object.assign(Object.assign({}, options), {
        headers: Object.assign(Object.assign({}, options === null || options === void 0 ? void 0 : options.headers), {
            Authorization: `Bearer ${authToken}`
        })
    }));
    if ([
        401,
        403
    ].includes(res.status) && authTokenFallback) {
        res = await fetch(url, Object.assign(Object.assign({}, options), {
            headers: Object.assign(Object.assign({}, options === null || options === void 0 ? void 0 : options.headers), {
                Authorization: `Bearer ${authTokenFallback}`
            })
        }));
    }
    return res;
}
function signDataWithKey(data, signingKey, ts) {
    // Calculate the HMAC of the request body ourselves.
    // We make the assumption here that a stringified body is the same as the
    // raw bytes; it may be pertinent in the future to always parse, then
    // canonicalize the body to ensure it's consistent.
    const encoded = typeof data === "string" ? data : (0, canonicalize_1.default)(data);
    // Remove the `/signkey-[test|prod]-/` prefix from our signing key to calculate the HMAC.
    const key = signingKey.replace(/signkey-\w+-/, "");
    // eslint-disable-next-line @typescript-eslint/no-unsafe-argument, @typescript-eslint/no-explicit-any
    const mac = (0, hash_js_1.hmac)(hash_js_1.sha256, key).update(encoded).update(ts).digest("hex");
    return mac;
} //# sourceMappingURL=net.js.map
}),
"[project]/node_modules/inngest/helpers/stream.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.createStream = void 0;
const strings_js_1 = __turbopack_context__.r("[project]/node_modules/inngest/helpers/strings.js [app-route] (ecmascript)");
/**
 * Creates a {@link ReadableStream} that sends a `value` every `interval`
 * milliseconds as a heartbeat, intended to keep a stream open.
 *
 * Returns the `stream` itself and a `finalize` function that can be used to
 * close the stream and send a final value.
 */ const createStream = (opts)=>{
    var _a, _b;
    /**
     * We need to resolve this promise with both the stream and the `finalize`
     * function, but having them both instantiated synchronously is difficult, as
     * we need access to the stream's internals too.
     *
     * We create this cheeky deferred promise to grab the internal `finalize`
     * value. Be warned that simpler solutions may appear to compile, but fail at
     * runtime due to variables not being assigned; make sure to test your code!
     */ let passFinalize;
    const finalizeP = new Promise((resolve)=>{
        passFinalize = resolve;
    });
    const interval = (_a = opts === null || opts === void 0 ? void 0 : opts.interval) !== null && _a !== void 0 ? _a : 3000;
    const value = (_b = opts === null || opts === void 0 ? void 0 : opts.value) !== null && _b !== void 0 ? _b : " ";
    // eslint-disable-next-line @typescript-eslint/no-misused-promises, no-async-promise-executor
    return new Promise(async (resolve, reject)=>{
        try {
            const stream = new ReadableStream({
                start (controller) {
                    const encoder = new TextEncoder();
                    const heartbeat = setInterval(()=>{
                        controller.enqueue(encoder.encode(value));
                    }, interval);
                    const finalize = (data)=>{
                        clearInterval(heartbeat);
                        // `data` may be a `Promise`. If it is, we need to wait for it to
                        // resolve before sending it. To support this elegantly we'll always
                        // assume it's a promise and handle that case.
                        void Promise.resolve(data).then((resolvedData)=>{
                            controller.enqueue(encoder.encode((0, strings_js_1.stringify)(resolvedData)));
                            controller.close();
                        });
                    };
                    passFinalize(finalize);
                }
            });
            resolve({
                stream,
                finalize: await finalizeP
            });
        } catch (err) {
            reject(err);
        }
    });
};
exports.createStream = createStream; //# sourceMappingURL=stream.js.map
}),
"[project]/node_modules/inngest/components/InngestCommHandler.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __classPrivateFieldGet = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__classPrivateFieldGet || function(receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __importDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
var _RequestSignature_instances, _RequestSignature_verifySignature;
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.InngestCommHandler = void 0;
const debug_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/debug/src/index.js [app-route] (ecmascript)"));
const zod_1 = __turbopack_context__.r("[project]/node_modules/zod/lib/index.js [app-route] (ecmascript)");
const ServerTiming_js_1 = __turbopack_context__.r("[project]/node_modules/inngest/helpers/ServerTiming.js [app-route] (ecmascript)");
const consts_js_1 = __turbopack_context__.r("[project]/node_modules/inngest/helpers/consts.js [app-route] (ecmascript)");
const devserver_js_1 = __turbopack_context__.r("[project]/node_modules/inngest/helpers/devserver.js [app-route] (ecmascript)");
const enum_js_1 = __turbopack_context__.r("[project]/node_modules/inngest/helpers/enum.js [app-route] (ecmascript)");
const env_js_1 = __turbopack_context__.r("[project]/node_modules/inngest/helpers/env.js [app-route] (ecmascript)");
const errors_js_1 = __turbopack_context__.r("[project]/node_modules/inngest/helpers/errors.js [app-route] (ecmascript)");
const functions_js_1 = __turbopack_context__.r("[project]/node_modules/inngest/helpers/functions.js [app-route] (ecmascript)");
const net_js_1 = __turbopack_context__.r("[project]/node_modules/inngest/helpers/net.js [app-route] (ecmascript)");
const promises_js_1 = __turbopack_context__.r("[project]/node_modules/inngest/helpers/promises.js [app-route] (ecmascript)");
const stream_js_1 = __turbopack_context__.r("[project]/node_modules/inngest/helpers/stream.js [app-route] (ecmascript)");
const strings_js_1 = __turbopack_context__.r("[project]/node_modules/inngest/helpers/strings.js [app-route] (ecmascript)");
const types_js_1 = __turbopack_context__.r("[project]/node_modules/inngest/types.js [app-route] (ecmascript)");
const version_js_1 = __turbopack_context__.r("[project]/node_modules/inngest/version.js [app-route] (ecmascript)");
const InngestExecution_js_1 = __turbopack_context__.r("[project]/node_modules/inngest/components/execution/InngestExecution.js [app-route] (ecmascript)");
/**
 * A schema for the response from Inngest when registering.
 */ const registerResSchema = zod_1.z.object({
    status: zod_1.z.number().default(200),
    skipped: zod_1.z.boolean().optional().default(false),
    modified: zod_1.z.boolean().optional().default(false),
    error: zod_1.z.string().default("Successfully registered")
});
/**
 * `InngestCommHandler` is a class for handling incoming requests from Inngest (or
 * Inngest's tooling such as the dev server or CLI) and taking appropriate
 * action for any served functions.
 *
 * All handlers (Next.js, RedwoodJS, Remix, Deno Fresh, etc.) are created using
 * this class; the exposed `serve` function will - most commonly - create an
 * instance of `InngestCommHandler` and then return `instance.createHandler()`.
 *
 * See individual parameter details for more information, or see the
 * source code for an existing handler, e.g.
 * {@link https://github.com/inngest/inngest-js/blob/main/src/next.ts}
 *
 * @example
 * ```
 * // my-custom-handler.ts
 * import {
 *   InngestCommHandler,
 *   type ServeHandlerOptions,
 * } from "./components/InngestCommHandler";
 *
 * export const serve = (options: ServeHandlerOptions) => {
 *   const handler = new InngestCommHandler({
 *     frameworkName: "my-custom-handler",
 *     ...options,
 *     handler: (req: Request) => {
 *       return {
 *         body: () => req.json(),
 *         headers: (key) => req.headers.get(key),
 *         method: () => req.method,
 *         url: () => new URL(req.url, `https://${req.headers.get("host") || ""}`),
 *         transformResponse: ({ body, status, headers }) => {
 *           return new Response(body, { status, headers });
 *         },
 *       };
 *     },
 *   });
 *
 *   return handler.createHandler();
 * };
 * ```
 *
 * @public
 */ class InngestCommHandler {
    constructor(options){
        var _a;
        /**
         * A private collection of functions that are being served. This map is used
         * to find and register functions when interacting with Inngest Cloud.
         */ this.fns = {};
        this.env = (0, env_js_1.allProcessEnv)();
        // Set input options directly so we can reference them later
        this._options = options;
        /**
         * v2 -> v3 migration error.
         *
         * If a serve handler is passed a client as the first argument, it'll be
         * spread in to these options. We should be able to detect this by picking
         * up a unique property on the object.
         */ if (Object.prototype.hasOwnProperty.call(options, "eventKey")) {
            throw new Error(`${consts_js_1.logPrefix} You've passed an Inngest client as the first argument to your serve handler. This is no longer supported in v3; please pass the Inngest client as the \`client\` property of an options object instead. See https://www.inngest.com/docs/sdk/migration`);
        }
        this.frameworkName = options.frameworkName;
        this.client = options.client;
        if (options.id) {
            console.warn(`${consts_js_1.logPrefix} The \`id\` serve option is deprecated and will be removed in v4`);
        }
        this.id = options.id || this.client.id;
        this.handler = options.handler;
        /**
         * Provide a hidden option to allow expired signatures to be accepted during
         * testing.
         */ this.allowExpiredSignatures = Boolean(// eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, prefer-rest-params
        (_a = arguments["0"]) === null || _a === void 0 ? void 0 : _a.__testingAllowExpiredSignatures);
        // Ensure we filter any undefined functions in case of missing imports.
        this.rawFns = options.functions.filter(Boolean);
        if (this.rawFns.length !== options.functions.length) {
            // TODO PrettyError
            console.warn(`Some functions passed to serve() are undefined and misconfigured.  Please check your imports.`);
        }
        this.fns = this.rawFns.reduce((acc, fn)=>{
            const configs = fn["getConfig"]({
                baseUrl: new URL("https://example.com"),
                appPrefix: this.id
            });
            const fns = configs.reduce((acc, { id }, index)=>{
                return Object.assign(Object.assign({}, acc), {
                    [id]: {
                        fn,
                        onFailure: Boolean(index)
                    }
                });
            }, {});
            configs.forEach(({ id })=>{
                if (acc[id]) {
                    // TODO PrettyError
                    throw new Error(`Duplicate function ID "${id}"; please change a function's name or provide an explicit ID to avoid conflicts.`);
                }
            });
            return Object.assign(Object.assign({}, acc), fns);
        }, {});
        this.inngestRegisterUrl = new URL("/fn/register", this.apiBaseUrl);
        this.signingKey = options.signingKey;
        this.signingKeyFallback = options.signingKeyFallback;
        this._serveHost = options.serveHost || this.env[consts_js_1.envKeys.InngestServeHost];
        this._servePath = options.servePath || this.env[consts_js_1.envKeys.InngestServePath];
        this.skipSignatureValidation = options.skipSignatureValidation || false;
        const defaultLogLevel = "info";
        this.logLevel = zod_1.z.enum(types_js_1.logLevels).default(defaultLogLevel).catch((ctx)=>{
            this.log("warn", `Unknown log level passed: ${String(ctx.input)}; defaulting to ${defaultLogLevel}`);
            return defaultLogLevel;
        }).parse(options.logLevel || this.env[consts_js_1.envKeys.InngestLogLevel]);
        if (this.logLevel === "debug") {
            /**
             * `debug` is an old library; sometimes its runtime detection doesn't work
             * for newer pairings of framework/runtime.
             *
             * One silly symptom of this is that `Debug()` returns an anonymous
             * function with no extra properties instead of a `Debugger` instance if
             * the wrong code is consumed following a bad detection. This results in
             * the following `.enable()` call failing, so we just try carefully to
             * enable it here.
             */ if (debug_1.default.enable && typeof debug_1.default.enable === "function") {
                debug_1.default.enable(`${consts_js_1.debugPrefix}:*`);
            }
        }
        const defaultStreamingOption = false;
        this.streaming = zod_1.z.union([
            zod_1.z.enum([
                "allow",
                "force"
            ]),
            zod_1.z.literal(false)
        ]).default(defaultStreamingOption).catch((ctx)=>{
            this.log("warn", `Unknown streaming option passed: ${String(ctx.input)}; defaulting to ${String(defaultStreamingOption)}`);
            return defaultStreamingOption;
        }).parse(options.streaming || this.env[consts_js_1.envKeys.InngestStreaming]);
        this.fetch = options.fetch ? (0, env_js_1.getFetch)(options.fetch) : this.client["fetch"];
    }
    /**
     * Get the API base URL for the Inngest API.
     *
     * This is a getter to encourage checking the environment for the API base URL
     * each time it's accessed, as it may change during execution.
     */ get apiBaseUrl() {
        return this._options.baseUrl || this.env[consts_js_1.envKeys.InngestApiBaseUrl] || this.env[consts_js_1.envKeys.InngestBaseUrl] || this.client.apiBaseUrl || consts_js_1.defaultInngestApiBaseUrl;
    }
    /**
     * Get the event API base URL for the Inngest API.
     *
     * This is a getter to encourage checking the environment for the event API
     * base URL each time it's accessed, as it may change during execution.
     */ get eventApiBaseUrl() {
        return this._options.baseUrl || this.env[consts_js_1.envKeys.InngestEventApiBaseUrl] || this.env[consts_js_1.envKeys.InngestBaseUrl] || this.client.eventBaseUrl || consts_js_1.defaultInngestEventBaseUrl;
    }
    /**
     * The host used to access the Inngest serve endpoint, e.g.:
     *
     *     "https://myapp.com"
     *
     * By default, the library will try to infer this using request details such
     * as the "Host" header and request path, but sometimes this isn't possible
     * (e.g. when running in a more controlled environments such as AWS Lambda or
     * when dealing with proxies/redirects).
     *
     * Provide the custom hostname here to ensure that the path is reported
     * correctly when registering functions with Inngest.
     *
     * To also provide a custom path, use `servePath`.
     */ get serveHost() {
        return this._serveHost || this.env[consts_js_1.envKeys.InngestServeHost];
    }
    /**
     * The path to the Inngest serve endpoint. e.g.:
     *
     *     "/some/long/path/to/inngest/endpoint"
     *
     * By default, the library will try to infer this using request details such
     * as the "Host" header and request path, but sometimes this isn't possible
     * (e.g. when running in a more controlled environments such as AWS Lambda or
     * when dealing with proxies/redirects).
     *
     * Provide the custom path (excluding the hostname) here to ensure that the
     * path is reported correctly when registering functions with Inngest.
     *
     * To also provide a custom hostname, use `serveHost`.
     *
     * This is a getter to encourage checking the environment for the serve path
     * each time it's accessed, as it may change during execution.
     */ get servePath() {
        return this._servePath || this.env[consts_js_1.envKeys.InngestServePath];
    }
    get hashedEventKey() {
        if (!this.client["eventKey"] || this.client["eventKey"] === consts_js_1.dummyEventKey) {
            return undefined;
        }
        return (0, strings_js_1.hashEventKey)(this.client["eventKey"]);
    }
    // hashedSigningKey creates a sha256 checksum of the signing key with the
    // same signing key prefix.
    get hashedSigningKey() {
        if (!this.signingKey) {
            return undefined;
        }
        return (0, strings_js_1.hashSigningKey)(this.signingKey);
    }
    get hashedSigningKeyFallback() {
        if (!this.signingKeyFallback) {
            return undefined;
        }
        return (0, strings_js_1.hashSigningKey)(this.signingKeyFallback);
    }
    /**
     * Returns a `boolean` representing whether this handler will stream responses
     * or not. Takes into account the user's preference and the platform's
     * capabilities.
     */ async shouldStream(actions) {
        const rawProbe = await actions.queryStringWithDefaults("testing for probe", consts_js_1.queryKeys.Probe);
        if (rawProbe !== undefined) {
            return false;
        }
        // We must be able to stream responses to continue.
        if (!actions.transformStreamingResponse) {
            return false;
        }
        // If the user has forced streaming, we should always stream.
        if (this.streaming === "force") {
            return true;
        }
        // If the user has allowed streaming, we should stream if the platform
        // supports it.
        return this.streaming === "allow" && (0, env_js_1.platformSupportsStreaming)(this.frameworkName, this.env);
    }
    /**
     * `createHandler` should be used to return a type-equivalent version of the
     * `handler` specified during instantiation.
     *
     * @example
     * ```
     * // my-custom-handler.ts
     * import {
     *   InngestCommHandler,
     *   type ServeHandlerOptions,
     * } from "./components/InngestCommHandler";
     *
     * export const serve = (options: ServeHandlerOptions) => {
     *   const handler = new InngestCommHandler({
     *     frameworkName: "my-custom-handler",
     *     ...options,
     *     handler: (req: Request) => {
     *       return {
     *         body: () => req.json(),
     *         headers: (key) => req.headers.get(key),
     *         method: () => req.method,
     *         url: () => new URL(req.url, `https://${req.headers.get("host") || ""}`),
     *         transformResponse: ({ body, status, headers }) => {
     *           return new Response(body, { status, headers });
     *         },
     *       };
     *     },
     *   });
     *
     *   return handler.createHandler();
     * };
     * ```
     */ createHandler() {
        const handler = async (...args)=>{
            var _a, _b;
            const timer = new ServerTiming_js_1.ServerTiming();
            /**
             * Used for testing, allow setting action overrides externally when
             * calling the handler. Always search the final argument.
             */ const lastArg = args[args.length - 1];
            const actionOverrides = typeof lastArg === "object" && lastArg !== null && "actionOverrides" in lastArg && typeof lastArg["actionOverrides"] === "object" && lastArg["actionOverrides"] !== null ? lastArg["actionOverrides"] : {};
            /**
             * We purposefully `await` the handler, as it could be either sync or
             * async.
             */ const rawActions = Object.assign(Object.assign({}, await timer.wrap("handler", ()=>this.handler(...args)).catch((0, errors_js_1.rethrowError)("Serve handler failed to run"))), actionOverrides);
            /**
             * Map over every `action` in `rawActions` and create a new `actions`
             * object where each function is safely promisified with each access
             * requiring a reason.
             *
             * This helps us provide high quality errors about what's going wrong for
             * each access without having to wrap every access in a try/catch.
             */ const promisifiedActions = Object.entries(rawActions).reduce((acc, [key, value])=>{
                if (typeof value !== "function") {
                    return acc;
                }
                return Object.assign(Object.assign({}, acc), {
                    [key]: (reason, ...args)=>{
                        const errMessage = [
                            `Failed calling \`${key}\` from serve handler`,
                            reason
                        ].filter(Boolean).join(" when ");
                        const fn = ()=>value(...args);
                        return (0, promises_js_1.runAsPromise)(fn).catch((0, errors_js_1.rethrowError)(errMessage)).catch((err)=>{
                            this.log("error", err);
                            throw err;
                        });
                    }
                });
            }, {});
            /**
             * Mapped promisified handlers from userland `serve()` function mixed in
             * with some helpers.
             */ const actions = Object.assign(Object.assign(Object.assign({}, promisifiedActions), {
                queryStringWithDefaults: async (reason, key)=>{
                    var _a;
                    const url = await actions.url(reason);
                    const ret = await ((_a = actions.queryString) === null || _a === void 0 ? void 0 : _a.call(actions, reason, key, url)) || url.searchParams.get(key) || undefined;
                    return ret;
                }
            }), actionOverrides);
            const [env, expectedServerKind] = await Promise.all([
                (_a = actions.env) === null || _a === void 0 ? void 0 : _a.call(actions, "starting to handle request"),
                actions.headers("checking expected server kind", consts_js_1.headerKeys.InngestServerKind)
            ]);
            // Always make sure to merge whatever env we've been given with
            // `process.env`; some platforms may not provide all the necessary
            // environment variables or may use two sources.
            this.env = Object.assign(Object.assign({}, (0, env_js_1.allProcessEnv)()), env);
            const getInngestHeaders = ()=>(0, env_js_1.inngestHeaders)({
                    env: this.env,
                    framework: this.frameworkName,
                    client: this.client,
                    expectedServerKind: expectedServerKind || undefined,
                    extras: {
                        "Server-Timing": timer.getHeader()
                    }
                });
            const assumedMode = (0, env_js_1.getMode)({
                env: this.env,
                client: this.client
            });
            if (assumedMode.isExplicit) {
                this._mode = assumedMode;
            } else {
                const serveIsProd = await ((_b = actions.isProduction) === null || _b === void 0 ? void 0 : _b.call(actions, "starting to handle request"));
                if (typeof serveIsProd === "boolean") {
                    this._mode = new env_js_1.Mode({
                        type: serveIsProd ? "cloud" : "dev",
                        isExplicit: false
                    });
                } else {
                    this._mode = assumedMode;
                }
            }
            this.upsertKeysFromEnv();
            const methodP = actions.method("starting to handle request");
            const headerPromises = [
                consts_js_1.headerKeys.TraceParent,
                consts_js_1.headerKeys.TraceState
            ].map(async (header)=>{
                const value = await actions.headers(`fetching ${header} for forwarding`, header);
                return {
                    header,
                    value
                };
            });
            const contentLength = await actions.headers("checking signature for request", consts_js_1.headerKeys.ContentLength).then((value)=>{
                if (!value) {
                    return undefined;
                }
                return parseInt(value, 10);
            });
            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
            const [signature, method, body] = await Promise.all([
                actions.headers("checking signature for request", consts_js_1.headerKeys.Signature).then((headerSignature)=>{
                    return headerSignature !== null && headerSignature !== void 0 ? headerSignature : undefined;
                }),
                methodP,
                methodP.then((method)=>{
                    if (method === "POST" || method === "PUT") {
                        if (!contentLength) {
                            // Return empty string because req.json() will throw an error.
                            return "";
                        }
                        return actions.body(`checking body for request signing as method is ${method}`);
                    }
                    return "";
                })
            ]);
            const signatureValidation = this.validateSignature(signature, body);
            const headersToForwardP = Promise.all(headerPromises).then((fetchedHeaders)=>{
                return fetchedHeaders.reduce((acc, { header, value })=>{
                    if (value) {
                        acc[header] = value;
                    }
                    return acc;
                }, {});
            });
            const actionRes = timer.wrap("action", ()=>this.handleAction({
                    actions,
                    timer,
                    getInngestHeaders,
                    reqArgs: args,
                    signatureValidation,
                    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
                    body,
                    method,
                    headers: headersToForwardP
                }));
            /**
             * Prepares an action response by merging returned data to provide
             * trailing information such as `Server-Timing` headers.
             *
             * It should always prioritize the headers returned by the action, as they
             * may contain important information such as `Content-Type`.
             */ const prepareActionRes = async (res)=>{
                var _a;
                const headers = Object.assign(Object.assign(Object.assign(Object.assign({}, getInngestHeaders()), await headersToForwardP), res.headers), res.version === null ? {} : {
                    [consts_js_1.headerKeys.RequestVersion]: ((_a = res.version) !== null && _a !== void 0 ? _a : InngestExecution_js_1.PREFERRED_EXECUTION_VERSION).toString()
                });
                let signature;
                try {
                    signature = await signatureValidation.then((result)=>{
                        if (!result.success || !result.keyUsed) {
                            return undefined;
                        }
                        return this.getResponseSignature(result.keyUsed, res.body);
                    });
                } catch (err) {
                    // If we fail to sign, retun a 500 with the error.
                    return Object.assign(Object.assign({}, res), {
                        headers,
                        body: (0, strings_js_1.stringify)((0, errors_js_1.serializeError)(err)),
                        status: 500
                    });
                }
                if (signature) {
                    headers[consts_js_1.headerKeys.Signature] = signature;
                }
                return Object.assign(Object.assign({}, res), {
                    headers
                });
            };
            if (await this.shouldStream(actions)) {
                const method = await actions.method("starting streaming response");
                if (method === "POST") {
                    const { stream, finalize } = await (0, stream_js_1.createStream)();
                    /**
                     * Errors are handled by `handleAction` here to ensure that an
                     * appropriate response is always given.
                     */ void actionRes.then((res)=>{
                        return finalize(prepareActionRes(res));
                    });
                    return timer.wrap("res", ()=>{
                        var _a;
                        return (_a = actions.transformStreamingResponse) === null || _a === void 0 ? void 0 : _a.call(actions, "starting streaming response", {
                            status: 201,
                            headers: getInngestHeaders(),
                            body: stream,
                            version: null
                        });
                    });
                }
            }
            return timer.wrap("res", async ()=>{
                return actionRes.then(prepareActionRes).then((actionRes)=>{
                    // eslint-disable-next-line @typescript-eslint/no-unsafe-return
                    return actions.transformResponse("sending back response", actionRes);
                });
            });
        };
        /**
         * Some platforms check (at runtime) the length of the function being used
         * to handle an endpoint. If this is a variadic function, it will fail that
         * check.
         *
         * Therefore, we expect the arguments accepted to be the same length as the
         * `handler` function passed internally.
         *
         * We also set a name to avoid a common useless name in tracing such as
         * `"anonymous"` or `"bound function"`.
         *
         * https://github.com/getsentry/sentry-javascript/issues/3284
         */ Object.defineProperties(handler, {
            name: {
                value: "InngestHandler"
            },
            length: {
                value: this.handler.length
            }
        });
        return handler;
    }
    get mode() {
        return this._mode;
    }
    set mode(m) {
        this._mode = m;
        if (m) {
            this.client["mode"] = m;
        }
    }
    /**
     * Given a set of functions to check if an action is available from the
     * instance's handler, enact any action that is found.
     *
     * This method can fetch varying payloads of data, but ultimately is the place
     * where _decisions_ are made regarding functionality.
     *
     * For example, if we find that we should be viewing the UI, this function
     * will decide whether the UI should be visible based on the payload it has
     * found (e.g. env vars, options, etc).
     */ async handleAction({ actions, timer, getInngestHeaders, reqArgs, signatureValidation, body, method, headers }) {
        var _a;
        // This is when the request body is completely missing; it does not
        // include an empty body. This commonly happens when the HTTP framework
        // doesn't have body parsing middleware.
        const isMissingBody = body === undefined;
        try {
            let url = await actions.url("starting to handle request");
            if (method === "POST") {
                if (isMissingBody) {
                    this.log("error", "Missing body when executing, possibly due to missing request body middleware");
                    return {
                        status: 500,
                        headers: {
                            "Content-Type": "application/json"
                        },
                        body: (0, strings_js_1.stringify)((0, errors_js_1.serializeError)(new Error("Missing request body when executing, possibly due to missing request body middleware"))),
                        version: undefined
                    };
                }
                const validationResult = await signatureValidation;
                if (!validationResult.success) {
                    return {
                        status: 401,
                        headers: {
                            "Content-Type": "application/json"
                        },
                        body: (0, strings_js_1.stringify)((0, errors_js_1.serializeError)(validationResult.err)),
                        version: undefined
                    };
                }
                const rawProbe = await actions.queryStringWithDefaults("testing for probe", consts_js_1.queryKeys.Probe);
                if (rawProbe) {
                    const probe = (0, enum_js_1.enumFromValue)(consts_js_1.probe, rawProbe);
                    if (!probe) {
                        // If we're here, we've received a probe that we don't recognize.
                        // Fail.
                        return {
                            status: 400,
                            headers: {
                                "Content-Type": "application/json"
                            },
                            body: (0, strings_js_1.stringify)((0, errors_js_1.serializeError)(new Error(`Unknown probe "${rawProbe}"`))),
                            version: undefined
                        };
                    }
                    // Provide actions for every probe available.
                    const probeActions = {
                        [consts_js_1.probe.Trust]: ()=>({
                                status: 200,
                                headers: {
                                    "Content-Type": "application/json"
                                },
                                body: "",
                                version: undefined
                            })
                    };
                    return probeActions[probe]();
                }
                const fnId = await actions.queryStringWithDefaults("processing run request", consts_js_1.queryKeys.FnId);
                if (!fnId) {
                    // TODO PrettyError
                    throw new Error("No function ID found in request");
                }
                const stepId = await actions.queryStringWithDefaults("processing run request", consts_js_1.queryKeys.StepId) || null;
                const { version, result } = this.runStep({
                    functionId: fnId,
                    data: body,
                    stepId,
                    timer,
                    reqArgs,
                    headers: await headers
                });
                const stepOutput = await result;
                /**
                 * Functions can return `undefined`, but we'll always convert this to
                 * `null`, as this is appropriately serializable by JSON.
                 */ const opDataUndefinedToNull = (op)=>{
                    op.data = (0, functions_js_1.undefinedToNull)(op.data);
                    return op;
                };
                const resultHandlers = {
                    "function-rejected": (result)=>{
                        return {
                            status: result.retriable ? 500 : 400,
                            headers: Object.assign({
                                "Content-Type": "application/json",
                                [consts_js_1.headerKeys.NoRetry]: result.retriable ? "false" : "true"
                            }, typeof result.retriable === "string" ? {
                                [consts_js_1.headerKeys.RetryAfter]: result.retriable
                            } : {}),
                            body: (0, strings_js_1.stringify)((0, functions_js_1.undefinedToNull)(result.error)),
                            version
                        };
                    },
                    "function-resolved": (result)=>{
                        return {
                            status: 200,
                            headers: {
                                "Content-Type": "application/json"
                            },
                            body: (0, strings_js_1.stringify)((0, functions_js_1.undefinedToNull)(result.data)),
                            version
                        };
                    },
                    "step-not-found": (result)=>{
                        return {
                            status: 500,
                            headers: {
                                "Content-Type": "application/json",
                                [consts_js_1.headerKeys.NoRetry]: "false"
                            },
                            body: (0, strings_js_1.stringify)({
                                error: `Could not find step "${result.step.displayName || result.step.id}" to run; timed out`
                            }),
                            version
                        };
                    },
                    "step-ran": (result)=>{
                        const step = opDataUndefinedToNull(result.step);
                        return {
                            status: 206,
                            headers: Object.assign({
                                "Content-Type": "application/json"
                            }, typeof result.retriable !== "undefined" ? Object.assign({
                                [consts_js_1.headerKeys.NoRetry]: result.retriable ? "false" : "true"
                            }, typeof result.retriable === "string" ? {
                                [consts_js_1.headerKeys.RetryAfter]: result.retriable
                            } : {}) : {}),
                            body: (0, strings_js_1.stringify)([
                                step
                            ]),
                            version
                        };
                    },
                    "steps-found": (result)=>{
                        const steps = result.steps.map(opDataUndefinedToNull);
                        return {
                            status: 206,
                            headers: {
                                "Content-Type": "application/json"
                            },
                            body: (0, strings_js_1.stringify)(steps),
                            version
                        };
                    }
                };
                const handler = resultHandlers[stepOutput.type];
                try {
                    return await handler(stepOutput);
                } catch (err) {
                    this.log("error", "Error handling execution result", err);
                    throw err;
                }
            }
            // TODO: This feels hacky, so we should probably make it not hacky.
            const env = (_a = getInngestHeaders()[consts_js_1.headerKeys.Environment]) !== null && _a !== void 0 ? _a : null;
            if (method === "GET") {
                return {
                    status: 200,
                    body: (0, strings_js_1.stringify)(await this.introspectionBody({
                        actions,
                        env,
                        signatureValidation,
                        url
                    })),
                    headers: {
                        "Content-Type": "application/json"
                    },
                    version: undefined
                };
            }
            if (method === "PUT") {
                const [deployId, inBandSyncRequested] = await Promise.all([
                    actions.queryStringWithDefaults("processing deployment request", consts_js_1.queryKeys.DeployId).then((deployId)=>{
                        return deployId === "undefined" ? undefined : deployId;
                    }),
                    Promise.resolve((0, env_js_1.parseAsBoolean)(this.env[consts_js_1.envKeys.InngestAllowInBandSync])).then((allowInBandSync)=>{
                        if (allowInBandSync !== undefined && !allowInBandSync) {
                            return consts_js_1.syncKind.OutOfBand;
                        }
                        return actions.headers("processing deployment request", consts_js_1.headerKeys.InngestSyncKind);
                    }).then((kind)=>{
                        return kind === consts_js_1.syncKind.InBand;
                    })
                ]);
                if (inBandSyncRequested) {
                    if (isMissingBody) {
                        this.log("error", "Missing body when syncing, possibly due to missing request body middleware");
                        return {
                            status: 500,
                            headers: {
                                "Content-Type": "application/json"
                            },
                            body: (0, strings_js_1.stringify)((0, errors_js_1.serializeError)(new Error("Missing request body when syncing, possibly due to missing request body middleware"))),
                            version: undefined
                        };
                    }
                    // Validation can be successful if we're in dev mode and did not
                    // actually validate a key. In this case, also check that we did indeed
                    // use a particular key to validate.
                    const sigCheck = await signatureValidation;
                    if (!sigCheck.success) {
                        return {
                            status: 401,
                            body: (0, strings_js_1.stringify)({
                                code: "sig_verification_failed"
                            }),
                            headers: {
                                "Content-Type": "application/json"
                            },
                            version: undefined
                        };
                    }
                    const res = types_js_1.inBandSyncRequestBodySchema.safeParse(body);
                    if (!res.success) {
                        return {
                            status: 400,
                            body: (0, strings_js_1.stringify)({
                                code: "invalid_request",
                                message: res.error.message
                            }),
                            headers: {
                                "Content-Type": "application/json"
                            },
                            version: undefined
                        };
                    }
                    // We can trust the URL here because it's coming from
                    // signature-verified request.
                    url = this.reqUrl(new URL(res.data.url));
                    // This should be an in-band sync
                    const respBody = await this.inBandRegisterBody({
                        actions,
                        deployId,
                        env,
                        signatureValidation,
                        url
                    });
                    return {
                        status: 200,
                        body: (0, strings_js_1.stringify)(respBody),
                        headers: {
                            "Content-Type": "application/json",
                            [consts_js_1.headerKeys.InngestSyncKind]: consts_js_1.syncKind.InBand
                        },
                        version: undefined
                    };
                }
                // If we're here, this is a legacy out-of-band sync
                const { status, message, modified } = await this.register(this.reqUrl(url), deployId, getInngestHeaders);
                return {
                    status,
                    body: (0, strings_js_1.stringify)({
                        message,
                        modified
                    }),
                    headers: {
                        "Content-Type": "application/json",
                        [consts_js_1.headerKeys.InngestSyncKind]: consts_js_1.syncKind.OutOfBand
                    },
                    version: undefined
                };
            }
        } catch (err) {
            return {
                status: 500,
                body: (0, strings_js_1.stringify)(Object.assign({
                    type: "internal"
                }, (0, errors_js_1.serializeError)(err))),
                headers: {
                    "Content-Type": "application/json"
                },
                version: undefined
            };
        }
        return {
            status: 405,
            body: JSON.stringify({
                message: "No action found; request was likely not POST, PUT, or GET",
                mode: this._mode
            }),
            headers: {},
            version: undefined
        };
    }
    runStep({ functionId, stepId, data, timer, reqArgs, headers }) {
        var _a, _b;
        const fn = this.fns[functionId];
        if (!fn) {
            // TODO PrettyError
            throw new Error(`Could not find function with ID "${functionId}"`);
        }
        const immediateFnData = (0, functions_js_1.parseFnData)(data);
        let { version } = immediateFnData;
        // Handle opting in to optimized parallelism in v3.
        if (version === InngestExecution_js_1.ExecutionVersion.V1 && ((_b = (_a = fn.fn)["shouldOptimizeParallelism"]) === null || _b === void 0 ? void 0 : _b.call(_a))) {
            version = InngestExecution_js_1.ExecutionVersion.V2;
        }
        const result = (0, promises_js_1.runAsPromise)(async ()=>{
            const anyFnData = await (0, functions_js_1.fetchAllFnData)({
                data: immediateFnData,
                api: this.client["inngestApi"],
                version
            });
            if (!anyFnData.ok) {
                throw new Error(anyFnData.error);
            }
            const executionStarters = ((s)=>s)({
                [InngestExecution_js_1.ExecutionVersion.V0]: ({ event, events, steps, ctx, version })=>{
                    var _a, _b, _c;
                    const stepState = Object.entries(steps !== null && steps !== void 0 ? steps : {}).reduce((acc, [id, data])=>{
                        return Object.assign(Object.assign({}, acc), {
                            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
                            [id]: {
                                id,
                                data
                            }
                        });
                    }, {});
                    return {
                        version,
                        partialOptions: {
                            client: this.client,
                            runId: (ctx === null || ctx === void 0 ? void 0 : ctx.run_id) || "",
                            data: {
                                event: event,
                                events: events,
                                runId: (ctx === null || ctx === void 0 ? void 0 : ctx.run_id) || "",
                                attempt: (_a = ctx === null || ctx === void 0 ? void 0 : ctx.attempt) !== null && _a !== void 0 ? _a : 0
                            },
                            stepState,
                            requestedRunStep: stepId === "step" ? undefined : stepId || undefined,
                            timer,
                            isFailureHandler: fn.onFailure,
                            stepCompletionOrder: (_c = (_b = ctx === null || ctx === void 0 ? void 0 : ctx.stack) === null || _b === void 0 ? void 0 : _b.stack) !== null && _c !== void 0 ? _c : [],
                            reqArgs,
                            headers
                        }
                    };
                },
                [InngestExecution_js_1.ExecutionVersion.V1]: ({ event, events, steps, ctx, version })=>{
                    var _a, _b, _c;
                    const stepState = Object.entries(steps !== null && steps !== void 0 ? steps : {}).reduce((acc, [id, result])=>{
                        return Object.assign(Object.assign({}, acc), {
                            [id]: result.type === "data" ? {
                                id,
                                data: result.data
                            } : result.type === "input" ? {
                                id,
                                input: result.input
                            } : {
                                id,
                                error: result.error
                            }
                        });
                    }, {});
                    return {
                        version,
                        partialOptions: {
                            client: this.client,
                            runId: (ctx === null || ctx === void 0 ? void 0 : ctx.run_id) || "",
                            data: {
                                event: event,
                                events: events,
                                runId: (ctx === null || ctx === void 0 ? void 0 : ctx.run_id) || "",
                                attempt: (_a = ctx === null || ctx === void 0 ? void 0 : ctx.attempt) !== null && _a !== void 0 ? _a : 0
                            },
                            stepState,
                            requestedRunStep: stepId === "step" ? undefined : stepId || undefined,
                            timer,
                            isFailureHandler: fn.onFailure,
                            disableImmediateExecution: ctx === null || ctx === void 0 ? void 0 : ctx.disable_immediate_execution,
                            stepCompletionOrder: (_c = (_b = ctx === null || ctx === void 0 ? void 0 : ctx.stack) === null || _b === void 0 ? void 0 : _b.stack) !== null && _c !== void 0 ? _c : [],
                            reqArgs,
                            headers
                        }
                    };
                },
                [InngestExecution_js_1.ExecutionVersion.V2]: ({ event, events, steps, ctx, version })=>{
                    var _a, _b, _c;
                    const stepState = Object.entries(steps !== null && steps !== void 0 ? steps : {}).reduce((acc, [id, result])=>{
                        return Object.assign(Object.assign({}, acc), {
                            [id]: result.type === "data" ? {
                                id,
                                data: result.data
                            } : result.type === "input" ? {
                                id,
                                input: result.input
                            } : {
                                id,
                                error: result.error
                            }
                        });
                    }, {});
                    return {
                        version,
                        partialOptions: {
                            client: this.client,
                            runId: (ctx === null || ctx === void 0 ? void 0 : ctx.run_id) || "",
                            data: {
                                event: event,
                                events: events,
                                runId: (ctx === null || ctx === void 0 ? void 0 : ctx.run_id) || "",
                                attempt: (_a = ctx === null || ctx === void 0 ? void 0 : ctx.attempt) !== null && _a !== void 0 ? _a : 0
                            },
                            stepState,
                            requestedRunStep: stepId === "step" ? undefined : stepId || undefined,
                            timer,
                            isFailureHandler: fn.onFailure,
                            disableImmediateExecution: ctx === null || ctx === void 0 ? void 0 : ctx.disable_immediate_execution,
                            stepCompletionOrder: (_c = (_b = ctx === null || ctx === void 0 ? void 0 : ctx.stack) === null || _b === void 0 ? void 0 : _b.stack) !== null && _c !== void 0 ? _c : [],
                            reqArgs,
                            headers
                        }
                    };
                }
            });
            const executionOptions = await executionStarters[version](anyFnData.value);
            return fn.fn["createExecution"](executionOptions).start();
        });
        return {
            version,
            result
        };
    }
    configs(url) {
        const configs = Object.values(this.rawFns).reduce((acc, fn)=>[
                ...acc,
                ...fn["getConfig"]({
                    baseUrl: url,
                    appPrefix: this.id
                })
            ], []);
        for (const config of configs){
            const check = types_js_1.functionConfigSchema.safeParse(config);
            if (!check.success) {
                const errors = check.error.errors.map((err)=>err.message).join("; ");
                this.log("warn", `Config invalid for function "${config.id}" : ${errors}`);
            }
        }
        return configs;
    }
    /**
     * Return an Inngest serve endpoint URL given a potential `path` and `host`.
     *
     * Will automatically use the `serveHost` and `servePath` if they have been
     * set when registering.
     */ reqUrl(url) {
        let ret = new URL(url);
        const serveHost = this.serveHost || this.env[consts_js_1.envKeys.InngestServeHost];
        const servePath = this.servePath || this.env[consts_js_1.envKeys.InngestServePath];
        if (servePath) {
            ret.pathname = servePath;
        }
        if (serveHost) {
            ret = new URL(ret.pathname + ret.search, serveHost);
        }
        return ret;
    }
    registerBody({ url, deployId }) {
        const body = {
            url: url.href,
            deployType: "ping",
            framework: this.frameworkName,
            appName: this.id,
            functions: this.configs(url),
            sdk: `js:v${version_js_1.version}`,
            v: "0.1",
            deployId: deployId || undefined,
            capabilities: {
                trust_probe: "v1",
                connect: "v1"
            },
            appVersion: this.client.appVersion
        };
        return body;
    }
    async inBandRegisterBody({ actions, deployId, env, signatureValidation, url }) {
        const registerBody = this.registerBody({
            deployId,
            url
        });
        const introspectionBody = await this.introspectionBody({
            actions,
            env,
            signatureValidation,
            url
        });
        const body = {
            app_id: this.id,
            appVersion: this.client.appVersion,
            capabilities: registerBody.capabilities,
            env,
            framework: registerBody.framework,
            functions: registerBody.functions,
            inspection: introspectionBody,
            platform: (0, env_js_1.getPlatformName)(Object.assign(Object.assign({}, (0, env_js_1.allProcessEnv)()), this.env)),
            sdk_author: "inngest",
            sdk_language: "",
            sdk_version: "",
            sdk: registerBody.sdk,
            url: registerBody.url
        };
        if (introspectionBody.authentication_succeeded) {
            body.sdk_language = introspectionBody.sdk_language;
            body.sdk_version = introspectionBody.sdk_version;
        }
        return body;
    }
    async introspectionBody({ actions, env, signatureValidation, url }) {
        var _a, _b, _c, _d, _e;
        const registerBody = this.registerBody({
            url: this.reqUrl(url),
            deployId: null
        });
        if (!this._mode) {
            throw new Error("No mode set; cannot introspect without mode");
        }
        let introspection = {
            authentication_succeeded: null,
            extra: {
                is_mode_explicit: this._mode.isExplicit
            },
            has_event_key: this.client["eventKeySet"](),
            has_signing_key: Boolean(this.signingKey),
            function_count: registerBody.functions.length,
            mode: this._mode.type,
            schema_version: "2024-05-24"
        };
        // Only allow authenticated introspection in Cloud mode, since Dev mode skips
        // signature validation
        if (this._mode.type === "cloud") {
            try {
                const validationResult = await signatureValidation;
                if (!validationResult.success) {
                    throw new Error("Signature validation failed");
                }
                introspection = Object.assign(Object.assign({}, introspection), {
                    authentication_succeeded: true,
                    api_origin: this.apiBaseUrl,
                    app_id: this.id,
                    capabilities: {
                        trust_probe: "v1",
                        connect: "v1"
                    },
                    env,
                    event_api_origin: this.eventApiBaseUrl,
                    event_key_hash: (_a = this.hashedEventKey) !== null && _a !== void 0 ? _a : null,
                    extra: Object.assign(Object.assign({}, introspection.extra), {
                        is_streaming: await this.shouldStream(actions)
                    }),
                    framework: this.frameworkName,
                    sdk_language: "js",
                    sdk_version: version_js_1.version,
                    serve_origin: (_b = this.serveHost) !== null && _b !== void 0 ? _b : null,
                    serve_path: (_c = this.servePath) !== null && _c !== void 0 ? _c : null,
                    signing_key_fallback_hash: (_d = this.hashedSigningKeyFallback) !== null && _d !== void 0 ? _d : null,
                    signing_key_hash: (_e = this.hashedSigningKey) !== null && _e !== void 0 ? _e : null
                });
            } catch (_f) {
                // Swallow signature validation error since we'll just return the
                // unauthenticated introspection
                introspection = Object.assign(Object.assign({}, introspection), {
                    authentication_succeeded: false
                });
            }
        }
        return introspection;
    }
    async register(url, deployId, getHeaders) {
        var _a;
        const body = this.registerBody({
            url,
            deployId
        });
        let res;
        // Whenever we register, we check to see if the dev server is up.  This
        // is a noop and returns false in production. Clone the URL object to avoid
        // mutating the property between requests.
        let registerURL = new URL(this.inngestRegisterUrl.href);
        const inferredDevMode = this._mode && this._mode.isInferred && this._mode.isDev;
        if (inferredDevMode) {
            const host = (0, env_js_1.devServerHost)(this.env);
            const hasDevServer = await (0, devserver_js_1.devServerAvailable)(host, this.fetch);
            if (hasDevServer) {
                registerURL = (0, devserver_js_1.devServerUrl)(host, "/fn/register");
            }
        } else if ((_a = this._mode) === null || _a === void 0 ? void 0 : _a.explicitDevUrl) {
            registerURL = (0, devserver_js_1.devServerUrl)(this._mode.explicitDevUrl.href, "/fn/register");
        }
        if (deployId) {
            registerURL.searchParams.set(consts_js_1.queryKeys.DeployId, deployId);
        }
        try {
            res = await (0, net_js_1.fetchWithAuthFallback)({
                authToken: this.hashedSigningKey,
                authTokenFallback: this.hashedSigningKeyFallback,
                fetch: this.fetch,
                url: registerURL.href,
                options: {
                    method: "POST",
                    body: (0, strings_js_1.stringify)(body),
                    headers: Object.assign(Object.assign({}, getHeaders()), {
                        [consts_js_1.headerKeys.InngestSyncKind]: consts_js_1.syncKind.OutOfBand
                    }),
                    redirect: "follow"
                }
            });
        } catch (err) {
            this.log("error", err);
            return {
                status: 500,
                message: `Failed to register${err instanceof Error ? `; ${err.message}` : ""}`,
                modified: false
            };
        }
        const raw = await res.text();
        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
        let data = {};
        try {
            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
            data = JSON.parse(raw);
        } catch (err) {
            this.log("warn", "Couldn't unpack register response:", err);
            let message = "Failed to register";
            if (err instanceof Error) {
                message += `; ${err.message}`;
            }
            message += `; status code: ${res.status}`;
            return {
                status: 500,
                message,
                modified: false
            };
        }
        let status;
        let error;
        let skipped;
        let modified;
        try {
            ({ status, error, skipped, modified } = registerResSchema.parse(data));
        } catch (err) {
            this.log("warn", "Invalid register response schema:", err);
            let message = "Failed to register";
            if (err instanceof Error) {
                message += `; ${err.message}`;
            }
            message += `; status code: ${res.status}`;
            return {
                status: 500,
                message,
                modified: false
            };
        }
        // The dev server polls this endpoint to register functions every few
        // seconds, but we only want to log that we've registered functions if
        // the function definitions change.  Therefore, we compare the body sent
        // during registration with the body of the current functions and refuse
        // to register if the functions are the same.
        if (!skipped) {
            this.log("debug", "registered inngest functions:", res.status, res.statusText, data);
        }
        return {
            status,
            message: error,
            modified
        };
    }
    /**
     * Given an environment, upsert any missing keys. This is useful in
     * situations where environment variables are passed directly to handlers or
     * are otherwise difficult to access during initialization.
     */ upsertKeysFromEnv() {
        if (this.env[consts_js_1.envKeys.InngestSigningKey]) {
            if (!this.signingKey) {
                this.signingKey = String(this.env[consts_js_1.envKeys.InngestSigningKey]);
            }
            this.client["inngestApi"].setSigningKey(this.signingKey);
        }
        if (this.env[consts_js_1.envKeys.InngestSigningKeyFallback]) {
            if (!this.signingKeyFallback) {
                this.signingKeyFallback = String(this.env[consts_js_1.envKeys.InngestSigningKeyFallback]);
            }
            this.client["inngestApi"].setSigningKeyFallback(this.signingKeyFallback);
        }
        if (!this.client["eventKeySet"]() && this.env[consts_js_1.envKeys.InngestEventKey]) {
            this.client.setEventKey(String(this.env[consts_js_1.envKeys.InngestEventKey]));
        }
        // v2 -> v3 migration warnings
        if (this.env[consts_js_1.envKeys.InngestDevServerUrl]) {
            this.log("warn", `Use of ${consts_js_1.envKeys.InngestDevServerUrl} has been deprecated in v3; please use ${consts_js_1.envKeys.InngestBaseUrl} instead. See https://www.inngest.com/docs/sdk/migration`);
        }
    }
    /**
     * Validate the signature of a request and return the signing key used to
     * validate it.
     */ // eslint-disable-next-line @typescript-eslint/require-await
    async validateSignature(sig, body) {
        try {
            // Skip signature validation if requested (used by connect)
            if (this.skipSignatureValidation) {
                return {
                    success: true,
                    keyUsed: ""
                };
            }
            // Never validate signatures outside of prod. Make sure to check the mode
            // exists here instead of using nullish coalescing to confirm that the check
            // has been completed.
            if (this._mode && !this._mode.isCloud) {
                return {
                    success: true,
                    keyUsed: ""
                };
            }
            // If we're here, we're in production; lack of a signing key is an error.
            if (!this.signingKey) {
                // TODO PrettyError
                throw new Error(`No signing key found in client options or ${consts_js_1.envKeys.InngestSigningKey} env var. Find your keys at https://app.inngest.com/secrets`);
            }
            // If we're here, we're in production; lack of a req signature is an error.
            if (!sig) {
                // TODO PrettyError
                throw new Error(`No ${consts_js_1.headerKeys.Signature} provided`);
            }
            // Validate the signature
            return {
                success: true,
                keyUsed: new RequestSignature(sig).verifySignature({
                    body,
                    allowExpiredSignatures: this.allowExpiredSignatures,
                    signingKey: this.signingKey,
                    signingKeyFallback: this.signingKeyFallback
                })
            };
        } catch (err) {
            return {
                success: false,
                err: err
            };
        }
    }
    getResponseSignature(key, body) {
        const now = Date.now();
        const mac = (0, net_js_1.signDataWithKey)(body, key, now.toString());
        return `t=${now}&s=${mac}`;
    }
    /**
     * Log to stdout/stderr if the log level is set to include the given level.
     * The default log level is `"info"`.
     *
     * This is an abstraction over `console.log` and will try to use the correct
     * method for the given log level.  For example, `log("error", "foo")` will
     * call `console.error("foo")`.
     */ log(level, ...args) {
        const logLevels = [
            "debug",
            "info",
            "warn",
            "error",
            "fatal",
            "silent"
        ];
        const logLevelSetting = logLevels.indexOf(this.logLevel);
        const currentLevel = logLevels.indexOf(level);
        if (currentLevel >= logLevelSetting) {
            let logger = console.log;
            if (Object.prototype.hasOwnProperty.call(console, level)) {
                logger = console[level];
            }
            logger(`${consts_js_1.logPrefix} ${level} -`, ...args);
        }
    }
}
exports.InngestCommHandler = InngestCommHandler;
class RequestSignature {
    constructor(sig){
        _RequestSignature_instances.add(this);
        const params = new URLSearchParams(sig);
        this.timestamp = params.get("t") || "";
        this.signature = params.get("s") || "";
        if (!this.timestamp || !this.signature) {
            // TODO PrettyError
            throw new Error(`Invalid ${consts_js_1.headerKeys.Signature} provided`);
        }
    }
    hasExpired(allowExpiredSignatures) {
        if (allowExpiredSignatures) {
            return false;
        }
        const delta = Date.now() - new Date(parseInt(this.timestamp) * 1000).valueOf();
        return delta > 1000 * 60 * 5;
    }
    verifySignature({ body, signingKey, signingKeyFallback, allowExpiredSignatures }) {
        try {
            __classPrivateFieldGet(this, _RequestSignature_instances, "m", _RequestSignature_verifySignature).call(this, {
                body,
                signingKey,
                allowExpiredSignatures
            });
            return signingKey;
        } catch (err) {
            if (!signingKeyFallback) {
                throw err;
            }
            __classPrivateFieldGet(this, _RequestSignature_instances, "m", _RequestSignature_verifySignature).call(this, {
                body,
                signingKey: signingKeyFallback,
                allowExpiredSignatures
            });
            return signingKeyFallback;
        }
    }
}
_RequestSignature_instances = new WeakSet(), _RequestSignature_verifySignature = function _RequestSignature_verifySignature({ body, signingKey, allowExpiredSignatures }) {
    if (this.hasExpired(allowExpiredSignatures)) {
        // TODO PrettyError
        throw new Error("Signature has expired");
    }
    const mac = (0, net_js_1.signDataWithKey)(body, signingKey, this.timestamp);
    if (mac !== this.signature) {
        // TODO PrettyError
        throw new Error("Invalid signature");
    }
}; //# sourceMappingURL=InngestCommHandler.js.map
}),
"[project]/node_modules/inngest/next.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/**
 * An adapter for Next.js to serve and register any declared functions with
 * Inngest, making them available to be triggered by events.
 *
 * Supports Next.js 12+, both serverless and edge.
 *
 * @example Next.js <=12 or the pages router can export the handler directly
 * ```ts
 * export default serve({ client: inngest, functions: [fn1, fn2] });
 * ```
 *
 * @example Next.js >=13 with the `app` dir must export individual methods
 * ```ts
 * export const { GET, POST, PUT } = serve({
 *            client: inngest,
 *            functions: [fn1, fn2],
 * });
 * ```
 *
 * @module
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.serve = exports.frameworkName = void 0;
const InngestCommHandler_js_1 = __turbopack_context__.r("[project]/node_modules/inngest/components/InngestCommHandler.js [app-route] (ecmascript)");
const env_js_1 = __turbopack_context__.r("[project]/node_modules/inngest/helpers/env.js [app-route] (ecmascript)");
/**
 * The name of the framework, used to identify the framework in Inngest
 * dashboards and during testing.
 */ exports.frameworkName = "nextjs";
const isRecord = (val)=>{
    return typeof val === "object" && val !== null;
};
const isFunction = (val)=>{
    return typeof val === "function";
};
const isNext12ApiResponse = (val)=>{
    return isRecord(val) && isFunction(val.setHeader) && isFunction(val.status) && isFunction(val.send);
};
/**
 * In Next.js, serve and register any declared functions with Inngest, making
 * them available to be triggered by events.
 *
 * Supports Next.js 12+, both serverless and edge.
 *
 * @example Next.js <=12 or the pages router can export the handler directly
 * ```ts
 * export default serve({ client: inngest, functions: [fn1, fn2] });
 * ```
 *
 * @example Next.js >=13 with the `app` dir must export individual methods
 * ```ts
 * export const { GET, POST, PUT } = serve({
 *            client: inngest,
 *            functions: [fn1, fn2],
 * });
 * ```
 *
 * @public
 */ // Has explicit return type to avoid JSR-defined "slow types"
const serve = (options)=>{
    const handler = new InngestCommHandler_js_1.InngestCommHandler(Object.assign(Object.assign({
        frameworkName: exports.frameworkName
    }, options), {
        handler: (reqMethod, ...args)=>{
            const [expectedReq, res] = args;
            const req = expectedReq;
            const getHeader = (key)=>{
                const header = typeof req.headers.get === "function" ? req.headers.get(key) : req.headers[key];
                return Array.isArray(header) ? header[0] : header;
            };
            return {
                // eslint-disable-next-line @typescript-eslint/no-unsafe-return
                body: ()=>typeof req.json === "function" ? req.json() : req.body,
                headers: getHeader,
                method: ()=>{
                    /**
                     * `req.method`, though types say otherwise, is not available in Next.js
                     * 13 {@link https://beta.nextjs.org/docs/routing/route-handlers Route Handlers}.
                     *
                     * Therefore, we must try to set the method ourselves where we know it.
                     */ const method = reqMethod || req.method || "";
                    return method;
                },
                isProduction: ()=>{
                    /**
                     * Vercel Edge Functions do not allow dynamic access to environment
                     * variables, so we'll manage production checks directly here.
                     *
                     * We try/catch to avoid situations where Next.js is being used in
                     * environments where `process.env` is not accessible or polyfilled.
                     */ try {
                        // eslint-disable-next-line @inngest/internal/process-warn
                        const isProd = ("TURBOPACK compile-time value", "development") === "production";
                        return isProd;
                    } catch (err) {
                    // no-op
                    }
                },
                queryString: (key, url)=>{
                    var _a;
                    const qs = ((_a = req.query) === null || _a === void 0 ? void 0 : _a[key]) || url.searchParams.get(key);
                    return Array.isArray(qs) ? qs[0] : qs;
                },
                url: ()=>{
                    let absoluteUrl;
                    try {
                        absoluteUrl = new URL(req.url);
                    } catch (_a) {
                    // no-op
                    }
                    if (absoluteUrl) {
                        /**
                         * `req.url` here should may be the full URL, including query string.
                         * There are some caveats, however, where Next.js will obfuscate
                         * the host. For example, in the case of `host.docker.internal`,
                         * Next.js will instead set the host here to `localhost`.
                         *
                         * To avoid this, we'll try to parse the URL from `req.url`, but
                         * also use the `host` header if it's available.
                         */ const host = options.serveHost || getHeader("host");
                        if (host) {
                            const hostWithProtocol = new URL(host.includes("://") ? host : `${absoluteUrl.protocol}//${host}`);
                            absoluteUrl.protocol = hostWithProtocol.protocol;
                            absoluteUrl.host = hostWithProtocol.host;
                            absoluteUrl.port = hostWithProtocol.port;
                            absoluteUrl.username = hostWithProtocol.username;
                            absoluteUrl.password = hostWithProtocol.password;
                        }
                        return absoluteUrl;
                    }
                    let scheme = "https";
                    const host = options.serveHost || getHeader("host") || "";
                    try {
                        // eslint-disable-next-line @inngest/internal/process-warn
                        if (("TURBOPACK compile-time value", "development") === "development") {
                            scheme = "http";
                        }
                    } catch (err) {
                    // no-op
                    }
                    const url = new URL(req.url, `${scheme}://${host}`);
                    return url;
                },
                transformResponse: ({ body, headers, status })=>{
                    /**
                     * Carefully attempt to set headers and data on the response object
                     * for Next.js 12 support.
                     *
                     * This also assumes that we're not using Next.js 15, where the `res`
                     * object is repopulated as a `RouteContext` object. We expect these
                     * methods to NOT be defined in Next.js 15.
                     *
                     * We could likely use `instanceof ServerResponse` to better check the
                     * type of this, though Next.js 12 had issues with this due to not
                     * instantiating the response correctly.
                     */ if (isNext12ApiResponse(res)) {
                        for (const [key, value] of Object.entries(headers)){
                            res.setHeader(key, value);
                        }
                        res.status(status);
                        res.send(body);
                        /**
                         * If we're here, we're in a serverless endpoint (not edge), so
                         * we've correctly sent the response and can return `undefined`.
                         *
                         * Next.js 13 edge requires that the return value is typed as
                         * `Response`, so we still enforce that as we cannot dynamically
                         * adjust typing based on the environment.
                         */ return undefined;
                    }
                    /**
                     * If we're here, we're in an edge environment and need to return a
                     * `Response` object.
                     *
                     * We also don't know if the current environment has a native
                     * `Response` object, so we'll grab that first.
                     */ const Res = (0, env_js_1.getResponse)();
                    return new Res(body, {
                        status,
                        headers
                    });
                },
                transformStreamingResponse: ({ body, headers, status })=>{
                    return new Response(body, {
                        status,
                        headers
                    });
                }
            };
        }
    }));
    /**
     * Next.js 13 uses
     * {@link https://beta.nextjs.org/docs/routing/route-handlers Route Handlers}
     * to declare API routes instead of a generic catch-all method that was
     * available using the `pages/api` directory.
     *
     * This means that users must now export a function for each method supported
     * by the endpoint. For us, this means requiring a user explicitly exports
     * `GET`, `POST`, and `PUT` functions.
     *
     * Because of this, we'll add circular references to those property names of
     * the returned handler, meaning we can write some succinct code to export
     * them. Thanks, @goodoldneon.
     *
     * @example
     * ```ts
     * export const { GET, POST, PUT } = serve(...);
     * ```
     *
     * See {@link https://beta.nextjs.org/docs/routing/route-handlers}
     */ const baseFn = handler.createHandler();
    const fn = baseFn.bind(null, undefined);
    /**
     * Ensure we have a non-variadic length to avoid issues with forced type
     * checking.
     */ Object.defineProperty(fn, "length", {
        value: 1
    });
    const handlerFn = Object.defineProperties(fn, {
        GET: {
            value: baseFn.bind(null, "GET")
        },
        POST: {
            value: baseFn.bind(null, "POST")
        },
        PUT: {
            value: baseFn.bind(null, "PUT")
        }
    });
    return handlerFn;
};
exports.serve = serve; //# sourceMappingURL=next.js.map
}),
];

//# sourceMappingURL=node_modules_inngest_3ac5a305._.js.map